/*
    artifact generator: /wizzi/lib/artifacts/js/module/gen/main.js
    primary source IttfDocument: c:\my\wizzi\v3\sources\kernel\v3-wizzi-mongodb\ittf\lib\fs\document.js.ittf
    utc time: Tue, 18 Jul 2017 17:11:07 GMT
*/
'use strict';
// generated by js.module.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var path = require('path');
var assert = require('assert');
var async = require('async');
var errors = require('../errors');
var file = require('./file');
var Promise = require('promise');
// var AdmZip = require('adm-zip')
// var archiver = require('archiver')
var JSZip = require('jszip');
var Document = (function () {
    function Document(fsdb) {
        _classCallCheck(this, Document);
        this.fsdb = fsdb;
    }
    Document.prototype.uploadFolder = function(folderPath,options,callback) {
        if (typeof callback === 'undefined') {
            callback = options;
            options = {
                deep: true, 
                documentContent: true
            };
        }
        options.documentContent = true;
        var that = this;
        folderPath = normalize(path.resolve(folderPath));
        var documents = file.getFiles(folderPath, {
            deep: true, 
            documentContent: true
        })
        ;
        // log 'uploadFolder.documents', folderPath, options, documents
        var d, len = documents.length;
        var uploaded = [];
        function repeater(index) {
            if (index === len) {
                return callback(null, uploaded);
            }
            d = documents[index];
            that.writeFile(d.file, d.content, function(err, uploadR) {
                if (err) {
                    return callback(err)
                    ;
                }
                uploaded.push({
                    d: d, 
                    result: uploadR.result
                });
                process.nextTick(function() {
                    repeater(index + 1);
                });
            });
        }
        repeater(0);
    }
    Document.prototype.createFolder = function(folderPath,callback) {
        folderPath = normalize(path.resolve(folderPath));
        var parts = folderPath.split('/');
        var dirname = [];
        var insertedId = null;
        var parentFsItemId = null;
        var lastInserted = null;
        // log 'Document.createFolder.parts', parts
        var that = this;
        var item, len = parts.length;
        function repeater(index) {
            if (index === len) {
                return callback(null, lastInserted);
            }
            item = parts[index];
            var dirnameS = dirname.join('/');
            dirname.push(item);
            var pathS = dirname.join('/');
            that.fsdb.insertItem({
                basename: item, 
                parentId: parentFsItemId, 
                dirname: dirnameS, 
                path: pathS, 
                kind: 0
            }, function(err, r) {
                if (err) {
                    return callback(err)
                    ;
                }
                // log 'Document.createFolder.r', r
                lastInserted = r;
                if (r.code === 'FSITEM_EXISTS') {
                    if (r.kind == 1) {
                        throw Error('MongoFS createFolder error: ' + folderPath + ' is or contains a document path');
                    }
                    insertedId = r.item._id;
                }
                else {
                    insertedId = r.insertedId;
                }
                parentFsItemId = insertedId;
                process.nextTick(function() {
                    repeater(index + 1);
                });
            });
        }
        repeater(0);
    }
    Document.prototype.getFolder = function(folderPath,callback) {
        folderPath = normalize(path.resolve(folderPath));
        this.fsdb.getItemByPath(folderPath, function(err, r) {
            if (err) {
                return callback(err)
                ;
            }
            if (r && r.kind == 1) {
                throw Error('MongoFS getFolder error: ' + folderPath + ' is a document path');
            }
            console.log('Document.getFolder.r', r);
            callback(null, r);
        });
    }
    Document.prototype.getDir = function(folderPath,options,callback) {
        
        if (typeof callback === 'undefined') {
            callback = options;
            options = {};
        }
        
        folderPath = normalize(path.resolve(folderPath));
        
        var that = this;
        
        this.fsdb.getItemByPath(folderPath, function(err, r) {
            if (err) {
                return callback(err)
                ;
            }
            if (r) {
                that.fsdb.getItemChildren(r._id, function(err, fsitems) {
                    if (err) {
                        return callback(err)
                        ;
                    }
                    return callback(null, fsitems);
                });
            }
            else {
                return callback(null, []);
            }
        });
    }
    Document.prototype.getFiles = function(folderPath,options,callback) {
        
        if (typeof callback === 'undefined') {
            callback = options;
            options = {};
        }
        
        folderPath = normalize(path.resolve(folderPath));
        var deep = options.deep;
        var extension = options.extension;
        var documentContent = options.documentContent;
        
        var that = this;
        function get_files_Async(singleFolderPath, callback) {
            
            that.fsdb.getItemByPath(singleFolderPath, function(err, r) {
                if (err) {
                    return callback(err)
                    ;
                }
                if (r) {
                    that.fsdb.getItemChildren(r._id, function(err, fsitems) {
                        if (err) {
                            return callback(err)
                            ;
                        }
                        return callback(null, fsitems);
                    });
                }
                else {
                    return callback(null, null);
                }
            });
        }
        function get_folders_files_Async(folderPaths, callback) {
            async.map(folderPaths, get_files_Async, function(err, fsitems) {
                if (err) {
                    return callback(err)
                    ;
                }
                return callback(null, fsitems);
            });
        }
        function recurser(folderPaths, files) {
            return new Promise(function(resolve) {
                    get_folders_files_Async(folderPaths, function(err, fsitemsArray) {
                        if (err) {
                            return callback(err)
                            ;
                        }
                        console.log('****** fsitemsArray', fsitemsArray);
                        var subfolders = [];
                        var i, i_len=fsitemsArray.length, fsitems;
                        for (i=0; i<i_len; i++) {
                            fsitems = fsitemsArray[i];
                            if (fsitems != null) {
                                var j, j_len=fsitems.length, item;
                                for (j=0; j<j_len; j++) {
                                    item = fsitems[j];
                                    if (item.kind == 0) {
                                        subfolders.push(item.path);
                                    }
                                    else {
                                        if (!extension || item.path.substr(-extension.length) === extension) {
                                            files.push(item.path);
                                        }
                                    }
                                }
                            }
                        }
                        if (deep && subfolders.length > 0) {
                            recurser(subfolders, files).then(function() {
                                resolve();
                            })
                            ;
                        }
                        else {
                            resolve();
                        }
                    });
                });
        }
        var files = [];
        recurser([folderPath], files).then(function() {
            console.log('getFiles', files);
            return callback(null, files);
        })
        ;
    }
    Document.prototype.exists = function(itemPath,callback) {
        itemPath = normalize(path.resolve(itemPath));
        this.fsdb.getItemByPath(itemPath, function(err, fsitem) {
            if (err) {
                return callback(err)
                ;
            }
            if (fsitem) {
                callback(null, true);
            }
            else {
                callback(null, false);
            }
        });
    }
    Document.prototype.isFolder = function(folderPath,callback) {
        folderPath = normalize(path.resolve(folderPath));
        this.fsdb.getItemByPath(folderPath, function(err, fsitem) {
            if (err) {
                return callback(err)
                ;
            }
            if (fsitem && fsitem.kind == 0) {
                callback(null, true);
            }
            else {
                callback(null, false);
            }
        });
    }
    Document.prototype.isFile = function(filePath,callback) {
        filePath = normalize(path.resolve(filePath));
        this.fsdb.getItemByPath(filePath, function(err, fsitem) {
            if (err) {
                return callback(err)
                ;
            }
            if (fsitem && fsitem.kind == 1) {
                callback(null, true);
            }
            else {
                callback(null, false);
            }
        });
    }
    Document.prototype.copyFile = function(sourcePath,destPath,callback) {
        var sourcePath = normalize(path.resolve(sourcePath));
        var destPath = normalize(path.resolve(destPath));
        if (sourcePath === destPath) {
            return callback(null, {})
            ;
        }
        var that = this;
        this.readFile(sourcePath, function(err, source) {
            if (err) {
                return callback(err)
                ;
            }
            console.log('Document.copyFile.source', source);
            that.writeFile(destPath, source, function(err, r) {
                if (err) {
                    return callback(err)
                    ;
                }
                console.log('Document.copyFile.r', r);
                return callback(null, r);
            });
        });
    }
    Document.prototype.copyFolder = function(sourcePath,destPath,callback) {
        sourcePath = normalize(path.resolve(sourcePath));
        destPath = normalize(path.resolve(destPath));
        if (sourcePath === destPath) {
            return callback(null, {})
            ;
        }
        var that = this;
        var copies = [];
        this.getFiles(sourcePath, {
            deep: true
        }, function(err, files) {
            if (err) {
                return callback(err)
                ;
            }
            var sourcefile,
                destfile,
                files_len = files.length;
            function repeater(index) {
                if (index === files_len) {
                    return callback(null, copies);
                }
                sourcefile = files[index];
                destfile = sourcefile.replace(sourcePath, destPath);
                that.copyFile(sourcefile, destfile, function(err, r) {
                    if (err) {
                        return callback(err)
                        ;
                    }
                    copies.push(r);
                    process.nextTick(function() {
                        repeater(index + 1);
                    });
                });
            }
            repeater(0);
        });
    }
    Document.prototype.deleteFile = function(filePath,callback) {
        filePath = normalize(path.resolve(filePath));
        var that = this;
        this.fsdb.getItemByPath(filePath, function(err, fsitem) {
            if (err) {
                return callback(err)
                ;
            }
            if (fsitem == null) {
                var error = new errors.FsItemNotFoundError('File', filePath);
                return callback(error)
                ;
            }
            if (fsitem.kind == 0) {
                var error = new errors.InvalidRequestError('MongoFS error. Is a folder path, not a fila path: ' + filePath, '');
                return callback(error)
                ;
            }
            that.fsdb.deleteItem(fsitem._id, function(err, r) {
                if (err) {
                    return callback(err)
                    ;
                }
                console.log('Document.deleteFile.r', r);
                return callback(null, r)
                ;
            });
        });
    }
    Document.prototype.deleteFolder = function(folderPath,callback) {
        folderPath = normalize(path.resolve(folderPath));
        var that = this;
        this.fsdb.getItemByPath(folderPath, function(err, fsitem) {
            if (err) {
                return callback(err)
                ;
            }
            if (fsitem == null) {
                return callback(error('deleteFolder', 'Folder not found: ' + folderPath)
                    )
                ;
            }
            if (fsitem.kind == 1) {
                return callback(error('deleteFolder', 'Is a file path, not a folder path: ' + folderPath)
                    )
                ;
            }
            that.fsdb.getItemChildren(fsitem._id, function(err, children) {
                if (err) {
                    return callback(err)
                    ;
                }
                console.log('Document.deleteFolder.children', children);
                if (children.length > 0) {
                    return callback(error('deleteFolder', 'Folder not empty: ' + folderPath)
                        )
                    ;
                }
                else {
                    that.fsdb.deleteItem(fsitem._id, function(err, r) {
                        if (err) {
                            return callback(err)
                            ;
                        }
                        console.log('Document.deleteFolder.r', r);
                        assert( true, r.deleted );
                        return callback(null, r);
                    });
                }
            });
        });
    }
    Document.prototype.renameFile = function(oldPath,newPath,callback) {
        oldPath = normalize(path.resolve(oldPath));
        newPath = normalize(path.resolve(newPath));
        if (oldPath === newPath) {
            return callback(null, {})
            ;
        }
        var oldDirname = normalize(path.dirname(oldPath));
        var newDirname = normalize(path.dirname(newPath));
        var oldName = path.basename(oldPath);
        var newName = path.basename(newPath);
        if (oldDirname !== newDirname) {
            return callback(error('renameFile', 'Old and new path must have the same base folder: ' + oldPath + ' - ' + newPath)
                )
            ;
        }
        if (oldName === newName) {
            return callback(null, {
                    renamed: false, 
                    message: 'oldPath and newPath are the same'
                })
            ;
        }
        var that = this;
        this.fsdb.getItemByPath(oldPath, function(err, fsitem) {
            if (err) {
                return callback(err)
                ;
            }
            if (fsitem == null) {
                return error('renameFile', 'Folder not found: ' + oldPath)
                ;
            }
            if (fsitem.kind == 0) {
                return error('renameFile', 'Is a folder path, not a file path: ' + oldPath)
                ;
            }
            console.log('renameFile.fsitem', fsitem);
            fsitem.basename = newName;
            fsitem.path = normalize(path.join(fsitem.dirname, fsitem.basename));
            that.fsdb.updateItem(fsitem, function(err, r) {
                if (err) {
                    return callback(err)
                    ;
                }
                return callback(null, r);
            });
        });
    }
    Document.prototype.renameFolder = function(oldPath,newPath,callback) {
        oldPath = normalize(path.resolve(oldPath));
        newPath = normalize(path.resolve(newPath));
        if (oldPath === newPath) {
            return callback(null, {})
            ;
        }
        var oldDirname = normalize(path.dirname(oldPath));
        var newDirname = normalize(path.dirname(newPath));
        var oldName = path.basename(oldPath);
        var newName = path.basename(newPath);
        if (oldDirname !== newDirname) {
            return callback(error('renameFolder', 'Old and new path must have the same base folder: ' + oldPath + ' - ' + newPath)
                )
            ;
        }
        if (oldName === newName) {
            return callback(null, {
                    renamed: false, 
                    message: 'oldPath and newPath are the same'
                })
            ;
        }
        var that = this;
        this.fsdb.getItemByPath(oldPath, function(err, fsitem) {
            if (err) {
                return callback(err)
                ;
            }
            if (fsitem == null) {
                return error('renameFolder', 'Folder not found: ' + oldPath)
                ;
            }
            if (fsitem.kind == 1) {
                return error('renameFolder', 'Is a file path, not a folder path: ' + oldPath)
                ;
            }
            console.log('renameFolder.fsitem', fsitem);
            fsitem.basename = newName;
            fsitem.path = normalize(path.join(fsitem.dirname, fsitem.basename));
            that._changeParentFolder(fsitem, function(err, changes) {
                if (err) {
                    return callback(err)
                    ;
                }
                console.log('renameFolder.changes', changes);
                that.fsdb.updateItem(fsitem, function(err, r) {
                    if (err) {
                        return callback(err)
                        ;
                    }
                    return callback(null, r);
                });
            });
        });
    }
    Document.prototype._changeParentFolder = function(fsitemParent,callback) {
        var that = this;
        function change_dirnames_Async(fsitems, newDirname, callback) {
            
            var i, i_len=fsitems.length, item;
            for (i=0; i<i_len; i++) {
                item = fsitems[i];
                console.log('change_dirnames_Async', item);
                item.dirname = newDirname;
                item.path = normalize(path.join(item.dirname, item.basename));
            }
            async.mapSeries(fsitems, function(fsitem, callback) {
                that.fsdb.updateItem(fsitem, function(err, r) {
                    if (err) {
                        return callback(err)
                        ;
                    }
                    return callback(null, r.item);
                });
            }, function(err, newfsitems) {
                if (err) {
                    return callback(err)
                    ;
                }
                return callback(null, newfsitems);
            });
        }
        function recurser(fsitemParent, changes) {
            return new Promise(function(resolve) {
                    that.fsdb.getItemChildren(fsitemParent._id, function(err, fsitems) {
                        if (err) {
                            return callback(err)
                            ;
                        }
                        // log 'children of ', fsitemParent._id, fsitemParent.path, fsitems.length
                        if (fsitems.length > 0) {
                            change_dirnames_Async(fsitems, fsitemParent.path, function(err, updfsitems) {
                                if (err) {
                                    return callback(err)
                                    ;
                                }
                                var i, i_len=updfsitems.length, upd;
                                for (i=0; i<i_len; i++) {
                                    upd = updfsitems[i];
                                    console.log('upd', upd);
                                    changes.push(upd.path);
                                    recurser(upd, changes).then(function() {
                                        console.log('resolve');
                                        resolve();
                                    })
                                    ;
                                }
                            });
                        }
                        else {
                            console.log('last resolve');
                            resolve();
                        }
                    });
                });
        }
        var changes = [];
        recurser(fsitemParent, changes).then(function() {
            console.log('_changeParentFolder ended', changes);
            return callback(null, changes);
        })
        ;
    }
    Document.prototype.uploadFolder = function(folderPath,options,callback) {
        if (typeof callback === 'undefined') {
            callback = options;
            options = {
                deep: true, 
                documentContent: true
            };
        }
        options.documentContent = true;
        var that = this;
        folderPath = normalize(path.resolve(folderPath));
        var documents = file.getFiles(folderPath, {
            deep: true, 
            documentContent: true
        })
        ;
        // log 'uploadFolder.documents', folderPath, options, documents
        var d, len = documents.length;
        var uploaded = [];
        function repeater(index) {
            if (index === len) {
                return callback(null, uploaded);
            }
            d = documents[index];
            that.writeFile(d.file, d.content, function(err, uploadR) {
                if (err) {
                    return callback(err)
                    ;
                }
                uploaded.push({
                    d: d, 
                    result: uploadR.result
                });
                process.nextTick(function() {
                    repeater(index + 1);
                });
            });
        }
        repeater(0);
    }
    Document.prototype.downloadFolder = function(folderPath,options,callback) {
        
        if (typeof callback === 'undefined') {
            callback = options;
            options = {};
        }
        
        var that = this;
        
        function read_file_Async(singleFilePath, callback) {
            
            that.readFile(singleFilePath, function(err, content) {
                if (err) {
                    return callback(err)
                    ;
                }
                console.log('content', content);
                return callback(null, {
                        path: singleFilePath, 
                        content: content
                    })
                ;
            });
        }
        this.getFiles(folderPath, {
            deep: true
        }, function(err, files) {
            if (err) {
                return callback(err)
                ;
            }
            async.map(files, read_file_Async, function(err, fileContents) {
                if (err) {
                    return callback(err)
                    ;
                }
                console.log('download fileContents', fileContents);
                // var zip = new AdmZip()
                /**
                    var zip = archiver('zip', {
                        zlib: {
                            level: 9
                        }
                    })
                    ;
                    zip.pipe(options.pipe)*/
                var zip = new JSZip();
                var i, i_len=fileContents.length, item;
                for (i=0; i<i_len; i++) {
                    item = fileContents[i];
                    /**
                        zip.addFile(item.path, new Buffer(item.content))
                        zip.append(item.content, {
                            name: item.path
                        })
                    */
                    zip.file(item.path, item.content);
                }
                /**
                    return callback(null, zip.toBuffer())
                    ;
                */
                return callback(null, zip)
                ;
            });
        });
    }
    Document.prototype._createFile = function(parentId,dirname,basename,content,callback) {
        var that = this;
        this.fsdb.insertItem({
            basename: basename, 
            parentId: parentId, 
            dirname: dirname, 
            path: normalize(path.join(dirname, basename)), 
            kind: 1
        }, function(err, r) {
            if (err) {
                return callback(err)
                ;
            }
            // log '_createFile.x1.inserted', r.insertedId
            that.fsdb.writeFile(r.insertedId, content, callback);
        });
    }
    Document.prototype._updateFile = function(id,content,callback) {
        // log '_updateFile', id, content
        this.fsdb.writeFile(id, content, callback);
    }
    Document.prototype.writeFile = function(filePath,content,callback) {
        filePath = normalize(path.resolve(filePath));
        var that = this;
        // log 'writeFile.init', filePath
        this.fsdb.getItemByPath(filePath, function(err, fsitem) {
            if (err) {
                return callback(err)
                ;
            }
            if (fsitem != null) {
                // log 'writeFile.1.exists update', filePath
                return that._updateFile(fsitem._id, content, callback)
                ;
            }
            else {
                var dirname = path.dirname(filePath);
                // log 'writeFile.2.not exists. try get dirname', dirname
                that.fsdb.getItemByPath(dirname, function(err, fsitem) {
                    if (err) {
                        return callback(err)
                        ;
                    }
                    if (fsitem != null) {
                        // log 'writeFile.3. dirname exists create file', fsitem._id, dirname, path.basename(filePath)
                        return that._createFile(fsitem._id, dirname, path.basename(filePath), content, callback)
                        ;
                    }
                    else {
                        // log 'writeFile.4.dirname not exists.create dirname', dirname
                        that.createFolder(dirname, function(err, fsitem) {
                            if (err) {
                                return callback(err)
                                ;
                            }
                            // log 'writeFile.5.dirname created.create file', fsitem.item._id, dirname, path.basename(filePath)
                            return that._createFile(fsitem.item._id, dirname, path.basename(filePath), content, callback)
                            ;
                        });
                    }
                });
            }
        });
    }
    Document.prototype.readFile = function(filePath,callback) {
        filePath = normalize(path.resolve(filePath));
        var that = this;
        this.fsdb.getItemByPath(filePath, function(err, fsitem) {
            if (err) {
                return callback(err)
                ;
            }
            if (fsitem == null) {
                var error = new errors.FsItemNotFoundError('File', filePath);
                return callback(error)
                ;
            }
            else if (fsitem.kind == 0) {
                var error = new errors.InvalidRequestError('MongoFS error. Cannot read a folder: ' + filePath, '');
                return callback(error)
                ;
            }
            else {
                that.fsdb.readFile(fsitem._id, function(err, content) {
                    if (err) {
                        return callback(err)
                        ;
                    }
                    return callback(null, content);
                });
            }
        });
    }
    return Document;
})();


function error(method,message) {
    return {
            __is_error: true, 
            method: 'Mongo.Document.' + method, 
            message: message
        };
}

function normalize(path) {
    return path.trim().replace(/\\/g,'/').toLowerCase();
}

module.exports = Document;
