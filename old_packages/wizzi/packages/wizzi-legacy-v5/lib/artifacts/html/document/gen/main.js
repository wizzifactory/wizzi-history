/*
    artifact generator: C:\My\wizzi\v4\node_modules\v4-wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v4\plugins\wizzi-html\src\ittf\lib\artifacts\html\document\gen\main.js.ittf
    utc time: Wed, 11 Oct 2017 11:41:46 GMT
*/
'use strict';
// generated by wizzi.codegen.js.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var util = require('util');
//Unsupported in v5 var codegen = require('wizzi-legacy-v4-codegen');
//Unsupported in v5 var js_statement = codegen.jsStatement;
var css_rule = require('./css_rule');
var verify = require('../../../util/verify');
var utilNode = require('../../../util/utilNode');
var lineParser = require('../../../util/lineParser');
var md = module.exports = {};
var myname = 'htm1.document.main';
md.gen = function(model, ctx, callback) {
    // log 'model', util.inspect(model, { depth: 1 })
    new Gen().genItem(model, ctx);
    callback(null, ctx);
};
var Gen = (function () {
    function Gen() {
        _classCallCheck(this, Gen);
    }
    Gen.prototype.genItems = function(items, ctx, options) {
        var opt = options || {},
            from = opt.from || 0,
            indent = typeof opt.indent === 'undefined' ? true : opt.indent;
        if (indent) {
            ctx.indent();
        }
        for (var i = from; i < items.length; i++) {
            var item = items[i];
            this.genItem(item, ctx);
        }
        if (indent) {
            ctx.deindent();
        }
    }
    Gen.prototype.genItem = function(model, ctx) {
        if (['_text','_textLF'].indexOf(model.wzElement) >= 0) {
            // model.wzName is a TEXTNODE
            // preserve a blank first char (coded between single hyphens)
            var text = verify.startsWith(model.wzName, "' '") ? '&nbsp;' + model.wzName.substr(3) : model.wzName;
            if (ctx.__iscode || model.wzElement === '_textLF') {
                ctx.w(text);
            }
            else {
                ctx.write(text);
            }
            this.genItems(model.elements, ctx);
            return ;
        }
        if (this[model.wzElement]) {
            // known element
            if (this[model.wzElement](model, ctx)) {
                // ok, processed
                return ;
            }
        }
        this.preprocess(model, ctx);
        var voidEl = (model.wzTag in voidElements);
        ctx.write('<' + model.wzTag);
        var i, i_len=getAttrs(model).length, a;
        for (i=0; i<i_len; i++) {
            a = getAttrs(model)[i];
            if ((a.name in attrsneedsvalue) || a.value && a.value.length > 0) {
                ctx.write(' ' + a.name + '="' + verify.unquote(a.value || '') + '"');
            }
            else {
                ctx.write(' ' + a.name);
            }
        }
        ctx.write('>');
        if (voidEl) {
            ctx.w();
            this.postprocess(model, ctx);
            return ;
        }
        // check if the element has text line coded as children of the $. ittf command
        var lt = utilNode.lineToText(model.wzName);
        if (lt.text) {
            // preserve a blank first char (coded between single hyphens)
            var text = verify.startsWith(lt.text, "' '") ? '&nbsp;' + lt.text.substr(3) : lt.text;
            ctx.write(text);
        }
        if (lt.lines) {
            ctx.w();
            var saveIndent;
            if (ctx.__ispre) {
                // we are inside a pre element, temporaly reset
                // to 0 the indentation depending from the node depth
                saveIndent = ctx.forceIndent(0);
            }
            else {
                ctx.indent();
            }
            var i, i_len=lt.lines.length, line;
            for (i=0; i<i_len; i++) {
                line = lt.lines[i];
                ctx.w(line);
            }
            if (ctx.__ispre) {
                // restore indentation
                ctx.forceIndent(saveIndent);
            }
            else {
                ctx.deindent();
            }
        }
        if (model.elements && model.elements.length > 0) {
            if (ctx.__ispre && !ctx.__ispre_started) {
                ctx.w('');
                ctx.__ispre_started = true;
                var saveIndent = ctx.forceIndent(0);
                this.genItems(model.elements, ctx);
                ctx.forceIndent(saveIndent);
                ctx.__ispre_started = false;
            }
            else {
                var noinline = inline.indexOf(model.wzTag) < 0;
                if (noinline) {
                    ctx.w('');
                }
                this.genItems(model.elements, ctx, { indent: noinline});
            }
        }
        ctx.w('</' + model.wzTag + '>');
        this.postprocess(model, ctx);
    }
    Gen.prototype.preprocess = function(model, ctx) {
        if (model.wzTag == '.') {
            model.wzTag = 'div';
            model.class = model.wzName;
            model.wzName = null;
        }
        else if (model.wzTag == '#') {
            model.wzTag = 'div';
            model.id = model.wzName;
            model.wzName = null;
        }
        else if (model.wzTag == '<') {
            model.wzTag = model.wzName;
            model.wzName = null;
        }
        else if (model.wzTag == 'js') {
            model.wzTag = 'script';
            model.src = model.wzName;
            model.wzName = null;
        }
        else if (model.wzTag === 'css') {
            model.wzTag = 'link';
            model.href = model.wzName;
            model.rel = 'stylesheet';
            model.wzName = null;
        }
        else if (model.wzTag === '@title') {
            model.wzTag = 'title';
        }
        else if (model.wzTag === '@style') {
            model.wzTag = 'style';
        }
        if (incode.indexOf(model.wzTag) > -1) {
            ctx.__iscode = true;
        }
        if (['pre'].indexOf(model.wzTag) > -1) {
            ctx.__ispre = true;
        }
    }
    Gen.prototype.postprocess = function(model, ctx) {
        if (incode.indexOf(model.wzTag) > -1) {
            ctx.__iscode = false;
        }
        if (['pre'].indexOf(model.wzTag) > -1) {
            ctx.__ispre = false;
        }
    }
    Gen.prototype.html = function(model, ctx) {
        if (model.doctype) {
            ctx.w('<!doctype ' + model.doctype + '>');
        }
        else {
            ctx.w('<!doctype html>');
        }
        ctx.write('<html');
        var i, i_len=getAttrs(model).length, a;
        for (i=0; i<i_len; i++) {
            a = getAttrs(model)[i];
            if (a.name != 'doctype') {
                if ((a.name in attrsneedsvalue) || a.value && a.value.length > 0) {
                    ctx.write(' ' + a.name + '="' + verify.unquote(a.value || '') + '"');
                }
                else {
                    ctx.write(' ' + a.name);
                }
            }
        }
        ctx.w('>');
        this.genItems(model.elements, ctx);
        ctx.w();
        ctx.w('</html>');
        return true;
    }
    Gen.prototype._css = function(model, ctx) {
        if (model.rules.length === 0) {
            // is link to a stylesheet not a style element
            return false;
        }
        ctx.w("<style>");
        css_rule.genItems(model.rules, ctx);
        ctx.w("</style>");
        return true;
    }
    Gen.prototype._js = function (model, ctx) {
        throw ctx.error(myname + 'js statements unsuported in legacy v5: ' + model.wzName, model);
        if (model.statements.length === 0) {
            // is link to a js file not a script element
            return false;
        }
        ctx.w("<script>");
        var i, i_len=model.statements.length, item;
        for (i=0; i<i_len; i++) {
            item = model.statements[i];
            js_statement.gen(item, ctx);
        }
        ctx.w("</script>");
        return true;
    }
    Gen.prototype.ready = function (model, ctx) {
        throw ctx.error(myname + 'js statements unsuported in legacy v5: ' + model.wzName, model);
        ctx.w("<script>");
        ctx.indent();
        if (model.kind === 'jquery') {
            ctx.w('$(function() {');
            ctx.indent();
            var i, i_len=model.statements.length, item;
            for (i=0; i<i_len; i++) {
                item = model.statements[i];
                js_statement.gen(item, ctx);
            }
            ctx.deindent();
            ctx.w('});');
        }
        else {
            ctx.w('window.onload = function() {');
            ctx.indent();
            var i, i_len=model.statements.length, item;
            for (i=0; i<i_len; i++) {
                item = model.statements[i];
                js_statement.gen(item, ctx);
            }
            ctx.deindent();
            ctx.w('};');
        }
        ctx.deindent();
        ctx.w("</script>");
        return true;
    }
    Gen.prototype.comment = function(model, ctx) {
        if (ctx.__iscode) {
            ctx.w("// " + model.wzName);
        }
        else {
            ctx.w("<!-- " + model.wzName + " -->");
        }
        return true;
    }
    return Gen;
})();

var noattrs = [
    'wzTag', 
    'wzName', 
    'wzElement', 
    'wzParent', 
    'wzSourceLineInfo', 
    '___exportName'
];
function isAttrValue(a, v) {
    if (noattrs.indexOf(a) > -1) {
        return false;
    }
    if (v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)) {
        return false;
    }
    return true;
}
function getAttrs(e) {
    var retval = [];
    for (var a in e) {
        if (isAttrValue(a, e[a])) {
            retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] });
        }
        else if (a.substr(0, 3) === 'ng-') {
            retval.push({ name: a, value: e[a] });
        }
        else if (a.substr(0, 5) === 'data-') {
            retval.push({ name: a, value: e[a] });
        }
        else if (a.substr(0, 5) === 'aria-') {
            retval.push({ name: a, value: e[a] });
        }
    }
    if (e.attributes) {
        var i, i_len=e.attributes.length, a;
        for (i=0; i<i_len; i++) {
            a = e.attributes[i];
            var p = lineParser.parseNameValueRaw(a.wzName, a);
            if (p.hasValue()) {
                retval.push({ name: p.name(), value: p.value() });
            }
            else {
                retval.push({ name: p.name() });
            }
        }
    }
    return retval;
}
var inline = [
    'a', 
    'img', 
    'input', 
    'li', 
    'textarea'
];
var incode = [
    'js', 
    'css', 
    'script', 
    'style', 
    'ready'
];
var attrsneedsvalue = {
    __proto__: null
};
var voidElements = {
    __proto__:  null, 
    area:  true, 
    base:  true, 
    basefont:  true, 
    br:  true, 
    col:  true, 
    command:  true, 
    embed:  true, 
    frame:  true, 
    hr:  true, 
    img:  true, 
    input:  true, 
    isindex:  true, 
    keygen:  true, 
    link:  true, 
    meta:  true, 
    param:  true, 
    source:  true, 
    track:  true, 
    wbr:  true, 
    // common self closing svg elements
    path:  true, 
    circle:  true, 
    ellipse:  true, 
    line:  true, 
    rect:  true, 
    use:  true, 
    stop:  true, 
    polyline:  true, 
    polygone:  true
};
