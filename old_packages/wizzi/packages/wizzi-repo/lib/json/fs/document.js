/*
    artifact generator: C:\My\wizzi\v5\node_modules\wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v5\kernel\wizzi-repo\src\ittf\lib\json\fs\document.js.ittf
*/
'use strict';
// generated by wizzi.codegen.js4.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var verify = require('wizzi-utils').verify;
var path = require('path');
var assert = require('assert');
var async = require('async');
var vfile = require('wizzi-utils').vfile;
var verify = require('wizzi-utils').verify;
var jsonUriParser = require('wizzi-utils').uriParser;
var errors = require('../../errors');
var FsStream = require('../../utils/fsstream');
var Promise = require('promise');
var JSZip = require('jszip');
var FsJson = null;
var Document = (function () {
    function Document(fsCommon) {
        _classCallCheck(this, Document);
        assert( true, fsCommon.classType === 'wizzi-repo.json.FsJson' );
        assert( true, !!fsCommon.items && fsCommon.items.classType === 'wizzi-repo.utils.Collection');
        assert( true, !!fsCommon.documents && fsCommon.documents.classType === 'wizzi-repo.utils.Collection');
        this.classType = 'wizzi-repo.json.Document';
        
        this.fsCommon = fsCommon;
        
    }
    Document.prototype.createFolder = function(folderPath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'createFolder', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(folderPath) === false) {
            return callback(error(
                'InvalidArgument', 'createFolder', { parameter: 'folderPath', message: 'The folderPath parameter must be a string. Received: ' + folderPath }
            ));
        }
        folderPath = normalize(folderPath);
        var parts = folderPath.split('/');
        var dirname = [];
        var insertedId = null;
        var parentFsItemId = null;
        var lastInserted = null;
        // log 'wizzi-repo.fs.json.document.createFolder.parts', parts
        var that = this;
        var item, len = parts.length;
        function repeater(index) {
            if (index === len) {
                return callback(null, lastInserted);
            }
            item = parts[index];
            if (item.length == 0) {
                return process.nextTick(function() {
                        repeater(index + 1);
                    });
            }
            var dirnameS = dirname.join('/');
            dirname.push(item);
            var pathS = dirname.join('/');
            // log 'wizzi-repo.fs.json.document.createFolder.item,dirnameS,pathS', item , dirnameS, pathS
            that.fsCommon.insertItem({
                basename: item, 
                parentId: parentFsItemId, 
                dirname: dirnameS, 
                path: pathS, 
                kind: 0
            }, function(err, r) {
                if (err) {
                    return callback(err);
                }
                // log 'wizzi-repo.fs.json.document.createFolder.r', r
                lastInserted = r;
                if (r.code === 'FSITEM_EXISTS') {
                    if (r.kind == 1) {
                        throw Error('JsonFS createFolder error: ' + folderPath + ' is or contains a document path');
                    }
                    insertedId = r.item._id;
                }
                else {
                    insertedId = r.insertedId;
                }
                parentFsItemId = insertedId;
                process.nextTick(function() {
                    repeater(index + 1);
                });
            });
        }
        repeater(0);
    }
    Document.prototype.getFolder = function(folderPath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'getFolder', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(folderPath) === false) {
            return callback(error(
                'InvalidArgument', 'getFolder', { parameter: 'folderPath', message: 'The folderPath parameter must be a string. Received: ' + folderPath }
            ));
        }
        folderPath = normalize(folderPath);
        this.fsCommon.getItemByPath(folderPath, function(err, r) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-repo.fs.json.document.getFolder.r', r
            if (r.kind == 1) {
                return callback(error('JsonFSRepoError', 'getFolder', 'Document getFolder error: ' + folderPath + ' is a file path'));
            }
            else {
                return callback(null, r);
            }
        });
    }
    Document.prototype.getDir = function(folderPath, options, callback) {
        if (verify.isFunction(callback) === false && verify.isFunction(options) === true) {
            callback = options;
            options = {};
        }
        if (verify.isFunction(callback) === false) {
            throw new Error(
                error('InvalidArgument', 'getDir', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(folderPath) === false) {
            return error(
                'InvalidArgument', 'getDir', { parameter: 'folderPath', message: 'The folderPath parameter must be a string. Received: ' + folderPath }
            );
        }
        
        folderPath = normalize(folderPath);
        
        var that = this;
        
        this.fsCommon.getItemByPath(folderPath, function(err, r) {
            if (err) {
                return callback(err);
            }
            if (r) {
                that.fsCommon.getItemChildren(r._id, function(err, fsitems) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, fsitems);
                });
            }
            else {
                return callback(null, []);
            }
        });
    }
    Document.prototype.getFiles = function(folderPath, options, callback) {
        if (verify.isFunction(callback) === false && verify.isFunction(options) === true) {
            callback = options;
            options = {};
        }
        if (verify.isFunction(callback) === false) {
            throw new Error(
                error('InvalidArgument', 'getFiles', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(folderPath) === false) {
            return error(
                'InvalidArgument', 'getFiles', { parameter: 'folderPath', message: 'The folderPath parameter must be a string. Received: ' + folderPath }
            );
        }
        
        folderPath = normalize(folderPath, true);
        var deep = options.deep;
        var extension = options.extension;
        var documentContent = options.documentContent || false;
        
        var that = this;
        function get_files_Async(singleFolderPath, callback) {
            // log 'wizzi-repo.fs.json.document.get_files_Async', singleFolderPath
            
            that.fsCommon.getItemByPath(singleFolderPath, function(err, r) {
                if (err) {
                    return callback(err);
                }
                // log 'wizzi-repo.fs.json.document.get_files_Async.r', r
                if (r) {
                    that.fsCommon.getItemChildren(r._id, function(err, r2) {
                        // log 'wizzi-repo.fs.json.document.getItemChildren.err.r2', err, r2
                        if (err) {
                            return callback(err);
                        }
                        else {
                            return callback(null, r2);
                        }
                    });
                }
                else {
                    return callback(null, null);
                }
            });
        }
        function recurser(folderPaths, files, ids, basenames) {
            return new Promise(function(resolve, reject) {
                    async.map(folderPaths, get_files_Async, function(err, fsitemsArray) {
                        // log 'wizzi-repo.fs.json.document.getfiles err, fsitemsArray', err, fsitemsArray
                        if (err) {
                            return reject(err);
                        }
                        var subfolders = [];
                        var i, i_items=fsitemsArray, i_len=fsitemsArray.length, fsitems;
                        for (i=0; i<i_len; i++) {
                            fsitems = fsitemsArray[i];
                            if (fsitems != null) {
                                var j, j_items=fsitems, j_len=fsitems.length, item;
                                for (j=0; j<j_len; j++) {
                                    item = fsitems[j];
                                    if (item.kind == 0) {
                                        subfolders.push(item.path);
                                    }
                                    else {
                                        if (!extension || item.path.substr(-extension.length) === extension) {
                                            files.push(item.path);
                                            ids.push(item._id);
                                            basenames.push(item.basename);
                                        }
                                    }
                                }
                            }
                        }
                        if (deep && subfolders.length > 0) {
                            recurser(subfolders, files, ids, basenames).then(function() {
                                resolve();
                            });
                        }
                        else {
                            resolve();
                        }
                    });
                });
        }
        var files = [];
        var ids = [];
        var basenames = [];
        recurser([folderPath], files, ids, basenames).then(function() {
            // log 'wizzi-repo.fs.json.document.getfiles', 'folderPath', folderPath, 'files', files, 'ids', ids, 'documentContent', documentContent
            if (!documentContent) {
                return callback(null, files);
            }
            else {
                that.getContentsByIds(ids, function(err, contents) {
                    if (err) {
                        return callback(err);
                    }
                    // log 'wizzi-repo.fs.json.document.getfiles.contents', contents
                    var ret = [];
                    for (var i=0; i<files.length; i++) {
                        ret.push({
                            basename: basenames[i], 
                            path: files[i], 
                            fullPath: files[i], 
                            content: contents[i]
                        });
                    }
                    return callback(null, ret);
                });
            }
        }).catch(function(err) {
            return callback(err);
        })
        ;
    }
    Document.prototype.getContentsByIds = function(ids, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'getContentsByIds', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isArray(ids) === false) {
            return callback(error(
                'InvalidArgument', 'getContentsByIds', { parameter: 'ids', message: 'The ids parameter must be an array. Received: ' + ids }
            ));
        }
        
        var fsCommon = this.fsCommon;
        
        async.map(ids, function(id, callback) {
            console.log('wizzi-repo.fs.json.document.getContentsByIds', id);
            fsCommon.readDocument(id, callback);
        }, callback);
    }
    Document.prototype.exists = function(itemPath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'exists', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(itemPath) === false) {
            return callback(error(
                'InvalidArgument', 'exists', { parameter: 'itemPath', message: 'The itemPath parameter must be a string. Received: ' + itemPath }
            ));
        }
        itemPath = normalize(path.resolve(itemPath));
        this.fsCommon.getItemByPath(itemPath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            if (fsitem) {
                return callback(null, true);
            }
            else {
                return callback(null, false);
            }
        });
    }
    Document.prototype.isFolder = function(folderPath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'isFolder', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(folderPath) === false) {
            return callback(error(
                'InvalidArgument', 'isFolder', { parameter: 'folderPath', message: 'The folderPath parameter must be a string. Received: ' + folderPath }
            ));
        }
        folderPath = normalize(folderPath);
        this.fsCommon.getItemByPath(folderPath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            if (fsitem && fsitem.kind == 0) {
                return callback(null, true);
            }
            else {
                return callback(null, false);
            }
        });
    }
    Document.prototype.isFile = function(filePath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'isFile', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(filePath) === false) {
            return callback(error(
                'InvalidArgument', 'isFile', { parameter: 'filePath', message: 'The filePath parameter must be a string. Received: ' + filePath }
            ));
        }
        filePath = normalize(filePath);
        this.fsCommon.getItemByPath(filePath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            if (fsitem && fsitem.kind == 1) {
                return callback(null, true);
            }
            else {
                return callback(null, false);
            }
        });
    }
    Document.prototype.copyFile = function(sourcePath, destPath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'copyFile', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(sourcePath) === false) {
            return callback(error(
                'InvalidArgument', 'copyFile', { parameter: 'sourcePath', message: 'The sourcePath parameter must be a string. Received: ' + sourcePath }
            ));
        }
        if (verify.isNotEmpty(destPath) === false) {
            return callback(error(
                'InvalidArgument', 'copyFile', { parameter: 'destPath', message: 'The destPath parameter must be a string. Received: ' + destPath }
            ));
        }
        var sourcePath = normalize(sourcePath);
        var destPath = normalize(destPath);
        if (sourcePath === destPath) {
            return callback(null, {});
        }
        var that = this;
        this.readFile(sourcePath, function(err, source) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-repo.fs.json.document.copyFile.source', source
            that.exists(destPath, function(err, result) {
                if (err) {
                    return callback(err);
                }
                if (result === true) {
                    return callback(error('JsonFSRepoError', 'copyFile', 'Document copy file error. The destination path already exists: ' + destPath));
                }
                else {
                    that.writeFile(destPath, source, function(err, r) {
                        if (err) {
                            return callback(err);
                        }
                        console.log('wizzi-repo.fs.json.document.copyFile.r', r);
                        return callback(null, {
                                code: "DOCUMENT_COPIED"
                            });
                    });
                }
            });
        });
    }
    Document.prototype.copyFolder = function(sourcePath, destPath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'copyFolder', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(sourcePath) === false) {
            return callback(error(
                'InvalidArgument', 'copyFolder', { parameter: 'sourcePath', message: 'The sourcePath parameter must be a string. Received: ' + sourcePath }
            ));
        }
        if (verify.isNotEmpty(destPath) === false) {
            return callback(error(
                'InvalidArgument', 'copyFolder', { parameter: 'destPath', message: 'The destPath parameter must be a string. Received: ' + destPath }
            ));
        }
        sourcePath = normalize(sourcePath);
        destPath = normalize(destPath);
        if (sourcePath === destPath) {
            console.log('wizzi-repo.t.fscommon.document.copyFolder. sourcePath === destPath');
            return callback(null, {});
        }
        var that = this;
        var copies = [];
        console.log('wizzi-repo.t.fscommon.document.getFiles.before');
        this.getFiles(sourcePath, {
            deep: true
        }, function(err, files) {
            if (err) {
                return callback(err);
            }
            console.log('wizzi-repo.t.fscommon.document.copyFolder. files', files.length);
            var sourcefile,
                destfile,
                files_len = files.length;
            function repeater(index) {
                if (index === files_len) {
                    return callback(null, copies);
                }
                sourcefile = files[index];
                destfile = sourcefile.replace(sourcePath, destPath);
                that.copyFile(sourcefile, destfile, function(err, r) {
                    if (err) {
                        return callback(err);
                    }
                    copies.push(r);
                    process.nextTick(function() {
                        repeater(index + 1);
                    });
                });
            }
            repeater(0);
        });
    }
    Document.prototype.deleteFile = function(filePath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'deleteFile', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(filePath) === false) {
            return callback(error(
                'InvalidArgument', 'deleteFile', { parameter: 'filePath', message: 'The filePath parameter must be a string. Received: ' + filePath }
            ));
        }
        filePath = normalize(filePath);
        var that = this;
        this.fsCommon.getItemByPath(filePath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            if (fsitem == null) {
                return callback(error('JsonFSRepoError', 'deleteFolder', 'Document delete file error. Item not found: ' + filePath));
            }
            if (fsitem.kind == 0) {
                return callback(error('JsonFSRepoError', 'deleteFolder', 'Document delete file error. Is a folder path, not a file path: ' + filePath));
            }
            that.fsCommon.deleteItem(fsitem._id, function(err, r) {
                if (err) {
                    return callback(err);
                }
                // log 'wizzi-repo.fs.json.document.deleteFile.r', r
                return callback(null, r);
            });
        });
    }
    Document.prototype.deleteFolder = function(folderPath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'deleteFolder', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(folderPath) === false) {
            return callback(error(
                'InvalidArgument', 'deleteFolder', { parameter: 'folderPath', message: 'The folderPath parameter must be a string. Received: ' + folderPath }
            ));
        }
        folderPath = normalize(folderPath);
        var that = this;
        this.fsCommon.getItemByPath(folderPath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            if (fsitem == null) {
                return callback(error('JsonFSRepoError', 'deleteFolder', 'Document folder not found: ' + folderPath));
            }
            if (fsitem.kind == 1) {
                return callback(error('JsonFSRepoError', 'deleteFolder', 'Is a file path, not a folder path: ' + folderPath));
            }
            that.fsCommon.getItemChildren(fsitem._id, function(err, children) {
                if (err) {
                    return callback(err);
                }
                console.log('wizzi-repo.fs.json.document.deleteFolder.children', children);
                if (children.length > 0) {
                    return callback(error('JsonFSRepoError', 'deleteFolder', 'Folder not empty: ' + folderPath));
                }
                else {
                    that.fsCommon.deleteItem(fsitem._id, function(err, r) {
                        if (err) {
                            return callback(err);
                        }
                        console.log('wizzi-repo.fs.json.document.deleteFolder.r', r);
                        assert( true, r.deleted );
                        return callback(null, r);
                    });
                }
            });
        });
    }
    Document.prototype.renameFile = function(oldPath, newPath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'renameFile', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(oldPath) === false) {
            return callback(error(
                'InvalidArgument', 'renameFile', { parameter: 'oldPath', message: 'The oldPath parameter must be a string. Received: ' + oldPath }
            ));
        }
        if (verify.isNotEmpty(newPath) === false) {
            return callback(error(
                'InvalidArgument', 'renameFile', { parameter: 'newPath', message: 'The newPath parameter must be a string. Received: ' + newPath }
            ));
        }
        oldPath = normalize(path.resolve(oldPath));
        newPath = normalize(path.resolve(newPath));
        if (oldPath === newPath) {
            return callback(null, {});
        }
        var oldDirname = normalize(path.dirname(oldPath));
        var newDirname = normalize(path.dirname(newPath));
        var oldName = path.basename(oldPath);
        var newName = path.basename(newPath);
        if (oldDirname !== newDirname) {
            return callback(error('InvalidArgument', 'renameFile', 'Document rename file error. Old and new path must have the same base folder: ' + oldDirname + ' !== ' + newDirname));
        }
        if (oldName === newName) {
            return callback(null, {
                    renamed: false, 
                    message: 'oldPath and newPath are the same'
                });
        }
        var that = this;
        this.fsCommon.getItemByPath(oldPath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            if (fsitem == null) {
                return callback(error('JsonFSRepoError', 'renameFile', 'Document rename file error. Old path not found: ' + oldPath));
            }
            if (fsitem.kind == 0) {
                return callback(error('JsonFSRepoError', 'renameFile', 'Document rename file error. Is a folder path, not a file path: ' + oldPath));
            }
            // log 'wizzi-repo.fs.json.document.renameFile.fsitem', fsitem
            that.exists(newPath, function(err, r) {
                if (err) {
                    return callback(err);
                }
                if (r === true) {
                    return callback(error('JsonFSRepoError', 'renameFile', 'Document rename file error. The new path already exists: ' + newPath));
                }
                else {
                    fsitem.basename = newName;
                    fsitem.path = normalize(path.join(fsitem.dirname, fsitem.basename));
                    that.fsCommon.updateItem(fsitem, function(err, r) {
                        if (err) {
                            return callback(err);
                        }
                        return callback(null, {
                                code: "DOCUMENT_RENAMED", 
                                id: r.item._id
                            });
                    });
                }
            });
        });
    }
    Document.prototype.renameFolder = function(oldPath, newPath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'renameFolder', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(oldPath) === false) {
            return callback(error(
                'InvalidArgument', 'renameFolder', { parameter: 'oldPath', message: 'The oldPath parameter must be a string. Received: ' + oldPath }
            ));
        }
        if (verify.isNotEmpty(newPath) === false) {
            return callback(error(
                'InvalidArgument', 'renameFolder', { parameter: 'newPath', message: 'The newPath parameter must be a string. Received: ' + newPath }
            ));
        }
        oldPath = normalize(path.resolve(oldPath));
        newPath = normalize(path.resolve(newPath));
        if (oldPath === newPath) {
            return callback(null, {});
        }
        var oldDirname = normalize(path.dirname(oldPath));
        var newDirname = normalize(path.dirname(newPath));
        var oldName = path.basename(oldPath);
        var newName = path.basename(newPath);
        if (oldDirname !== newDirname) {
            return callback(error('InvalidArgument', 'renameFile', 'Document rename folder error. Old and new path must have the same base folder: ' + oldDirname + ' !== ' + newDirname));
        }
        if (oldName === newName) {
            return callback(null, {
                    renamed: false, 
                    message: 'oldPath and newPath are the same'
                });
        }
        var that = this;
        this.fsCommon.getItemByPath(oldPath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            if (fsitem == null) {
                return callback(error('JsonFSRepoError', 'renameFolder', 'Document rename folder error. Old path not found: ' + oldPath));
            }
            if (fsitem.kind == 1) {
                return callback(error('JsonFSRepoError', 'renameFolder', 'Document rename folder error. Is a file path, not a folder path: ' + oldPath));
            }
            console.log('wizzi-repo.fs.json.document.renameFolder.fsitem', fsitem);
            that.exists(newPath, function(err, r) {
                if (err) {
                    return callback(err);
                }
                if (r === true) {
                    return callback(error('JsonFSRepoError', 'renameFile', 'Document rename folder error. The new path already exists: ' + newPath));
                }
                else {
                    fsitem.basename = newName;
                    fsitem.path = normalize(path.join(fsitem.dirname, fsitem.basename));
                    that._changeParentFolder(fsitem, function(err, changes) {
                        if (err) {
                            return callback(err);
                        }
                        console.log('wizzi-repo.fs.json.document.renameFolder.changes', changes);
                        that.fsCommon.updateItem(fsitem, function(err, r) {
                            if (err) {
                                return callback(err);
                            }
                            return callback(null, r);
                        });
                    });
                }
            });
        });
    }
    Document.prototype._changeParentFolder = function(fsitemParent, callback) {
        var that = this;
        function change_dirnames_Async(fsitems, newDirname, callback) {
            
            var i, i_items=fsitems, i_len=fsitems.length, item;
            for (i=0; i<i_len; i++) {
                item = fsitems[i];
                console.log('wizzi-repo.fs.json.document.renameFolder.change_dirnames_Async', item);
                item.dirname = newDirname;
                item.path = normalize(path.join(item.dirname, item.basename));
            }
            async.mapSeries(fsitems, function(fsitem, callback) {
                that.fsCommon.updateItem(fsitem, function(err, r) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, r.item);
                });
            }, function(err, newfsitems) {
                if (err) {
                    return callback(err);
                }
                return callback(null, newfsitems);
            });
        }
        function recurser(fsitemParent, changes) {
            return new Promise(function(resolve) {
                    that.fsCommon.getItemChildren(fsitemParent._id, function(err, fsitems) {
                        if (err) {
                            return callback(err);
                        }
                        // log 'wizzi-repo.fs.json.document.renameFolder.children of ', fsitemParent._id, fsitemParent.path, fsitems.length
                        if (fsitems.length > 0) {
                            change_dirnames_Async(fsitems, fsitemParent.path, function(err, updfsitems) {
                                if (err) {
                                    return callback(err);
                                }
                                var i, i_items=updfsitems, i_len=updfsitems.length, upd;
                                for (i=0; i<i_len; i++) {
                                    upd = updfsitems[i];
                                    console.log('wizzi-repo.fs.json.document.renameFolder.upd', upd);
                                    changes.push(upd.path);
                                    recurser(upd, changes).then(function() {
                                        console.log('wizzi-repo.fs.json.document.renameFolder.resolve');
                                        resolve();
                                    });
                                }
                            });
                        }
                        else {
                            console.log('wizzi-repo.fs.json.document.renameFolder.last resolve');
                            resolve();
                        }
                    });
                });
        }
        var changes = [];
        recurser(fsitemParent, changes).then(function() {
            console.log('wizzi-repo.fs.json.document.renameFolder._changeParentFolder ended', changes);
            return callback(null, changes);
        });
    }
    Document.prototype.uploadFolder = function(sourcePath, destPath, options, callback) {
        if (verify.isFunction(callback) === false && verify.isFunction(options) === true) {
            callback = options;
            options = {};
        }
        if (verify.isFunction(callback) === false) {
            throw new Error(
                error('InvalidArgument', 'uploadFolder', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(sourcePath) === false) {
            return error(
                'InvalidArgument', 'uploadFolder', { parameter: 'sourcePath', message: 'The sourcePath parameter must be a string. Received: ' + sourcePath }
            );
        }
        if (verify.isNotEmpty(destPath) === false) {
            return error(
                'InvalidArgument', 'uploadFolder', { parameter: 'destPath', message: 'The destPath parameter must be a string. Received: ' + destPath }
            );
        }
        options.documentContent = true;
        var that = this;
        sourcePath = normalize(sourcePath);
        destPath = normalize(destPath);
        // use disk filesystem
        vfile(function(err, file) {
            if (err) {
                return callback(err);
            }
            var documents = file.getFiles(sourcePath, {
                deep: true, 
                documentContent: true
            });
            // log 'wizzi-repo.fs.json.document.uploadFolder.documents', sourcePath, options, documents
            var d, destFilePath, len = documents.length;
            var uploaded = [];
            function repeater(index) {
                if (index === len) {
                    return callback(null, uploaded);
                }
                d = documents[index];
                destFilePath = path.join(destPath, d.relPath);
                if (d.content && d.content.length > 0) {
                    that.writeFile(destFilePath, d.content, function(err, r) {
                        if (err) {
                            return callback(err);
                        }
                        uploaded.push({
                            relPath: d.relPath, 
                            dest: destFilePath, 
                            result: r
                        });
                        process.nextTick(function() {
                            repeater(index + 1);
                        });
                    });
                }
                else {
                    repeater(index + 1);
                }
            }
            repeater(0);
        });
    }
    Document.prototype.downloadFolder = function(folderPath, options, callback) {
        if (verify.isFunction(callback) === false && verify.isFunction(options) === true) {
            callback = options;
            options = {};
        }
        if (verify.isFunction(callback) === false) {
            throw new Error(
                error('InvalidArgument', 'downloadFolder', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(folderPath) === false) {
            return error(
                'InvalidArgument', 'downloadFolder', { parameter: 'folderPath', message: 'The folderPath parameter must be a string. Received: ' + folderPath }
            );
        }
        
        var that = this;
        
        function read_file_Async(singleFilePath, callback) {
            
            that.readFile(singleFilePath, function(err, content) {
                if (err) {
                    return callback(err);
                }
                console.log('wizzi-repo.JsonFS.document.download.content', content);
                return callback(null, {
                        path: singleFilePath, 
                        content: content
                    });
            });
        }
        this.getFiles(folderPath, {
            deep: true
        }, function(err, files) {
            if (err) {
                return callback(err);
            }
            async.map(files, read_file_Async, function(err, fileContents) {
                if (err) {
                    return callback(err);
                }
                console.log('wizzi-repo.JsonFS.document.download.fileContents', fileContents);
                var zip = new JSZip();
                var i, i_items=fileContents, i_len=fileContents.length, item;
                for (i=0; i<i_len; i++) {
                    item = fileContents[i];
                    zip.file(item.path, item.content);
                }
                return callback(null, zip);
            });
        });
    }
    Document.prototype._createFile = function(parentId, dirname, basename, content, callback) {
        var that = this;
        this.fsCommon.insertItem({
            basename: basename, 
            parentId: parentId, 
            dirname: dirname, 
            path: normalize(path.join(dirname, basename)), 
            kind: 1
        }, function(err, r) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-repo.fs.json.document.writeFile._createFile.r', r
            if (r.code === 'FSITEM_EXISTS') {
                that.fsCommon.writeDocument(r.item._id, content, callback);
            }
            else {
                that.fsCommon.writeDocument(r.insertedId, content, callback);
            }
        });
    }
    Document.prototype._updateFile = function(id, content, callback) {
        // log 'wizzi-repo.fs.json.document.writeFile._updateFile', id, content
        this.fsCommon.writeDocument(id, content, callback);
    }
    Document.prototype.writeFile = function(filePath, content, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'writeFile', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(filePath) === false) {
            return callback(error(
                'InvalidArgument', 'writeFile', { parameter: 'filePath', message: 'The filePath parameter must be a string. Received: ' + filePath }
            ));
        }
        if (verify.isNullOrUndefined(content) === false) {
            if (verify.isNotEmpty(content) === false) {
                return callback(error(
                    'InvalidArgument', 'writeFile', { parameter: 'content', message: 'The content parameter must be a string. Received: ' + content }
                ));
            }
        }
        console.log('wizzi-repo.fs.json.document.writeFile.writeFile.init', filePath);
        filePath = normalize(filePath);
        console.log('wizzi-repo.fs.json.document.writeFile.writeFile.normalized', filePath);
        var that = this;
        this.fsCommon.getItemByPath(filePath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            if (fsitem != null) {
                console.log('wizzi-repo.fs.json.document.writeFile.writeFile.1.exists, so update', filePath);
                return that._updateFile(fsitem._id, content, callback);
            }
            else {
                var dirname = path.dirname(filePath);
                console.log('wizzi-repo.fs.json.document.writeFile.writeFile.2.not exists. try get dirname', dirname);
                that.fsCommon.getItemByPath(dirname, function(err, fsitem) {
                    if (err) {
                        return callback(err);
                    }
                    if (fsitem != null) {
                        console.log('wizzi-repo.fs.json.document.writeFile.writeFile.3. dirname exists create file', fsitem._id, dirname, path.basename(filePath));
                        return that._createFile(fsitem._id, dirname, path.basename(filePath), content, callback);
                    }
                    else {
                        console.log('wizzi-repo.fs.json.document.writeFile.writeFile.4.dirname not exists.create dirname', dirname);
                        that.createFolder(dirname, function(err, fsitem) {
                            if (err) {
                                return callback(err);
                            }
                            console.log('wizzi-repo.fs.json.document.writeFile.writeFile.5.dirname created. so create file', fsitem.item._id, dirname, path.basename(filePath));
                            return that._createFile(fsitem.item._id, dirname, path.basename(filePath), content, callback);
                        });
                    }
                });
            }
        });
    }
    Document.prototype.createWriteStream = function(filePath) {
        if (verify.isNotEmpty(filePath) === false) {
            return error(
                'InvalidArgument', 'createWriteStream', { parameter: 'filePath', message: 'The filePath parameter must be a string. Received: ' + filePath }
            );
        }
        filePath = normalize(filePath);
        return new FsStream(filePath, this);
    }
    Document.prototype.readFile = function(filePath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'readFile', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(filePath) === false) {
            return callback(error(
                'InvalidArgument', 'readFile', { parameter: 'filePath', message: 'The filePath parameter must be a string. Received: ' + filePath }
            ));
        }
        // log 'wizzi-repo.t.fsCommon.readFile.filePath before', filePath
        // set filePath = denormalize(filePath)
        filePath = normalize(filePath);
        console.log('wizzi-repo.t.fsCommon.readFile.normalized.filePath before', filePath);
        var that = this;
        this.fsCommon.getItemByPath(filePath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            if (fsitem == null) {
                that.fsCommon.toJson(function(err, json) {
                    if (err) {
                        return callback(err);
                    }
                    // log 'fsJson.readFile not found', JSON.stringify(json, null, 4)
                    return callback(error('JsonFSRepoError', 'readFile', 'Document read file error. Not found: ' + filePath));
                });
            }
            else if (fsitem.kind == 0) {
                return callback(error('JsonFSRepoError', 'readFile', 'Document read file error. Cannot read a folder: ' + filePath));
            }
            else {
                that.fsCommon.readDocument(fsitem._id, callback);
            }
        });
    }
    Document.prototype.stat = function(filePath, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'stat', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(filePath) === false) {
            return callback(error(
                'InvalidArgument', 'stat', { parameter: 'filePath', message: 'The filePath parameter must be a string. Received: ' + filePath }
            ));
        }
        this.fsCommon.getItemByPath(filePath, function(err, fsitem) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-repo.fs.json.document.stat.filePath', filePath, 'fsitem', fsitem
            if (fsitem == null) {
                return callback(null, {
                        isDirectory: function() {
                            return false;
                        }, 
                        isFile: function() {
                            return false;
                        }
                    });
            }
            else {
                return callback(null, {
                        isDirectory: function() {
                            return fsitem.kind == 0;
                        }, 
                        isFile: function() {
                            return fsitem.kind == 1;
                        }
                    });
            }
        });
    }
    Document.prototype.toJson = function(callback) {
        return this.fsCommon.toJson(callback);
    }
    Document.prototype.close = function() {
        if (this.fsCommon) {
            this.fsCommon.close();
            this.fsCommon = null;
        }
    }
    return Document;
})();

/** -àà
     Creates a Document instance
*/
Document.create = function(jsonFsData, callback) {
    
    if (verify.isUndefined(callback) && verify.isFunction(jsonFsData)) {
        callback = jsonFsData;
        jsonFsData = null;
    }
    
    if (FsJson == null) {
        FsJson = require('./fsjson');
    }
    return callback(null, new Document(new FsJson(jsonFsData)));
};
function error(method, message) {
    return {
            __is_error: true, 
            method: 'Json.Fs.Document.' + method, 
            message: message
        };
}
function normalize(path, stripEndingSlash) {
    if (stripEndingSlash) {
        var ret = path.trim().replace(/\\/g,'/').toLowerCase();
        var parsedUri = jsonUriParser(ret.substr(-1) === '/' ? ret.substr(0, ret.length-1) : ret);
        return parsedUri.internalPath;
    }
    else {
        var parsedUri = jsonUriParser(path.trim().replace(/\\/g,'/').toLowerCase());
        return parsedUri.internalPath;
    }
}
function denormalize(path) {
    return path.trim().replace(/\//g,'\\').toLowerCase();
}
module.exports = Document;
/**
  params
    string code
      # the error name or number
    string method
    string message
      # optional
    { innerError
      # optional
*/
function error(code, method, message, innerError) {
    var parameter = null;
    if (verify.isObject(message)) {
        parameter = message.parameter;
        message = message.message;
    }
    return verify.error(innerError, {
        name: ( verify.isNumber(code) ? 'Err-' + code : code ),
        method: 'wizzi-repo.fs.json.Document.' + method,
        parameter: parameter,
        sourcePath: __filename
    }, message || 'Error message unavailable');
}
