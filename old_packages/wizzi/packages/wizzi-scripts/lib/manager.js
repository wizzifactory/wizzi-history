/*
    artifact generator: C:\My\wizzi\v5\node_modules\wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v5\kernel\wizzi-scripts\src\ittf\lib\manager.js.ittf
*/
'use strict';
// generated by wizzi.codegen.js4.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var path = require('path');
var util = require('util');
var file = require('wizzi-utils').file;
var verify = require('wizzi-utils').verify;
var cp = require("child_process");
var robocopy = require('robocopy');
var powershell = require('node-powershell');
// var npm = require('npm')
var babelParser = null;
var babelCore = null;
var prettier = null;
var webpack = null;
var MemoryFS = null;
var memoryFS = null;
const DEFAULT_PRETTIER_CONFIG = {
    bracketSpacing: true, 
    jsxBracketSameLine: false, 
    parser: "babylon", 
    printWidth: 80, 
    semi: true, 
    singleQuote: false, 
    tabWidth: 2, 
    trailingComma: "none", 
    useTabs: false
};
var Manager = (function () {
    function Manager() {
        _classCallCheck(this, Manager);
    }
    Manager.prototype.robocopyExec = function(options, callback) {
        robocopy({
            source: options.source, 
            destination: options.destination, 
            serial: options.serial, 
            files: [
                
            ], 
            copy: {
                subdirs: true, 
                emptySubdirs: true, 
                purge: true, 
                // Mirrors a directory tree (equivalent to copy.emptySubdirs plus copy.purge). [/mir]
                mirror: true, 
                // Moves files, and deletes them from the source after they are copied. [/mov]
                moveFiles: false, 
                // Moves files and directories, and deletes them from the source after they
                // are copied. [/move]
                moveFilesAndDirs: false, 
                // Copies the symbolic link instead of the target. [/sl]
                symbolicLink: false
            }, 
            file: {
                // Excludes files that match the specified names or paths. Note that FileName
                // can include wildcard characters (* and ?). [/xf <FileName>[ ...]]
                excludeFiles: [
                    
                ], 
                // Excludes directories that match the specified names and paths.
                // [/xd <Directory>[ ...]]
                excludeDirs: [
                    
                ]
            }
        }).done(function(stdout) {
            console.log('wizzi-scripts.manager.robocopyExec.stdout', stdout);
            if (callback) {
                return callback(null, {
                        error: false, 
                        stdout: stdout.join('\n')
                    });
            }
        });
    }
    Manager.prototype.robocopyExecToEventStream = function(options, res, callback) {
        this.robocopyExec(options, function(err, result) {
            if (err) {
                return callback(err);
            }
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
            });
            if (result.error) {
                res.write('stderr: ' + result.stderr);
                res.end('data: ***___CLOSE___***\n\n');
            }
            else {
                console.log('wizzi-scripts.robocopyExecToEventStream', result.stdout);
                var str;
                var lines = result.stdout.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    else {
                        // Note: The double-newline is *required*
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
                if (str.length > 0) {
                    res.write('data: ' + str + "\n\n");
                }
                res.end('data: ***___CLOSE___***\n\n');
            }
            if (callback) {
                return callback(null, result);
            }
        });
    }
    Manager.prototype.powershellExec = function(options, callback) {
        var ps = new powershell({
            executionPolicy: 'Bypass', 
            verbose: true, 
            version: 3
        });
        console.log('wizzi-script.manager.powershellExec.options', JSON.stringify(options, null, 2));
        if (options.params) {
            ps.addCommand(options.scriptPath, options.params);
        }
        else {
            ps.addCommand(options.scriptPath);
        }
        ps.invoke().then((output) => {
            console.log(output);
            console.log('wizzi-script.manager.powershellExec.output', output);
            if (callback) {
                return callback(null, {
                        error: false, 
                        stdout: output
                    });
            }
        }).catch((err) => {
            console.log('wizzi-script.manager.powershellExec.err', err);
            ps.dispose();
            if (callback) {
                callback(null, {
                    error: true, 
                    stderr: err
                });
            }
        });
    }
    Manager.prototype.powershellExecToEventStream = function(options, res, callback) {
        this.powershellExec({
            scriptPath: options.scriptPath, 
            params: options.params
        }, function(err, result) {
            if (err) {
                return callback(err);
            }
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
            });
            if (result.error) {
                res.write('stderr: ' + result.stderr);
                res.end('data: ***___CLOSE___***\n\n');
            }
            else {
                var str;
                var lines = result.stdout.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    else {
                        // Note: The double-newline is *required*
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
                res.end('data: ***___CLOSE___***\n\n');
            }
            if (callback) {
                return callback(null, result);
            }
        });
    }
    Manager.prototype.spawnExec = function(options, callback) {
        var res = options.__res;
        if (res) {
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
            });
        }
        var temp,
            str = "",
            stdout = [],
            resEnded = false,
            sentCallback = false;
        var spw = cp.spawn(options.command, options.args, {
            cwd: options.cwd, 
            env: {
                
            }, 
            argv0: undefined, 
            stdio: undefined, 
            detached: false, 
            shell: options.shell || true, 
            windowsVerbatimArguments: false, 
            windowsHide: false
        });
        spw.stdout.on('data', function(data) {
            temp = data.toString();
            console.log(temp);
            stdout.push(temp);
            if (res && !resEnded) {
                str += temp;
                var lines = str.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    else {
                        // Note: The double-newline is *required*
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
            }
        });
        spw.on('close', function(code) {
            console.log("close", code);
            if (res && !resEnded) {
                res.write('data: ***___CLOSE___***\n\n');
                res.end(str);
                resEnded = true;
            }
            if (callback && sentCallback == false) {
                sentCallback = true;
                return callback(null, {
                        error: false, 
                        stdout: stdout
                    });
            }
        });
        spw.stderr.on('data', function(data) {
            temp = data.toString();
            console.log("stderr:", temp);
            if (res && !resEnded) {
                str += temp;
                var lines = str.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    else {
                        // Note: The double-newline is *required*
                        // TODO _ res.end('stderr: ' + temp)
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
                res.write('data: ***___CLOSE___***\n\n');
                res.end(str);
                resEnded = true;
            }
            if (callback && sentCallback == false) {
                sentCallback = true;
                return callback(null, {
                        error: true, 
                        stderr: temp
                    });
            }
        });
    }
    Manager.prototype.spawnExecToEventStream = function(options, res, callback) {
        options.__res = res;
        this.spawnExec(options, callback);
    }
    Manager.prototype.gitExec = function(options, callback) {
        this.powershellExec({
            scriptPath: options.scriptPath, 
            params: options.params
        }, callback);
    }
    Manager.prototype.gitExecToEventStream = function(options, res, callback) {
        this.powershellExecToEventStream({
            scriptPath: options.scriptPath, 
            params: options.params
        }, res, callback);
    }
    Manager.prototype.nodeJsExec = function(options, callback) {
        var scriptPath = options.scriptPath;
        var scriptArgs = options.args;
        var args = [path.basename(scriptPath)];
        if (scriptArgs && scriptArgs.length > 0) {
            args = args.concat(scriptArgs);
        }
        this.spawnExec({
            command: 'node', 
            cwd: path.dirname(scriptPath), 
            args: args
        }, callback);
    }
    Manager.prototype.nodeJsExecToEventStream = function(options, res, callback) {
        var scriptPath = options.scriptPath;
        var scriptArgs = options.args;
        var args = [path.basename(scriptPath)];
        if (scriptArgs && scriptArgs.length > 0) {
            args = args.concat(scriptArgs);
        }
        this.spawnExecToEventStream({
            command: 'node', 
            cwd: path.dirname(scriptPath), 
            args: args
        }, res, callback);
    }
    Manager.prototype.babelParseRequire = function(options) {
        if (!babelParser) {
            babelParser = require("@babel/parser");
        }
    }
    Manager.prototype.getBabelParseConfig = function(options) {
        // TODO calculate cfg from options
        var cfg = options;
        var result = {
            // Indicate the mode the code should be parsed in. Can be one of "script", "module", or "unambiguous". Defaults to "script". "unambiguous" will make @babel/parser attempt to guess, based on the presence of ES6 import or export statements. Files with ES6 imports and exports are considered "module" and are otherwise "script".
            sourceType: cfg.sourceType || 'module', 
            // Array containing the plugins that you want to enable.
            plugins: [
                "jsx", 
                "flow", 
                "objectRestSpread", 
                "classProperties", 
                "doExpressions", 
                ['decorators', { decoratorsBeforeExport: false }], 
                "classProperties", 
                "classPrivateProperties", 
                "classPrivateMethods", 
                "exportDefaultFrom", 
                "exportNamespaceFrom", 
                "asyncGenerators", 
                "functionBind", 
                "functionSent", 
                "dynamicImport", 
                "numericSeparator", 
                "optionalChaining", 
                "importMeta", 
                "bigInt", 
                "optionalCatchBinding", 
                "throwExpressions", 
                "nullishCoalescingOperator"
            ], 
            // By default, import and export declarations can only appear at a program's top level. Setting this option to true allows them anywhere where a statement is allowed.
            allowImportExportEverywhere: cfg.allowImportExportEverywhere, 
            // By default, await use is not allowed outside of an async function. Set this to true to accept such code.
            allowAwaitOutsideFunction: cfg.allowAwaitOutsideFunction, 
            // By default, a return statement at the top level raises an error. Set this to true to accept such code.
            allowReturnOutsideFunction: cfg.allowReturnOutsideFunction, 
            // By default, super use is not allowed outside of class and object methods. Set this to true to accept such code.
            allowSuperOutsideMethod: cfg.allowSuperOutsideMethod, 
            // Correlate output AST nodes with their source filename. Useful when generating code and source maps from the ASTs of multiple input files.
            sourceFilename: cfg.sourceFilename || undefined, 
            // By default, the first line of code parsed is treated as line 1. You can provide a line number to alternatively start with. Useful for integration with other source tools.
            startLine: cfg.startLine || 1, 
            // By default, ECMAScript code is parsed as strict only if a "use strict"; directive is present or if the parsed file is an ECMAScript module. Set this option to true to always parse files in strict mode.
            strictMode: cfg.strictMode, 
            // Adds a ranges property to each node: [node.start, node.end]
            ranges: cfg.ranges, 
            // Adds all parsed tokens to a tokens property on the File node
            tokens: cfg.tokens
        };
        return result;
    }
    Manager.prototype.babelParseExec = function(options, callback) {
        this.babelParseRequire(options);
        var code = options.code;
        var codePath = options.codePath;
        // log 'wizzi-scripts.babelParseExec codePath, code', codePath, code
        var cfg = this.getBabelParseConfig(options);
        if (codePath) {
            // log 'babelParseExec.cfg', cfg
            var ast = this.cleanBabelAst(options, babelParser.parse(file.read(codePath), cfg));
            return callback(null, ast);
        }
        else {
            // log 'babelParseExec.cfg', cfg
            var ast = this.cleanBabelAst(options, babelParser.parse(code, cfg));
            // log 'babelParseExec.ast', ast
            return callback(null, ast);
            /** -àà
                babelParser.parse(code, cfg, function(err, result) {
                    if (err) {
                        return callback(err);
                    }
                    var ast = this.cleanBabelAst(options, result);
                    return callback(null, ast);
                })*/
        }
    }
    Manager.prototype.babelParseExecToEventStream = function(options, res, callback) {
        this.babelParseExec(options, function(err, result) {
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
            });
            if (err) {
                // _ res.write('stderr: ' + JSON.stringify(err, null, 2))
                res.write('data: ' + JSON.stringify(err, null, 2));
                res.end('data: ***___CLOSE___***\n\n');
            }
            else {
                // log 'wizzi-scripts.babelParseExecToEventStream'
                var resultString = JSON.stringify(result, null, 2);
                var str;
                var lines = resultString.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    else {
                        // Note: The double-newline is *required*
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
                if (str.length > 0) {
                    res.write('data: ' + str + "\n\n");
                }
                res.end('data: ***___CLOSE___***\n\n');
            }
            if (callback) {
                return callback(null, result);
            }
        });
    }
    Manager.prototype.cleanBabelAst = function(options, ast) {
        var removeLocation = options.removeLocation;
        if (removeLocation) {
             delete ast.loc
             delete ast.start
             delete ast.end
            var i, i_items=Object.keys(ast), i_len=Object.keys(ast).length, k;
            for (i=0; i<i_len; i++) {
                k = Object.keys(ast)[i];
                if (verify.isArray(ast[k])) {
                    var j, j_items=ast[k], j_len=ast[k].length, node;
                    for (j=0; j<j_len; j++) {
                        node = ast[k][j];
                        this.cleanBabelAst(options, node);
                    }
                }
                if (verify.isObject(ast[k])) {
                    this.cleanBabelAst(options, ast[k]);
                }
            }
        }
        return ast;
    }
    Manager.prototype.babelTransformRequire = function(options) {
        if (!babelCore) {
            babelCore = require("@babel/core");
        }
    }
    Manager.prototype.getBabelTransformConfig = function(options) {
        // TODO calculate cfg from options
        var cfg = {
            presets: [
                "@babel/preset-env", 
                "@babel/preset-react", 
                "@babel/preset-flow"
            ], 
            /** -àà
                plugins: [
                    [
                        "@babel/plugin-proposal-decorators", 
                        {
                            "legacy": true
                        }
                    ], 
                    "@babel/plugin-proposal-function-sent", 
                    "@babel/plugin-proposal-export-namespace-from", 
                    "@babel/plugin-proposal-numeric-separator", 
                    "@babel/plugin-proposal-throw-expressions", 
                     stage 3
                    , 
                    "@babel/plugin-syntax-dynamic-import", 
                    "@babel/plugin-syntax-import-meta", 
                    [
                        "@babel/plugin-proposal-class-properties", 
                        {
                            loose: false
                        }
                    ], 
                    "@babel/plugin-proposal-json-strings"
                ]*/
            
        };
        return cfg;
    }
    Manager.prototype.babelTransformExec = function(options, callback) {
        this.babelTransformRequire(options);
        var code = options.code;
        var codePath = options.codePath;
        console.log('wizzi-scripts.babelTransformExec.codePath', codePath);
        var cfg = this.getBabelTransformConfig(options);
        if (codePath) {
            babelCore.transformFile(codePath, cfg, callback);
        }
        else {
            babelCore.transform(code, cfg, callback);
        }
    }
    Manager.prototype.babelTransformExecToEventStream = function(options, res, callback) {
        this.babelTransformExec(options, function(err, result) {
            // log 'wizzi-scripts.babelTransformExecToEventStream.err.result', err, result
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
            });
            var payload;
            if (err) {
                payload = util.inspect(err);
            }
            else {
                // TODO calculate payload from options
                var payload = result.code;
            }
            // log 'payload', payload
            var str;
            var lines = payload.split("\n");
            for (var i in lines) {
                if (i == lines.length - 1) {
                    str = lines[i];
                }
                else {
                    // Note: The double-newline is *required*
                    res.write('data: ' + lines[i] + "\n\n");
                }
            }
            if (str.length > 0) {
                res.write('data: ' + str + "\n\n");
            }
            res.end('data: ***___CLOSE___***\n\n');
            if (callback) {
                return callback(null, payload);
            }
        });
    }
    Manager.prototype.flowExec = function(options, callback) {
        var codePath = options.codePath;
        var codeArgs = options.args;
        var args = ['flow'];
        if (codeArgs && codeArgs.length > 0) {
            args = args.concat(codeArgs);
        }
        this.spawnExec({
            command: 'npx', 
            cwd: path.dirname(codePath), 
            args: args
        }, callback);
    }
    Manager.prototype.flowExecToEventStream = function(options, res, callback) {
        var codePath = options.codePath;
        var codeArgs = options.args;
        var args = ['flow'];
        if (codeArgs && codeArgs.length > 0) {
            args = args.concat(codeArgs);
        }
        this.spawnExecToEventStream({
            command: 'npx', 
            cwd: path.dirname(codePath), 
            args: args
        }, res, callback);
    }
    Manager.prototype.prettierRequire = function(options) {
        if (!prettier) {
            prettier = require("prettier");
        }
    }
    Manager.prototype.getPrettierConfig = function(options) {
        // TODO calculate cfg from options
        // TODO prettier.resolveConfig(filePath [, options])
        var cfg = options;
        var result = {
            printWidth: cfg.printWidth || 80, 
            tabWidth: typeof cfg.tabWidth === 'undefined' ? 2 : cfg.tabWidth, 
            useTabs: typeof cfg.useTabs === 'undefined' ? true : cfg.useTabs, 
            semi: typeof cfg.semi === 'undefined' ? true : cfg.semi, 
            singleQuote: cfg.singleQuote, 
            trailingComma: typeof cfg.trailingComma === 'undefined' ?  "none" : cfg.trailingComma, 
            bracketSpacing: typeof cfg.bracketSpacing === 'undefined' ? true : cfg.bracketSpacing, 
            jsxBracketSameLine: cfg.jsxBracketSameLine, 
            arrowParens: typeof cfg.arrowParens === 'undefined' ?  "avoid" : cfg.arrowParens, 
            parser: typeof cfg.parser === 'undefined' ?  "babylon" : cfg.parser, 
            filepath: cfg.filepath, 
            requirePragma: cfg.requirePragma, 
            insertPragma: cfg.insertPragma, 
            proseWrap: typeof cfg.proseWrap === 'preserve' ?  "avoid" : cfg.proseWrap
        };
        return result;
    }
    Manager.prototype.prettierExec = function(options, callback) {
        this.prettierRequire(options);
        var code = options.code;
        var codePath = options.codePath;
        var plugins = options.plugins || [];
        var cfg = this.getPrettierConfig(options);
        if (codePath) {
            var prettified = prettier.format(file.read(codePath), cfg, plugins);
            return callback(null, prettified);
        }
        else {
            var prettified = prettier.format(code, cfg, plugins);
            return callback(null, prettified);
        }
    }
    Manager.prototype.prettierExecToEventStream = function(options, res, callback) {
        this.prettierExec(options, function(err, result) {
            // log 'wizzi-scripts.prettierExecToEventStream.err.result', err, result
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
            });
            var payload;
            if (err) {
                payload = util.inspect(err);
            }
            else {
                // TODO calculate payload from options
                var payload = result;
            }
            // log 'payload', payload
            var str;
            var lines = payload.split("\n");
            for (var i in lines) {
                if (i == lines.length - 1) {
                    str = lines[i];
                }
                else {
                    // Note: The double-newline is *required*
                    res.write('data: ' + lines[i] + "\n\n");
                }
            }
            if (str.length > 0) {
                res.write('data: ' + str + "\n\n");
            }
            res.end('data: ***___CLOSE___***\n\n');
            if (callback) {
                return callback(null, payload);
            }
        });
    }
    Manager.prototype.eslintExec = function(options, callback) {
        var filePath = options.filePath;
        var packagePath = options.packagePath;
        var folder = options.folder;
        var codeArgs = options.args;
        var args = [folder];
        if (codeArgs && codeArgs.length > 0) {
            args = args.concat(codeArgs);
        }
        this.spawnExec({
            command: '"./node_modules/.bin/eslint"', 
            cwd: packagePath, 
            args: args
        }, callback);
    }
    Manager.prototype.eslintExecToEventStream = function(options, res, callback) {
        var filePath = options.filePath;
        var packagePath = options.packagePath;
        var folder = options.folder;
        var codeArgs = options.args;
        var args = [folder];
        if (codeArgs && codeArgs.length > 0) {
            args = args.concat(codeArgs);
        }
        this.spawnExecToEventStream({
            command: '"./node_modules/.bin/eslint"', 
            cwd: packagePath, 
            args: args
        }, res, callback);
    }
    Manager.prototype.webpackRequire = function(options) {
        if (!webpack) {
            webpack = require("webpack");
        }
        if (options.memoryFS && !MemoryFS) {
            MemoryFS = require('memory-fs');
            memoryFS = new MemoryFS();
        }
    }
    Manager.prototype.getWebpackConfig = function(options) {
        // TODO calculate cfg from options
        var cfg = options;
        cfg.rules = [];
        if (cfg.useReact) {
            cfg.rules.push({
                test: /\.(js|jsx)$/, 
                exclude: /node_modules/, 
                use: {
                    loader: 'babel-loader', 
                    options: {
                        presets: [
                            '@babel/preset-env', 
                            '@babel/preset-react'
                        ]
                    }
                }
            });
        }
        // https://webpack.js.org/configuration/
        return {
                mode: cfg.mode || 'development', 
                entry: cfg.entry || './src', 
                // options related to how webpack emits results
                output: {
                    // the target directory for all output files
                    // must be an absolute path (use the Node.js path module)
                    path: (cfg.output && cfg.output.path) || path.resolve(__dirname, "dist"), 
                    // the filename template for entry chunks
                    filename: cfg.filename || "bundle.js", 
                    // the url to the output directory resolved relative to the HTML page
                    publicPath: cfg.publicPath || "/assets/", 
                    // the name of the exported library
                    library: cfg.library, 
                    // universal module definition // the type of the exported library
                    libraryTarget: cfg.libraryTarget
                }, 
                module: {
                    rules: cfg.rules || []
                }
            };
    }
    Manager.prototype.webpackExec = function(options, callback) {
        this.webpackRequire(options);
        const compiler = webpack(this.getWebpackConfig(options));
        if (options.memoryFS) {
            compiler.outputFileSystem = memoryFS;
        }
        function run_cb(err, stats) {
            if (err) {
                console.error(err.stack || err);
                if (err.details) {
                    console.error(err.details);
                }
                return ;
            }
            const info = stats.toJson();
            if (stats.hasErrors()) {
                console.error(info.errors);
            }
            if (stats.hasWarnings()) {
                console.warn(info.warnings);
            }
            // Done processing
            console.log(stats.toString({
                // Makes the build much quieter
                chunks: false, 
                // Shows colors in the console
                colors: true
            }));
        }
        if (options.watch) {
            compiler.watch({
                // Example watchOptions
                aggregateTimeout: 300, 
                poll: undefined
            }, run_cb);
        }
        else {
            compiler.run(run_cb);
        }
    }
    Manager.prototype.webpackExecToEventStream = function(options, res, callback) {
        throw new Error('Not implemented');
    }
    return Manager;
})();

module.exports = Manager;
