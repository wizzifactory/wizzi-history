/*
    artifact generator: C:\My\wizzi\v4\node_modules\v4-wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v4\kernel\wizzi-mtree\src\ittf\lib\loader\mtreebrickprovider.js.ittf
    utc time: Tue, 10 Oct 2017 15:44:11 GMT
*/
'use strict';
// generated by wizzi.codegen.js.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var verify = require('../util/verify');
var path = require('path');
var url = require('url');

var errors = require('../errors');
var LoadHistory = require('./loadHistory').LoadHistory;
var MTreeBrick = require('./mTreeBrick').MTreeBrick;
var IttfDocumentFinder = require('./ittfDocumentFinder');
/**
     Each mTree loading requires one instance of the MTreeBrickProvider
     To date there is no global cache for mTrees, but only a cache of
     mTreeBricks used during a single loading.
*/
var MTreeBrickProvider = (function () {
    function MTreeBrickProvider() {
        _classCallCheck(this, MTreeBrickProvider);
        this.__type = 'MTreeBrickProvider';
        this.bricksCache = {};
        this.store = null;
        this.storeKind = null;
        this.uri = null;
        this.schema = null;
        this.userId = null;
        this.documentFinder = null;
        this.primaryMTreeBrickCloned = null;
        this.loadHistory = null;
        this.productionContext = null;
        this.mTreeBuildUpContext = null;
        this.sourcePreprocessor = null;
    }
    // The primary mTreeBrick of an mTree loading
    MTreeBrickProvider.prototype.getPrimaryMTreeBrick = function() {
        return this.primaryMTreeBrickCloned;
    }
    // The starting point of an mTree loading
    // Creates the mTree loadHistory
    // Load the primary mTreeBrick form the primary IttfDocument
    MTreeBrickProvider.prototype.init = function(primaryIttfDocumentUri, requestContext, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'init', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isNotEmpty(primaryIttfDocumentUri) === false) {
            return callback(error(
                'InvalidArgument', 'init', { parameter: 'primaryIttfDocumentUri', message: 'The primaryIttfDocumentUri parameter must be a string. Received: ' + primaryIttfDocumentUri }
            ));
        }
        if (verify.isObject(requestContext) === false) {
            return callback(error(
                'InvalidArgument', 'init', { parameter: 'requestContext', message: 'The requestContext parameter must be an object. Received: ' + requestContext }
            ));
        }
        if (verify.isObject(requestContext.__ittfDocumentStore) === false) {
            return callback(error(
                'InvalidArgument', 'init', { parameter: 'requestContext.__ittfDocumentStore', message: 'The requestContext.__ittfDocumentStore parameter must be an object. Received: ' + requestContext.__ittfDocumentStore }
            ));
        }
        if (verify.isObject(requestContext.productionContext) === false) {
            return callback(error(
                'InvalidArgument', 'init', { parameter: 'requestContext.productionContext', message: 'The requestContext.productionContext parameter must be an object. Received: ' + requestContext.productionContext }
            ));
        }
        if (verify.isObject(requestContext.mTreeBuildUpContext) === false) {
            return callback(error(
                'InvalidArgument', 'init', { parameter: 'requestContext.mTreeBuildUpContext', message: 'The requestContext.mTreeBuildUpContext parameter must be an object. Received: ' + requestContext.mTreeBuildUpContext }
            ));
        }
        if (verify.isNullOrUndefined(requestContext.sourcePreprocessor) === false) {
            if (verify.isFunction(requestContext.sourcePreprocessor) === false) {
                return callback(error(
                    'InvalidArgument', 'init', { parameter: 'requestContext.sourcePreprocessor', message: 'The requestContext.sourcePreprocessor parameter must be a function. Received: ' + requestContext.sourcePreprocessor }
                ));
            }
        }
        this.store = requestContext.__ittfDocumentStore;
        var that = this;
        // parse the primary IttfDocument Uri and collect
        // infos from the uri
        this.store.parseUri(primaryIttfDocumentUri, function(err, parsedUri) {
            if (err) {
                return callback(err)
                ;
            }
            // log 'wizzi-mtree.mTreeBrickProvider.parsedUri', parsedUri
            that.storeKind = parsedUri.storeKind;
            that.uri = parsedUri.uri || parsedUri.originalUri;
            that.userId = parsedUri.userId;
            that.projectId = parsedUri.projectId;
            that.schema = parsedUri.schema;
            // load the document text content
            that.store.getModelContent(that.uri, function(err, ittfContent) {
                if (err) {
                    return callback(err)
                    ;
                }
                // init helper objects
                that.documentFinder = new IttfDocumentFinder(that.store, that.schema);
                that.loadHistory = new LoadHistory();
                that.productionContext = requestContext.productionContext;
                that.mTreeBuildUpContext = requestContext.mTreeBuildUpContext;
                that.sourcePreprocessor = requestContext.sourcePreprocessor;
                // log 'wizzi-mtree.mTreeBrickProvider.ittfContent', ittfContent
                // load the primary mTreeBrick from the ittf content
                that.loadMTreeBrickFromSource(that.uri, {}, ittfContent, function(err, primaryMTreeBrickCloned) {
                    if (err) {
                        return callback(err)
                        ;
                    }
                    // save the cloned primary mTreeBrick on the mTreeBrickProvider instance
                    that.primaryMTreeBrickCloned = primaryMTreeBrickCloned;
                    // callbacks returning the mTreeBrickProvider instance
                    callback(null, that);
                });
            });
        });
    }
    /**
         Clones, or loads from source, an included or mixed ittf document
         params
         { options
         string ittfDocumentUri
         boolean include
         // If true the mTreeBrick loaded from the IttfDocument will be included in the includer mTreeBrick
         // and its scope will become that of the includer (its brickKey will be that of the includer).
         // A $include command must not have any argument.
         // An included ittf document must not have params (must not have the $params command).
         string includerBrickKey
         string basedir
         string relpath
        
         called from
         ./mtree.load
         ./includer
         ./mixer
        
    */
    MTreeBrickProvider.prototype.get = function(options, callback) {
        if (typeof(callback) !== 'function') {
            throw new Error(
                error('InvalidArgument', 'get', 'The callback parameter must be a function. Received: ' + callback)
            );
        };
        if (verify.isObject(options) === false) {
            return callback(error(
                'InvalidArgument', 'get', { parameter: 'options', message: 'The options parameter must be an object. Received: ' + options }
            ));
        }
        var loadHistory = this.loadHistory;
        var productionContext = this.productionContext;
        var that = this;
        this.documentFinder.resolvePath(options, function(err, uri) {
            if (err) {
                return callback(err)
                ;
            }
            // log 'wizzi-mtree.mTreeBrickProvider.path resolved', uri
            var mTreeBrickCloned = null;
            // check cache
            // log 'searching in cache', that.bricksCache, uri
            var cachedMTreeBrick = that.bricksCache[uri];
            if (cachedMTreeBrick) {
                // found in cache, clone it
                mTreeBrickCloned = cachedMTreeBrick.clone();
                // this is not superflous
                // the productionContext counts the cached used
                productionContext.addIttfDocument(uri, cachedMTreeBrick.inputContent);
                // adding the mTreeBrickCloned to the loadHistory
                // generates the sourceKey and brickKey
                var mTreeBrickData = loadHistory.addMTreeBrick(uri, that.schema, mTreeBrickCloned, options)
                ;
                mTreeBrickCloned.sourceKey = mTreeBrickData.sourceKey;
                mTreeBrickCloned.brickKey = mTreeBrickData.brickKey;
                mTreeBrickCloned.$schema = that.schema;
                return callback(null, mTreeBrickCloned);
            }
            else {
                // not found in cache, get the content from the store
                // than load the mTreeBrick from source
                that.store.getModelContent(uri, function(err, ittfContent) {
                    if (err) {
                        return callback(err)
                        ;
                    }
                    that.loadMTreeBrickFromSource(uri, options, ittfContent, callback);
                });
            }
        });
    }
    MTreeBrickProvider.prototype.loadMTreeBrickFromSource = function(uri, options, ittfContent, callback) {
        this.productionContext.addIttfDocument(uri, ittfContent);
        this.loadHistory.addIttfDocument(uri, ittfContent);
        if (this.sourcePreprocessor) {
            // TODO save the preprocessed in productionContext and loadHistory
            // or save the sourcePreprocessor function
            ittfContent = this.sourcePreprocessor(ittfContent);
        }
        // Creates the mTreeBrickData object passing
        // null in the mTreeBrick parameter
        // it will be added later if the parameter
        // options.include is false.
        // This because if the mTreeBrick
        // is included it does not have its own evalContext, its nodes become part
        // of the includer, and a cloned mTreeBrick is not needed.
        var mTreeBrickData = this.loadHistory.addMTreeBrick(uri, this.schema, null, options)
        ;
        var newMTreeBrick = new MTreeBrick(uri, this.loadHistory);
        // parses the ittf document content and loads the mTreeBrick
        // frome the ittf node tree.
        var notUsed = newMTreeBrick.load(ittfContent, mTreeBrickData);
        if (notUsed && notUsed.__is_error) {
            console.log('__is_error ', notUsed);
            return callback(notUsed);
        }
        // log 'wizzi-mtree.mTreeBrickProvider.parsed newMTreeBrick', newMTreeBrick
        // caches the newMTreeBrick
        this.bricksCache[uri] = newMTreeBrick;
        // clone it
        var mTreeBrickCloned = newMTreeBrick.clone();
        // set keys
        mTreeBrickCloned.sourceKey = mTreeBrickData.sourceKey;
        mTreeBrickCloned.brickKey = mTreeBrickData.brickKey;
        mTreeBrickCloned.$schema = this.schema;
        
        if (!(options.include)) {
            mTreeBrickData.mTreeBrick = mTreeBrickCloned;
        }
        
        // log 'cloned newMTreeBrick', mTreeBrickCloned
        return callback(null, mTreeBrickCloned);
    }
    MTreeBrickProvider.prototype.enterFragmentCall = function(mixerUri, mixedUri) {
        this.loadHistory.enterFragmentCall(mixerUri, mixedUri);
    }
    MTreeBrickProvider.prototype.exitFragmentCall = function() {
        this.loadHistory.exitFragmentCall();
    }
    MTreeBrickProvider.prototype.checkForRecursion = function() {
        return this.loadHistory.checkForRecursion();
    }
    return MTreeBrickProvider;
})();

/**
     Creates an MTreeBrickProvider for loading
     an IttfDocucument
*/
MTreeBrickProvider.createFromUri = function(primaryIttfDocumentUri, requestContext, callback) {
    if (typeof(callback) !== 'function') {
        throw new Error(
            error('InvalidArgument', '', 'The callback parameter must be a function. Received: ' + callback)
        );
    };
    if (verify.isNotEmpty(primaryIttfDocumentUri) === false) {
        return callback(error(
            'InvalidArgument', '', { parameter: 'primaryIttfDocumentUri', message: 'The primaryIttfDocumentUri parameter must be a string. Received: ' + primaryIttfDocumentUri }
        ));
    }
    if (verify.isObject(requestContext) === false) {
        return callback(error(
            'InvalidArgument', '', { parameter: 'requestContext', message: 'The requestContext parameter must be an object. Received: ' + requestContext }
        ));
    }
    // log 'wizzi-mtree.mTreeBrickProvider.createFromUri', primaryIttfDocumentUri
    var provider = new MTreeBrickProvider();
    provider.init(primaryIttfDocumentUri, requestContext, function(err, notUsed) {
        if (err) {
            return callback(err)
            ;
        }
        callback(null, provider);
    });
};
module.exports = MTreeBrickProvider;
/**
  params
    string code
      # the error name or number
    string method
    string message
      # optional
    { innerError
      # optional
*/
function error(code, method, message, innerError) {
    var parameter = null;
    if (verify.isObject(message)) {
        parameter = message.parameter;
        message = message.message;
    }
    return verify.error(innerError, {
        name: ( verify.isNumber(code) ? 'Err-' + code : code ),
        method: 'wizzi-mtree.loader.mTreeBrickProvider.' + method,
        parameter: parameter,
        sourcePath: __filename
    }, message || 'Error message unavailable');
}
