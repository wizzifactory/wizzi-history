/*
    artifact generator: C:\My\wizzi\v4\node_modules\v4-wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v4\kernel\wizzi-mtree\src\ittf\lib\loader\mtreebrick.js.ittf
    utc time: Tue, 10 Oct 2017 15:44:11 GMT
*/
'use strict';
// generated by wizzi.codegen.js.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

/**
     An mTreeBrick is a nodified ittf document.
     In the build-up of an mTree, the same mTreeBrick can be mixed
     or included many times, so it is created once and always cloned.
     { mTreeBrick
     string uri       // The location of the source IttfDocument.
     string schema    // The IttfDocument schema.
     { loadHistory    // The loadHistory object
     [ lines          // parsed lines of source text
     [ nodes          // nodified lines of source text
     string sourceKey // key of the source info of the IttfDocument
     string brickKey  // key of the cloned mTreeBrick
    
     ... these are set by the mixer, on the cloned object
     boolean mixed          // true if has been mixed
     string $mixerBrickKey  // the brickKey of the mTreeBrick of the calling node
     string $args           // the node-value of the mixing node
     string $argArray       // the $arg array of the mixing node
    
     ... these are set by the nodifier on the original mtree, then cloned
     string $params:        // the node-value of the $params node, if declared
    
     Method
     load
     setKeys
     clone
     calcParamValues
     toIttf
     toText
     dump
*/
var path = require('path');
var util = require('util');
var verify = require('../util/verify');
var errors = require('../errors');
var types = require('../util/types');
var liner = require('./liner');
var nodifier = require('./nodifier');
var MTreeBrick = (function () {
    function MTreeBrick(uri, loadHistory) {
        _classCallCheck(this, MTreeBrick);
        this.uri = uri;
        this.loadHistory = loadHistory;
    }
    MTreeBrick.prototype.load = function(ittfSourceTextContent, ittfDocumentData) {
        if (typeof(ittfSourceTextContent) !== 'string') {
            throw new TypeError('ittfSourceTextContent must be a string');
        }
        if (!ittfDocumentData || typeof(ittfDocumentData.sourceKey) !== 'string') {
            throw new TypeError('ittfDocumentData.sourceKey must be a string');
        }
        var lines = liner(ittfSourceTextContent, ittfDocumentData);
        if (lines && lines.__is_error) {
            return lines;
        }
        var nodes = nodifier(lines, this);
        if (nodes && nodes.__is_error) {
            return nodes;
        }
        this.nodes = nodes;
    }
    MTreeBrick.prototype.setKeys = function(sourceKey, brickKey) {
        this.sourceKey = sourceKey;
        this.brickKey = brickKey;
    }
    MTreeBrick.prototype.clone = function() {
        var clonedModel = new MTreeBrick(this.uri, this.loadHistory);
        if (this.$params) {
            clonedModel.$params = this.$params;
        }
        clonedModel.nodes = this._cloneNodes(this.nodes, null, clonedModel);
        return clonedModel;
    }
    MTreeBrick.prototype._cloneNodes = function(nodes, parent, clonedModel) {
        var self = this;
        var clnode,
            clnodes = [];
        var i, i_len=nodes.length, node;
        for (i=0; i<i_len; i++) {
            node = nodes[i];
            clnode = {
                id: self.loadHistory.getNewNodeId(), 
                parsedId: node.id, 
                name: node.name, 
                value: node.value, 
                tagSuffix: node.tagSuffix, 
                row: node.row, 
                col: node.col, 
                sourceKey: node.sourceKey, 
                hasMacro: node.hasMacro, 
                parent: parent, 
                model: clonedModel
            };
            clnode.children = self._cloneNodes(node.children, clnode, clonedModel);
            clnodes.push(clnode);
        }
        return clnodes;
    }
    /**
         Rules
         Node command format
         > $params param1 [,param2 [,param-n]]
         param   : [&]name[:type][|default]
         &       : the paramater is an object passed by reference
         name    : the name of the parameter to use in IttfMacro expressions
         type    : the parameter type
         one-of : string(default), integer, float, boolean, date, object (implicit
         when '&' declared), macro (implicit, detected from IttfMacro delimiters
         contained in the default value)
         default : typed-value | @@null | @@undefined
         // warning! `title|null` becomes title = "null" (the quoted string null)
         // if you want title to be null then : `title|@@null`
         string  : quotes are optional, example: `title|"my way"` and `title|my way` are the same
         boolean : true | false
         date    : yyyy/mm/dd
         macro   : an IttfMacro can be passed as a parameter to a mixin, when the parameter
         is referenced we have a double macro substitution
         TODO verify, explain how this works, macro or macros can be partial
         insides of the default value?
    */
    MTreeBrick.prototype.calcParamValues = function(args) {
        // string args
        // optional
        var mTreeBrickRoot = this.nodes[0];
        var params = this.$params;
        var _paramArray = [],
            _argsArray = [];
        if (verify.isNotEmpty(params)) {
            _paramArray = params.trim().split(',');
        }
        if (verify.isNotEmpty(args)) {
            _argsArray = args.trim().split(',');
        }
        var result = [];
        for (var i = 0; i < _paramArray.length; i++) {
            var name,
                type = 'string',
                defaultValue = null,
                value = null,
                hasparamvalue = false,
                hasdefaultvalue = false;
            // a param may have the format
            // 1) name
            // 2) name|default
            // 3) name:type|default
            // valid types: string(default), integer, float, boolean, date
            var param_parts = _paramArray[i].trim().split(/[|]/)
            ;
            if (param_parts.length > 2) {
                return local_error('MixinParamError', 'calcParamValues', 'Error evaluating: $params ' + params + ' , Argument ' + i + ' is malformed. Expected name[:type[|default]]', mTreeBrickRoot)
                ;
            }
            if (param_parts.length == 2) {
                defaultValue = param_parts[1].trim();
                hasdefaultvalue = true;
            }
            param_parts = param_parts[0].trim().split(/[:]/)
            ;
            if (param_parts.length > 2) {
                return local_error('MixinParamError', 'calcParamValues', 'Error evaluating: $params ' + params + ', argument ' + i + ' is malformed. Expected name[:type[|default]]', mTreeBrickRoot)
                ;
            }
            if (param_parts.length == 2) {
                type = param_parts[1];
            }
            name = param_parts[0];
            if (name.substr(0, 1) === '&') {
                name = name.substr(1);
                type = 'object';
            }
            if (_argsArray.length > i) {
                value = _argsArray[i].trim();
                if (type === 'object') {
                    if (value.substr(0, 1) !== '&') {
                        return local_error('MixinParamError', 'calcParamValues', 'Error evaluating: $params ' + params + ', argument (' + i + ') must be an object reference. Found ' + value, mTreeBrickRoot)
                        ;
                    }
                    else {
                        value = value.substr(1);
                    }
                }
                else {
                    value = verify.convert(value, type, true);
                    if (value && value.__is_error) {
                        return local_error('MixinParamError', 'calcParamValues', 'Error evaluating: $params ' + params + ', objectifying parameter: ' + i + '/' + name, mTreeBrickRoot, value)
                        ;
                    }
                }
                hasparamvalue = true;
            }
            else if (hasdefaultvalue) {
                value = verify.convert(defaultValue, type, true);
                if (value && value.__is_error) {
                    return local_error('MixinParamError', 'calcParamValues', 'Error evaluating: $params ' + params + ', converting parameter: ' + i + '/' + name + ' to type ' + type, mTreeBrickRoot, value)
                    ;
                }
            }
            else {
                return local_error('MixinParamError', 'calcParamValues', 'Error evaluating: $params ' + params + ', missing value for not optional argument ' + i + ' = ' + name, mTreeBrickRoot)
                ;
            }
            var isIttfMacro = type === 'object' ? false : verify.isIttfMacro(value);
            result.push({
                name: name.substr(0, 1) === '&' ? name.substr(1) : name, 
                value: value, 
                type: type, 
                isIttfMacro: isIttfMacro, 
                isByRef: type === 'object'
            });
        }
        return result;
    }
    MTreeBrick.prototype.dump = function(evaluated) {
        var buffer = [],
            ctx = {
                evaluated: evaluated, 
                loadHistory: this.loadHistory
            };
        this.nodes.forEach(function(node) {
            _dumpNodeDeep(node, 1, buffer, ctx);
        });
        return buffer.join('\n');
    }
    MTreeBrick.prototype.toIttf = function() {
        var buffer = [];
        this.nodes.forEach(function(node) {
            _toIttfNodeDeep(node, 0, buffer);
        });
        return buffer.join('\n');
    }
    MTreeBrick.prototype.toText = function() {
        var buffer = [];
        if (this.nodes.length == 1) {
            var root = this.nodes[0];
            var i, i_len=root.children.length, child;
            for (i=0; i<i_len; i++) {
                child = root.children[i];
                _toTextNodeDeep(child, 0, buffer);
            }
        }
        return buffer.join('\n');
    }
    return MTreeBrick;
})();

function _dumpNodeDeep(node, indent, buffer, ctx) {
    if (ctx.evaluated && node.u) {
        var sourceUri = ctx.loadHistory.ittfDocumentDatas[node.u].ittfDocumentUri;
        var sourceUriName = path.basename(sourceUri);
        var sourceUriFolder = path.basename(path.dirname(sourceUri));
        buffer.push(spaces(indent * 2) + node.n + ' ' + (node.v || '') + '    r' + node.r + ',c' + node.c + '    source:  ' + sourceUriFolder + '/' + sourceUriName);
    }
    else {
        buffer.push(spaces(indent * 2) + node.name + ' ' + (node.value || '') + '  r' + node.row + ',c' + node.col + '    ids: ' + node.parsedId + ' ' + node.id);
    }
    if (node.model) {
        if (node.model.$args || node.model.$params) {
            if (!ctx[node.model.brickKey]) {
                ctx[node.model.brickKey] = node.model;
                buffer.push(spaces(indent * 2) + '  $args: ' + node.model.$args + ' $params: ' + node.model.$params);
            }
        }
    }
    indent++;
    node.children.forEach(function(n) {
        _dumpNodeDeep(n, indent, buffer, ctx);
    });
}
function _toIttfNodeDeep(node, indent, buffer) {
    buffer.push(spaces(indent * 4) + node.n + ' ' + (node.v || ''));
    indent++;
    var i, i_len=node.children.length, child;
    for (i=0; i<i_len; i++) {
        child = node.children[i];
        _toIttfNodeDeep(child, indent, buffer);
    }
}
function _toTextNodeDeep(node, indent, buffer) {
    buffer.push(spaces(indent * 4) + node.n + ' ' + node.v || '');
    indent++;
    var i, i_len=node.children.length, child;
    for (i=0; i<i_len; i++) {
        child = node.children[i];
        _toTextNodeDeep(child, indent, buffer);
    }
}
function spaces(num) {
    return Array(num + 1).join(" ")
    ;
}
function local_error(name, method, message, node, inner) {
    if (node) {
        var nodeError = new errors.NodeError(message, node);
        message = nodeError.message;
    }
    return error('name', 'method', message, inner)
    ;
}

module.exports = {
    MTreeBrick: MTreeBrick
};
