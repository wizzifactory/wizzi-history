module wizzi-mtree.loader.liner
    kind jsfile
    var util = require('util')

	#
		# Reads an IttfDocument and extract an array of line descriptions
    #
		# params
		#   string textContent
		#     # The text content of the IttfDocument
		#   { ittfDocumentData
		#     string sourceKey
		#       # The IttfDocument key generated by the loadHistory

	#
		# Output
		# lines:Array of
		#  line : {
		#      indent: Number,
		#      name: String,
		#      value: String, // always trimmed
		#      row: Number,
		#      col: Number,
		#      sourceKey: String,
		#      tagSuffix: undefined || '(',
		#      hasMacro: Boolean
		#  }
	#
		# Ittf commands for comments
		#  $ and $ ... singleline comment
		#  $ and * ... * and $ multiline comment
		# Comment states
		#   0 = no comment seen
		#   1 = seen char $ could be first char of comment
		#   2 = seen chars $ and * we are inside multiline comments
		#   3 = seen chars $ and * ... and *  could be first char of end of multiline comments
		#  21 = seen chars $ and $ we are inside singleline comment
		# Es6 macro states
		#   0 = no macro seen
		#   1 = seen char ` we are inside template
		#   2 = seen escape char inside a template, the next ` char does not close the macro string
		#  10 = seen char $ inside a template could be start of macro

	var COMMENT
		{
			@ NONE 0
			@ NONE_SEEN_DOLLAR 1
			@ MULTI_LINE 2
			@ MULTI_LINE_SEEN_ASTER 3
			@ SINGLE_LINE 21
    
	# https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2/
	var MACRO
		{
			@ NONE 0
			@ INSIDE_TEMPLATE 1
			@ INSIDE_TEMPLATE_SEEN_ESCAPE 2
			@ INSIDE_TEMPLATE_SEEN_DOLLAR 10

	var CP
		{
			@ TAB 9
			@ LF 10
			@ CR 13
			@ SPACE 32
			@ DOLLAR 36
			@ ASTER 42
			@ SLASH 92
			@ OPEN_PAREN 40
			@ OPEN_GRAPH 123
			@ CLOSE_GRAPH 125
			@ SINGLE_QUOTE 39
			@ DOUBLE_QUOTE 34
			@ BACKTICK 96
			@ MACRO_REPLACE 198

	set module.exports
        function 
            param textContent
            param ittfDocumentData
            var 
                decl sourceKey = ittfDocumentData.sourceKey
                decl lines
                    [ 
                decl leadingWhiteSpaces = 0
                decl line = null
                decl linepos = 1
				decl lineHasMacro = false
                decl colpos = 0
                decl commentState = COMMENT.NONE
				decl macroState = MACRO.NONE
                decl quote = null
                # TODO ensure textContent is red as utf-8 and avoid this
				decl chunk = textContent.toString('utf-8')
                decl ch
				decl cp
				decl chUni
                decl i
                decl l = chunk.length
				decl waitValue = false
				decl nameAcc = []
				decl valueAcc = []
            
			# TODO replace ch with chUni 
			for i = 0; i < l; i++
                
				set ch = chunk[i]
				set chUni = chunk.charCodeAt(i)
				if i < l - 1
					set cp = (chunk.charAt(i) + chunk.charAt(i + 1)).codePointAt(0)
				elif i < l
					set cp = chunk.charAt(i).codePointAt(0)
				else 
					throw new Error('wizzi-mtree.loader.liner index of chunk out of range: ' + chunk)
				if cp > 0xffff
					log 'wizzi-mtree.loader.liner.cp > 0xffff'
					set i += 1

                set colpos++

				if cp == CP.SLASH
					# log '+++++ wizzi-mtree.liner', chunk[i+1], chunk[i+2], chunk[i+3]
                
				$$ log 'liner', ch, cp, commentState, quote
				
				if quote != null
                    if quote == cp
                        set quote = null
                    _ processMacro(cp)
                
				else 
                    if commentState == COMMENT.MULTI_LINE
                        if cp == CP.ASTER
							# could be start of end of comment
                            set commentState = COMMENT.MULTI_LINE_SEEN_ASTER
						else
							# skip comment char
							if cp == CP.LF
								set linepos++
								set colpos = 0
                    
					elif commentState == COMMENT.SINGLE_LINE
                        if cp == CP.LF
							# end of line comment
							# delegate end of comment to processChar 
                            _ processMacro(cp)
                    
					elif commentState == COMMENT.MULTI_LINE_SEEN_ASTER
                        if cp == CP.DOLLAR
							# ok, really is end of comment
                            set commentState = COMMENT.NONE
                        else
							# no, multi line comments continue 
                            set commentState = COMMENT.MULTI_LINE
							# check if it is eol
							if cp == CP.LF
								set linepos++
								set colpos = 0
                    
					elif commentState == COMMENT.NONE_SEEN_DOLLAR
						if cp == CP.ASTER
							# ok, is start of multi line comment
							set commentState = COMMENT.MULTI_LINE
						elif cp == CP.DOLLAR
							# ok, is a single line comment
							set commentState = COMMENT.SINGLE_LINE
						else
							# no, it was not a comment, reset
		                    set commentState = COMMENT.NONE
			                _ processMacro(CP.DOLLAR)
				            _ processMacro(cp)
                    
					elif commentState == COMMENT.NONE && ( cp == CP.SINGLE_QUOTE || cp == CP.DOUBLE_QUOTE )
						# start of literal
						# a literal suspend comments strip
						# comment delimiters inside quotes are normal characters.
                        set quote = cp
                        _ processMacro(cp)
                    
					elif commentState == COMMENT.NONE && cp == CP.DOLLAR
						# could be start of comment
                        set commentState = COMMENT.NONE_SEEN_DOLLAR

					elif cp == CP.SLASH && 
						\b i+3 < l && 
						\b chunk[i+1] == '$' &&
						\b chunk[i+2] == '\\' &&
						\b chunk[i+3] == '{'
						_ processMacro(CP.DOLLAR)
						_ processMacro(CP.OPEN_GRAPH)
						set i = i +3
                    
					else 
                        _ processMacro(cp)
            
			if line
				_ pushLine
            
			return lines
            
			function processMacro
				param cp

				if macroState == MACRO.INSIDE_TEMPLATE_SEEN_ESCAPE
					# remove escape state
					set macroState = MACRO.INSIDE_TEMPLATE
					_ processChar(cp)
					# log 'macroState', macroState, String.fromCodePoint(cp) 
				elif macroState == MACRO.INSIDE_TEMPLATE_SEEN_DOLLAR
					if cp == CP.OPEN_GRAPH
						# ok - really it was a start of macro
						# Alt+146 = Æ
						_ processChar(CP.MACRO_REPLACE)
						_ processChar(CP.OPEN_GRAPH)
						set lineHasMacro = true
					else
						# no - it was not a start of macro
						_ processChar(CP.DOLLAR)
						_ processChar(cp)
					set macroState = MACRO.INSIDE_TEMPLATE
					# log 'macroState', macroState, String.fromCodePoint(cp) 
				else
					if cp == CP.BACKTICK
						if macroState > MACRO.NONE 
							set macroState = MACRO.NONE
							_ processChar(cp)
							# log 'macroState', macroState, String.fromCodePoint(cp) 
						else
							set macroState = MACRO.INSIDE_TEMPLATE
							_ processChar(cp)
							# log 'macroState', macroState, String.fromCodePoint(cp) 
					else
						if macroState == MACRO.INSIDE_TEMPLATE
							if cp == CP.DOLLAR
								# could be start of macro
								set macroState = MACRO.INSIDE_TEMPLATE_SEEN_DOLLAR
								# log 'macroState', macroState, String.fromCodePoint(cp) 
							elif cp == CP.SLASH
								# could be an escape of a template start inside a template
								set macroState = MACRO.INSIDE_TEMPLATE_SEEN_ESCAPE
								_ processChar(cp)
								# log 'macroState', macroState, String.fromCodePoint(cp) 
							else
								# log 'process char macroState', macroState, String.fromCodePoint(cp) 
								_ processChar(cp)
						else
							_ processChar(cp)

			function processChar
                param cp

				if cp == CP.LF
                    if line
						_ pushLine
                    else 
						# Allow blank line. Do nothing
                    set leadingWhiteSpaces = 0
                    set colpos = 0
                    set linepos++
					set macroState = MACRO.NONE
					set quote = null
					if commentState != COMMENT.MULTI_LINE
                        set commentState = COMMENT.NONE
                
				elif cp == CP.CR

				elif [CP.SPACE, CP.TAB].indexOf(cp) !== -1
                    if cp == CP.TAB
                        set colpos += 3
                    if line
						if waitValue == false
							set waitValue = true
						else
							_ valueAcc.push
								@ String.fromCodePoint(cp)
						$* VIA	
                        if typeof (line.value) == 'undefined'
                            set line.value = ''
                        else 
                            set line.value += String.fromCodePoint(cp)
						*$
                    else 
                        set leadingWhiteSpaces += (cp == CP.SPACE ? 1 : 4)
                
				else
                    if line
                        if waitValue == false
							if cp == CP.OPEN_PAREN 
								set line.tagSuffix = String.fromCodePoint(cp)
								set waitValue = true
							else
								_ nameAcc.push
									@ String.fromCodePoint(cp)
								# set line.name += String.fromCodePoint(cp)
                        else 
							_ valueAcc.push
								@ String.fromCodePoint(cp)
						$* VIA	
                        if typeof(line.value) == 'undefined'
							if cp == CP.OPEN_PAREN 
								set line.tagSuffix = String.fromCodePoint(cp)
								set line.value = ''
							else
								_ nameAcc.push
									@ String.fromCodePoint(cp)
								# set line.name += String.fromCodePoint(cp)
                        else 
                            set line.value += String.fromCodePoint(cp)
						*$
                    else 
						_ nameAcc.push
							@ String.fromCodePoint(cp)
                        set line =
                            { 
                                @ indent leadingWhiteSpaces / 4
                                $$ @ name String.fromCodePoint(cp)
                                @ row linepos
                                @ col colpos
                                @ sourceKey sourceKey
                
				if line
					# log 'line.name, value', nameAcc.join(''), valueAcc.join('')

			function pushLine
				set line.name = nameAcc.join('')
				if waitValue == true
					# calc trimmed start, end, len of value
					var
						decl v_start = -1
						decl v_end
						decl v_ch
					for var i=0; i<valueAcc.length; i++
						set v_ch = valueAcc[i]
						if v_ch === ' ' || v_ch === '\t'
							# skip
						else
							if v_start < 0
								set v_start = i
							set v_end = i
					# log "v_start, v_end", v_start, v_end
					if valueAcc.length > v_start + 1 && valueAcc[v_start] === '\\' && valueAcc[v_start+1] === 'b'
						set v_start += 2
					if v_end > v_start + 1 && valueAcc[v_end] === 'b' && valueAcc[v_end-1] === '\\'
						set v_end -= 2
					# log "v_start, v_end", v_start, v_end
					set line.value = valueAcc.slice(v_start, v_end + 1).join('')
                
				$* VIA
				if typeof (line.value) !== 'undefined'
                    set line.value = line.value.trim()
				*$
				
				set line.hasMacro = lineHasMacro
				# log 'last push line', line
                _ lines.push(line)
				set line = null
				set waitValue = false
				set nameAcc.length = 0
				set valueAcc.length = 0
				set lineHasMacro = false

