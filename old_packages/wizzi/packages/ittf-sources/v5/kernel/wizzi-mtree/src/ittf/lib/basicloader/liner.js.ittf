module
    kind jsfile
    var util = require('util')

	#
		# Reads an IttfDocument and extract an array of line descriptions
    #
		# params
		#   string textContent
		#     #  The text content of the IttfDocument
		#   { ittfDocumentData
        #     string sourceKey
		#       # The IttfDocument key generated by the loadHistory

	#
		# Output
		# lines:Array of
		#  line : {
		#      indent: Number,
		#      name: String,
		#      value: String, // always trimmed
		#      row: Number,
		#      col: Number,
		#      sourceKey: String,
		#      tagSuffix: undefined || '(',
		#      hasMacro: Boolean
		#  }
	#
		# Ittf commands for comments
		#  $ and $ ... singleline comment
		#  $ and * ... * and $ multiline comment
		# Comment states
		#   0 = no comment seen
		#   1 = seen char $ could be first char of comment
		#   2 = seen chars $ and * we are inside multiline comments
		#   3 = seen chars $ and * ... and *  could be first char of end of multiline comments
		#  21 = seen chars $ and $ we are inside singleline comment
		# Es6 macro states
		#   0 = no macro seen
		#   1 = seen char ` we are inside macro
		#   2 = seen escape char inside a macro, the next ` char does not close the macro string
    
	set module.exports
        function 
            param textContent
            param ittfDocumentData
            var 
                decl sourceKey = ittfDocumentData.sourceKey
                decl lines
                    [ 
                decl leadingWhiteSpaces = 0
                decl line = null
                decl linepos = 1
				decl lineHasMacro = false
                decl colpos = 0
                decl commentState = 0
				decl macroState = 0
                decl quote = null
                # TODO ensure textContent is red as utf-8 and avoid this
				decl chunk = textContent.toString('utf-8')
                decl ch
				decl chUni
                decl i
                decl l = chunk.length
            
			# TODO replace ch with chUni 
			for i = 0; i < l; i++
                
				set ch = chunk[i]
				set chUni = chunk.charCodeAt(i)
                set colpos++
                
				if quote != null
                    if quote == ch
                        set quote = null
                    _ processMacro(ch)
                
				else 
                    if commentState == 2
                        if ch == '*'
							# could be start of end of comment
                            set commentState = 3
						else
							# skip comment char
							if ch == '\n'
								set linepos++
								set colpos = 0
                    
					elif commentState == 21
                        if ch == '\n'
							# end of line comment
							# delegate end of comment to processMacro 
                            _ processMacro(ch)
                    
					elif commentState == 3
                        if ch == '$'
							# ok, really is end of comment
                            set commentState = 0
                        else
							# no, comments continue 
                            set commentState = 2
							# check if it is eol
							if ch == '\n'
								set linepos++
								set colpos = 0
                    
					elif commentState == 1 && ch == '*'
						# ok, really is start of comment
                        set commentState = 2
                    
					elif commentState == 1 && ch == '$'
						# ok, is a line comment
                        set commentState = 21
                    
					elif commentState == 1 && ch != '*'
						# no, it was not a comment, reset
                        set commentState = 0
                        _ processMacro('$')
                        _ processMacro(ch)
                    
					elif commentState == 0 && ch == '"'
						# start of literal
                        set quote = ch
                        _ processMacro(ch)
                    
					elif commentState == 0 && ch == "'"
						# start of literal
                        set quote = ch
                        _ processMacro(ch)
                    
					elif commentState == 0 && ch == '$'
						# could be start of comment
                        set commentState = 1
                    else 
                        _ processMacro(ch)
            
			if line
                if typeof (line.value) !== 'undefined'
                    set line.value = line.value.trim()
				set line.hasMacro = lineHasMacro
                _ lines.push(line)
				set lineHasMacro = false
            
			return lines
            
			function processMacro
				param ch

				if macroState == 2
					# remove escape state
					set macroState = 1
					# log 'macroState', macroState, ch
				else
					if chUni == 96
						if macroState > 0 
							set macroState = 0
							# log 'macroState', macroState, ch
						else
							set macroState = 1
							# log 'macroState', macroState, ch
					else
						if macroState == 1
							if ch == '$'
								set ch = '#'
								set lineHasMacro = true
								# log 'macroState', macroState, ch
							elif ch == '\\'
								# could be an escape of a macro inside a macro
								set macroState = 2
								# log 'macroState', macroState, ch
				
				_ processChar(ch)

			function processChar
                param ch

				if ch == '\n'
                    if line
                        if typeof (line.value) !== 'undefined'
                            set line.value = line.value.trim()
						set line.hasMacro = lineHasMacro
                        _ lines.push(line)
                        set line = null
						set lineHasMacro = false
                    else 
						# Allow blank line. Do nothing
                    set leadingWhiteSpaces = 0
                    set colpos = 0
                    set linepos++
					if commentState != 2
                        set commentState = 0
                
				elif ch == '\r'

				elif [' ', '\t'].indexOf(ch) !== -1
                    if ch == '\t'
                        set colpos += 3
                    if line
                        if typeof (line.value) == 'undefined'
                            set line.value = ''
                        else 
                            set line.value += ch
                    else 
                        set leadingWhiteSpaces += ch == ' ' ? 1 : 4
                
				elif ['('].indexOf(ch) !== -1
                    if line
                        if typeof (line.value) == 'undefined'
                            set line.tagSuffix = ch
                            set line.value = ''
                        else 
                            set line.value += ch
                    else 
                        set line =
                            { 
                                @ indent leadingWhiteSpaces / 4
                                @ name ch
                                @ row linepos
                                @ col colpos
                                @ sourceKey sourceKey
                
				else 
                    if line
                        if typeof(line.value) == 'undefined'
                            set line.name += ch
                        else 
                            set line.value += ch
                    else 
                        set line =
                            { 
                                @ indent leadingWhiteSpaces / 4
                                @ name ch
                                @ row linepos
                                @ col colpos
                                @ sourceKey sourceKey
