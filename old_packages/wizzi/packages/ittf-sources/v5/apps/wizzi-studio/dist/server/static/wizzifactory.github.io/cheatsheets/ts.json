{
    "title": "Schema cheat sheet",
    "language": "ts",
    "elements": [
        {
            "name": "variables",
            "tag": "",
            "ast": "",
            "category": "",
            "items": [
                {
                    "title": "Boolean, Number, String",
                    "ittfWrapped": "module \\n    let isDone\\n        :boolean \\n        := false\\n    let decimal\\n        :number \\n        := 6\\n    let hex\\n        :number \\n        := 61453\\n    let binary\\n        :number \\n        := 10\\n    let octal\\n        :number \\n        := 484\\n    let color\\n        :string \\n        := \\\"blue\\\"\\n    set color = 'red'\\n    let fullName\\n        :string \\n        `lit \\n            + Bob Bobbington\\n    let age\\n        :number \\n        := 37\\n    let sentence\\n        :string \\n        `lit \\n            + Hello, my name is\\n            @ fullName\\n            + \\n    let sentence\\n        :string \\n        set \\\"Hello, my name is \\\" + fullName + \\\".\\n\\n\\\" + \\\"I'll be \\\" + (age + 1) + \\\" years old next month.\\\"",
                    "generated": "\\nlet isDone: boolean = false;\\nlet decimal: number = 6;\\nlet hex: number = 61453;\\nlet binary: number = 10;\\nlet octal: number = 484;\\nlet color: string = \\\"blue\\\";\\n (\\n    &lt;set&gt;\\n    color = 'red'\\n    &lt;/set&gt;\\n)\\nlet fullName: string = `Bob Bobbington`;\\nlet age: number = 37;\\nlet sentence: string = `Hello, my name is${fullName}`;\\nlet sentence: string =  (\\n    &lt;set&gt;\\n    \\\"Hello, my name is \\\" + fullName + \\\".\\n\\n\\\" + \\\"I'll be \\\" + (age + 1) + \\\" years old next month.\\\"\\n    &lt;/set&gt;\\n)\\n;\\n"
                },
                {
                    "title": "Array, Tuple",
                    "ittfWrapped": "module \\n    let list\\n        :[ \\n            :number \\n        [ \\n            @ 1\\n            @ 2\\n            @ 3\\n    let Array\\n        :number \\n        [ \\n            @ 1\\n            @ 2\\n            @ 3\\n    let x\\n        :tuple \\n            :string \\n            :number \\n    set x =\\n        [ \\n            @ \\\"hello\\\"\\n            @ 10\\n    set x =\\n        [ \\n            @ 10\\n            @ \\\"hello\\\"",
                    "generated": "\\nlet list: number[] = [\\n    1, \\n    2, \\n    3\\n];\\nlet Array: number = [\\n    1, \\n    2, \\n    3\\n];\\nlet x = string | number;\\n (\\n    &lt;set&gt;\\n    x =\\n    [\\n        \\\"hello\\\", \\n        10\\n    ]&lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    x =\\n    [\\n        10, \\n        \\\"hello\\\"\\n    ]&lt;/set&gt;\\n)\\n"
                },
                {
                    "title": "Enum",
                    "ittfWrapped": "module \\n    :enum Color\\n        @ Red\\n        @ Green\\n        @ Blue\\n    let c\\n        :ref Color\\n        := Color.Green\\n    :enum Color\\n        @ Red 1\\n        @ Green\\n        @ Blue\\n    let c\\n        :ref Color\\n        := Color.Green\\n    :enum Color\\n        @ Red 1\\n        @ Green 2\\n        @ Blue 4\\n    let c\\n        :ref Color\\n        := Color.Green\\n    :enum Color\\n        @ Red 1\\n        @ Green\\n        @ Blue\\n    let colorName\\n        :string \\n        := Color[2]",
                    "generated": "\\n@Red\\n, @Green\\n, @Blue\\nlet c: Color = Color.Green;\\n@Red 1\\n, @Green\\n, @Blue\\nlet c: Color = Color.Green;\\n@Red 1\\n, @Green 2\\n, @Blue 4\\nlet c: Color = Color.Green;\\n@Red 1\\n, @Green\\n, @Blue\\nlet colorName: string = Color[2];\\n"
                },
                {
                    "title": "Any, Void, Null, Undefined",
                    "ittfWrapped": "module \\n    let notSure\\n        :any \\n        := 4\\n    set notSure = \\\"maybe a string instead\\\"\\n    set notSure = false\\n    let notSure\\n        :any \\n        := 4\\n    _ notSure.ifItExists\\n    _ notSure.toFixed\\n    let prettySure\\n        :ref Object\\n        := 4\\n    _ prettySure.toFixed\\n    let list\\n        :[ \\n            :any \\n        [ \\n            @ 1\\n            @ true\\n            @ \\\"free\\\"\\n    set list[1] = 100\\n    function warnUser\\n        :return \\n            :void \\n        _ console.log(\\\"This is my warning message\\\")\\n    let unusable\\n        :void \\n        := undefined\\n    let u\\n        :void \\n        := undefined\\n    let n\\n        :null \\n        := null",
                    "generated": "\\nlet notSure: any = 4;\\n (\\n    &lt;set&gt;\\n    notSure = \\\"maybe a string instead\\\"\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    notSure = false\\n    &lt;/set&gt;\\n)\\nlet notSure: any = 4;\\nnotSure.ifItExists();\\nnotSure.toFixed();\\nlet prettySure: Object = 4;\\nprettySure.toFixed();\\nlet list: any[] = [\\n    1, \\n    true, \\n    \\\"free\\\"\\n];\\n (\\n    &lt;set&gt;\\n    list[1] = 100\\n    &lt;/set&gt;\\n)\\nfunction warnUser():  void {\\n    console.log(\\\"This is my warning message\\\");\\n}\\nlet unusable: void = undefined;\\nlet u: void = undefined;\\nlet n: null = null;\\n"
                },
                {
                    "title": "Never",
                    "ittfWrapped": "module \\n    function error\\n        param message\\n            :string \\n        :return \\n            :never \\n        throw new Error(message)\\n    function fail\\n        return error(\\\"Something failed\\\")\\n    function infiniteLoop\\n        :return \\n            :never \\n        while true",
                    "generated": "\\nfunction error(message: string):  never {\\n    throw new Error(message);\\n}\\nfunction fail() {\\n    return error(\\\"Something failed\\\");\\n}\\nfunction infiniteLoop():  never {\\n    while (true) {\\n    }\\n}\\n"
                },
                {
                    "title": "Object",
                    "ittfWrapped": "module \\n    :function create\\n        param o\\n            :union \\n                :object \\n                :null \\n        :return \\n            :void \\n    let strLength\\n        :number \\n        :as \\n            ( \\n                :string \\n                ident someValue\\n            . length",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: :object, wzElement: undefined, wzName:, row:5, col:17, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0002     :function create\\\",\\n    \\\"0003         param o\\\",\\n    \\\"0004             :union \\\",\\n    \\\"0005                 :object \\\",\\n    \\\"                     ^ Tag not recognized: :object  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0006                 :null \\\",\\n    \\\"0007         :return \\\",\\n    \\\"0008             :void \\\",\\n    \\\"0009     let strLength\\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at typeUnion.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1053:23)\\n    at param.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at param.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:735:29)\\n    at param.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:2783:48)\\n    at param.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:2793:27)\\n    at typeFunctionDeclare.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at typeFunctionDeclare.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:3307:29)\\n    at typeFunctionDeclare.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:3325:27)\\n    at module.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\\"\\n}"
                }
            ]
        },
        {
            "name": "function",
            "tag": "function",
            "ast": "",
            "category": "",
            "items": [
                {
                    "title": "Typed functions",
                    "ittfWrapped": "module \\n    function add\\n        param x\\n            :number \\n        param y\\n            :number \\n        :return \\n            :number \\n        return x + y\\n    let myAdd\\n        function \\n            param x\\n                :number \\n            param y\\n                :number \\n            :return \\n                :number \\n            return x + y",
                    "generated": "\\nfunction add(x: number, y: number):  number {\\n    return x + y;\\n}\\nlet myAdd = function(x: number, y: number):  number {\\n    return x + y;\\n};\\n"
                },
                {
                    "title": "Typed functions",
                    "ittfWrapped": "module \\n    let myAdd\\n        :=> \\n            :number \\n            param x\\n                :number \\n            param y\\n                :number \\n        function \\n            param x\\n                :number \\n            param y\\n                :number \\n            :return \\n                :number \\n            return x + y",
                    "generated": "\\nlet myAdd: (x: number = function(x: number, y: number, y: number)):  number {\\n    return x + y;\\n};\\n"
                },
                {
                    "title": "Optional parameters",
                    "ittfWrapped": "module \\n    function buildName\\n        param firstName\\n            :string \\n        param \\n            :string \\n            :optional \\n        if lastName\\n            return firstName + \\\" \\\" + lastName\\n        else \\n            return firstName",
                    "generated": "\\nfunction buildName(firstName: string, : string) {\\n    if (lastName) {\\n        return firstName + \\\" \\\" + lastName;\\n    }\\n    else {\\n        return firstName;\\n    }\\n}\\n"
                },
                {
                    "title": "Rest parameters",
                    "ittfWrapped": "module \\n    function buildName\\n        param firstName\\n            :string \\n        param ...restOfName\\n            :[ \\n                :string \\n        return firstName + \\\" \\\" + restOfName.join(\\\" \\\")\\n    function buildName\\n        param firstName\\n            :string \\n        param ...restOfName\\n            :[ \\n                :string \\n        return firstName + \\\" \\\" + restOfName.join(\\\" \\\")\\n    let buildNameFun\\n        :=> \\n            :string \\n            param fname\\n                :string \\n            param ...rest\\n                :[ \\n                    :string \\n        := buildName",
                    "generated": "\\nfunction buildName(firstName: string, ...restOfName: string[]) {\\n    return firstName + \\\" \\\" + restOfName.join(\\\" \\\");\\n}\\nfunction buildName(firstName: string, ...restOfName: string[]) {\\n    return firstName + \\\" \\\" + restOfName.join(\\\" \\\");\\n}\\nlet buildNameFun: (fname: string = buildName;\\n, ...rest: string[]\\n"
                },
                {
                    "title": "This and arrow functions",
                    "ittfWrapped": "module \\n    let deck\\n        { \\n            [ suits\\n                @ \\\"hearts\\\"\\n                @ \\\"spades\\\"\\n                @ \\\"clubs\\\"\\n                @ \\\"diamonds\\\"\\n            @ cards Array(52)\\n            @ createCardPicker\\n                function \\n                    return \\n                        function \\n                            let pickedCard = Math.floor(Math.random() * 52)\\n                            let pickedSuit = Math.floor(pickedCard / 13)\\n                            return \\n                                { \\n                                    @ suit this.suits[pickedSuit]\\n                                    @ card pickedCard % 13\\n    let deck\\n        { \\n            [ suits\\n                @ \\\"hearts\\\"\\n                @ \\\"spades\\\"\\n                @ \\\"clubs\\\"\\n                @ \\\"diamonds\\\"\\n            @ cards Array(52)\\n            @ createCardPicker\\n                function \\n                    # NOTE: the line below is now an arrow function, allowing us to capture 'this' right here\\n                    return \\n                        => \\n                            let pickedCard = Math.floor(Math.random() * 52)\\n                            let pickedSuit = Math.floor(pickedCard / 13)\\n                            return \\n                                { \\n                                    @ suit this.suits[pickedSuit]\\n                                    @ card pickedCard % 13",
                    "generated": "\\nlet deck = {\\n    suits: [\\n        \\\"hearts\\\", \\n        \\\"spades\\\", \\n        \\\"clubs\\\", \\n        \\\"diamonds\\\"\\n    ], \\n    cards: Array(52), \\n    createCardPicker: function() {\\n        return function() {\\n                let pickedCard = Math.floor(Math.random() * 52);\\n                let pickedSuit = Math.floor(pickedCard / 13);\\n                return {\\n                        suit: this.suits[pickedSuit], \\n                        card: pickedCard % 13\\n                    };\\n            };\\n    }\\n};\\nlet deck = {\\n    suits: [\\n        \\\"hearts\\\", \\n        \\\"spades\\\", \\n        \\\"clubs\\\", \\n        \\\"diamonds\\\"\\n    ], \\n    cards: Array(52), \\n    createCardPicker: function() {\\n        // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here\\n        return () =&gt; {\\n                let pickedCard = Math.floor(Math.random() * 52);\\n                let pickedSuit = Math.floor(pickedCard / 13);\\n                return {\\n                        suit: this.suits[pickedSuit], \\n                        card: pickedCard % 13\\n                    };\\n            };\\n    }\\n};\\n"
                },
                {
                    "title": "This parameters in callbacks",
                    "ittfWrapped": "module \\n    :interface UIElement\\n        :m addClickListener\\n            :void \\n            param onclick\\n                :=> \\n                    :void \\n                    param this\\n                        :void \\n                    param e\\n                        :ref Event\\n    class Handler\\n        p info\\n            :string \\n        m onClickBad\\n            param this\\n                :ref Handler\\n            param e\\n                :ref Event\\n            set this.info = e.message",
                    "generated": "\\ninterface UIElement {\\n    addClickListener(onclick: (this: void, e: Event)): void;\\n}\\nclass Handler {\\n    info: string;\\n    onClickBad(this: Handler, e: Event) {\\n         (\\n            &lt;set&gt;\\n            this.info = e.message\\n            &lt;/set&gt;\\n        )\\n    }\\n}\\n"
                },
                {
                    "title": "Overloads 1",
                    "ittfWrapped": "module \\n    let suits\\n        [ \\n            @ \\\"hearts\\\"\\n            @ \\\"spades\\\"\\n            @ \\\"clubs\\\"\\n            @ \\\"diamonds\\\"\\n    function pickCard\\n        param x\\n        :return \\n            :any \\n        if typeof x == \\\"object\\\"\\n            let pickedCard = Math.floor(Math.random() * x.length)\\n            return pickedCard\\n        else \\n            # Otherwise just let them pick the card\\n            if typeof x == \\\"number\\\"\\n                let pickedSuit = Math.floor(x / 13)\\n                return \\n                    { \\n                        @ suit suits[pickedSuit]\\n                        @ card x % 13",
                    "generated": "\\nlet suits = [\\n    \\\"hearts\\\", \\n    \\\"spades\\\", \\n    \\\"clubs\\\", \\n    \\\"diamonds\\\"\\n];\\nfunction pickCard(x):  any {\\n    if (typeof x == \\\"object\\\") {\\n        let pickedCard = Math.floor(Math.random() * x.length);\\n        return pickedCard;\\n    }\\n    else {\\n        // Otherwise just let them pick the card\\n        if (typeof x == \\\"number\\\") {\\n            let pickedSuit = Math.floor(x / 13);\\n            return {\\n                    suit: suits[pickedSuit], \\n                    card: x % 13\\n                };\\n        }\\n    }\\n}\\n"
                },
                {
                    "title": "Overloads 2",
                    "ittfWrapped": "module \\n    let suits\\n        [ \\n            @ \\\"hearts\\\"\\n            @ \\\"spades\\\"\\n            @ \\\"clubs\\\"\\n            @ \\\"diamonds\\\"\\n    :function pickCard\\n        param x\\n            :[ \\n                :{ \\n                    :p suit\\n                        :string \\n                    :p card\\n                        :number \\n        :return \\n            :number \\n    :function pickCard\\n        param x\\n            :number \\n        :return \\n            :{ \\n                :p suit\\n                    :string \\n                :p card\\n                    :number \\n    function pickCard\\n        param x\\n        :return \\n            :any \\n        # if so, they gave us the deck and we'll pick the card\\n        if typeof x == \\\"object\\\"\\n            let pickedCard = Math.floor(Math.random() * x.length)\\n            return pickedCard\\n        else \\n            # Otherwise just let them pick the card\\n            if typeof x == \\\"number\\\"\\n                let pickedSuit = Math.floor(x / 13)\\n                return \\n                    { \\n                        @ suit suits[pickedSuit]\\n                        @ card x % 13",
                    "generated": "\\nlet suits = [\\n    \\\"hearts\\\", \\n    \\\"spades\\\", \\n    \\\"clubs\\\", \\n    \\\"diamonds\\\"\\n];\\nfunction pickCard(x: {suit: string;\\n    card: number;\\n}[]):  number;\\nfunction pickCard(x: number):  {suit: string;\\n    ;\\n    card: number;\\n    function pickCard(x}):  any {\\n    // if so, they gave us the deck and we'll pick the card\\n    if (typeof x == \\\"object\\\") {\\n        let pickedCard = Math.floor(Math.random() * x.length);\\n        return pickedCard;\\n    }\\n    else {\\n        // Otherwise just let them pick the card\\n        if (typeof x == \\\"number\\\") {\\n            let pickedSuit = Math.floor(x / 13);\\n            return {\\n                    suit: suits[pickedSuit], \\n                    card: x % 13\\n                };\\n        }\\n    }\\n}\\n"
                }
            ]
        },
        {
            "name": "class",
            "tag": "class",
            "ast": "",
            "category": "",
            "items": [
                {
                    "title": "Simple class",
                    "ittfWrapped": "module \\n    class Greeter\\n        p greeting\\n            :string \\n        ctor \\n            param message\\n                :string \\n            set this.greeting = message\\n        m greet\\n            return \\\"Hello, \\\" + this.greeting\\n    let greeter = new Greeter(\\\"world\\\")",
                    "generated": "\\nclass Greeter {\\n    constructor(message: string) { (\\n            &lt;set&gt;\\n            this.greeting = message\\n            &lt;/set&gt;\\n        )\\n    }\\n    greeting: string;\\n    greet() {\\n        return \\\"Hello, \\\" + this.greeting;\\n    }\\n}\\nlet greeter = new Greeter(\\\"world\\\");\\n"
                },
                {
                    "title": "Class extension",
                    "ittfWrapped": "module \\n    class Animal\\n        m move\\n            param distanceInMeters\\n                :number \\n                := 0\\n            _ console.log\\n                `lit \\n                    + Animal moved\\n                    @ distanceInMeters\\n                    + m.\\n    class Dog\\n        super Animal\\n        m bark\\n            _ console.log('Woof! Woof!')",
                    "generated": "\\nclass Animal {\\n    move( = 0) {\\n        console.log(`Animal moved${distanceInMeters}m.`);\\n    }\\n}\\nclass Dog extends Animal {\\n    bark() {\\n        console.log('Woof! Woof!');\\n    }\\n}\\n"
                },
                {
                    "title": "Complex class example",
                    "ittfWrapped": "module \\n    class Animal\\n        p name\\n            :string \\n        ctor \\n            param theName\\n                :string \\n            set this.name = theName\\n        m move\\n            param distanceInMeters\\n                :number \\n                := 0\\n            _ console.log\\n                `lit \\n                    + \\n                    @ this.name\\n                    + moved\\n                    @ distanceInMeters\\n                    + m.\\n    class Snake\\n        super Animal\\n        ctor \\n            param name\\n                :string \\n            _ super(name)\\n        m move\\n            param distanceInMeters = 5\\n            _ console.log(\\\"Slithering...\\\")\\n            _ super.move(distanceInMeters)\\n    class Horse\\n        super Animal\\n        ctor \\n            param name\\n                :string \\n            _ super(name)\\n        m move\\n            param distanceInMeters = 45\\n            _ console.log(\\\"Galloping...\\\")\\n            _ super.move(distanceInMeters)",
                    "generated": "\\nclass Animal {\\n    constructor(theName: string) { (\\n            &lt;set&gt;\\n            this.name = theName\\n            &lt;/set&gt;\\n        )\\n    }\\n    name: string;\\n    move( = 0) {\\n        console.log(`${this.name}moved${distanceInMeters}m.`);\\n    }\\n}\\nclass Snake extends Animal {\\n    constructor(name: string) {super(name);\\n    }\\n    move(distanceInMeters = 5) {\\n        console.log(\\\"Slithering...\\\");\\n        super.move(distanceInMeters);\\n    }\\n}\\nclass Horse extends Animal {\\n    constructor(name: string) {super(name);\\n    }\\n    move(distanceInMeters = 45) {\\n        console.log(\\\"Galloping...\\\");\\n        super.move(distanceInMeters);\\n    }\\n}\\n"
                },
                {
                    "title": "Class accessors",
                    "ittfWrapped": "module \\n    class Animal\\n        p name\\n            :private \\n            :string \\n        ctor \\n            param theName\\n                :string \\n            set this.name = theName\\n    class Rhino\\n        super Animal\\n        ctor \\n            _ super(\\\"Rhino\\\")\\n    class Person\\n        p name\\n            :protected \\n            :string \\n        ctor \\n            param name\\n                :string \\n            set this.name = name\\n    class Employee\\n        super Person\\n        p department\\n            :private \\n            :string \\n        ctor \\n            param name\\n                :string \\n            param department\\n                :string \\n            _ super(name)\\n            set this.department = department\\n        m getElevatorPitch\\n            :public \\n            return \\n                `lit \\n                    + Hello, my name is\\n                    @ this.name\\n                    + and I work in\\n                    @ this.department\\n                    + .\\n    class Person\\n        p name\\n            :protected \\n            :string \\n        ctor \\n            :protected \\n            param theName\\n                :string \\n            set this.name = theName\\n    class Employee\\n        super Person\\n        p department\\n            :private \\n            :string \\n        ctor \\n            param name\\n                :string \\n            param department\\n                :string \\n            _ super(name)\\n            set this.department = department\\n        m getElevatorPitch\\n            :public \\n            return \\n                `lit \\n                    + Hello, my name is\\n                    @ this.name\\n                    + and I work in\\n                    @ this.department\\n                    + .",
                    "generated": "\\nclass Animal {\\n    constructor(theName: string) { (\\n            &lt;set&gt;\\n            this.name = theName\\n            &lt;/set&gt;\\n        )\\n    }\\n    name: string;\\n}\\nclass Rhino extends Animal {\\n    constructor() {super(\\\"Rhino\\\");\\n    }\\n}\\nclass Person {\\n    constructor(name: string) { (\\n            &lt;set&gt;\\n            this.name = name\\n            &lt;/set&gt;\\n        )\\n    }\\n    name: string;\\n}\\nclass Employee extends Person {\\n    constructor(name: string, department: string) {super(name);\\n         (\\n            &lt;set&gt;\\n            this.department = department\\n            &lt;/set&gt;\\n        )\\n    }\\n    department: string;\\n    getElevatorPitch() {\\n        return `Hello, my name is${this.name}and I work in${this.department}.`;\\n    }\\n}\\nclass Person {\\n    constructor(theName: string) { (\\n            &lt;set&gt;\\n            this.name = theName\\n            &lt;/set&gt;\\n        )\\n    }\\n    name: string;\\n}\\nclass Employee extends Person {\\n    constructor(name: string, department: string) {super(name);\\n         (\\n            &lt;set&gt;\\n            this.department = department\\n            &lt;/set&gt;\\n        )\\n    }\\n    department: string;\\n    getElevatorPitch() {\\n        return `Hello, my name is${this.name}and I work in${this.department}.`;\\n    }\\n}\\n"
                },
                {
                    "title": "Readonly modifier",
                    "ittfWrapped": "module \\n    class Octopus\\n        p name\\n            :readonly \\n            :string \\n        p numberOfLegs\\n            :readonly \\n            :number \\n            := 8\\n        ctor \\n            param theName\\n                :string \\n            set this.name = theName\\n    class Octopus\\n        p numberOfLegs\\n            :readonly \\n            :number \\n            := 8\\n        ctor \\n            param \\n                :readonly \\n                :string ",
                    "generated": "\\nclass Octopus {\\n    constructor(theName: string) { (\\n            &lt;set&gt;\\n            this.name = theName\\n            &lt;/set&gt;\\n        )\\n    }\\n    name: string;\\n    numberOfLegs: number = 8;\\n}\\nclass Octopus {\\n    constructor(: string) {}\\n    numberOfLegs: number = 8;\\n}\\n"
                },
                {
                    "title": "Static members",
                    "ittfWrapped": "module \\n    class Grid\\n        p origin\\n            static \\n            { \\n                @ x 0\\n                @ y 0\\n        m calculateDistanceFromOrigin\\n            param point\\n                :{ \\n                    :p x\\n                        :number \\n                    :p y\\n                        :number \\n            let xDist = (point.x - Grid.origin.x)\\n            let yDist = (point.y - Grid.origin.y)\\n            return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale",
                    "generated": "\\nclass Grid {\\n    static originorigin: {\\n            {\\n                x: 0, \\n                y: 0calculateDistanceFromOrigin(point: {x: number;\\n                    \\n                }y: number;\\n                \\n            }\\n    }) {\\n        let xDist = (point.x - Grid.origin.x);\\n        let yDist = (point.y - Grid.origin.y);\\n        return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale;\\n    }\\n}\\n"
                },
                {
                    "title": "Abstract classes",
                    "ittfWrapped": "module \\n    class Animal\\n        :abstract \\n        :m makeSound\\n            :abstract \\n            :return \\n                :void \\n        m move\\n            _ console.log(\\\"roaming the earth...\\\")\\n    class Department\\n        :abstract \\n        ctor \\n            param name\\n                :string \\n        m printName\\n            _ console.log(\\\"Department name: \\\" + this.name)\\n        :m printMeeting\\n            :abstract \\n            :return \\n                :void \\n    class AccountingDepartment\\n        super Department\\n        ctor \\n            _ super(\\\"Accounting and Auditing\\\")\\n        m printMeeting\\n            _ console.log(\\\"The Accounting Department meets each Monday at 10am.\\\")\\n        m generateReports\\n            _ console.log(\\\"Generating accounting reports...\\\")",
                    "generated": "\\nclass Animal {\\n    makeSoundmakeSound: {\\n             void\\n        }\\n    move() {\\n        console.log(\\\"roaming the earth...\\\");\\n    }\\n}\\nclass Department {\\n    constructor(name: string) {}\\n    printName() {\\n        console.log(\\\"Department name: \\\" + this.name);\\n    }\\n    printMeetingprintMeeting: {\\n             void\\n        }\\n}\\nclass AccountingDepartment extends Department {\\n    constructor() {super(\\\"Accounting and Auditing\\\");\\n    }\\n    printMeeting() {\\n        console.log(\\\"The Accounting Department meets each Monday at 10am.\\\");\\n    }\\n    generateReports() {\\n        console.log(\\\"Generating accounting reports...\\\");\\n    }\\n}\\n"
                },
                {
                    "title": "Static members",
                    "ittfWrapped": "module \\n    class Greeter\\n        p standardGreeting\\n            static \\n            := \\\"Hello, there\\\"\\n        p greeting\\n            :string \\n        m greet\\n            if this.greeting\\n                return \\\"Hello, \\\" + this.greeting\\n            else \\n                return Greeter.standardGreeting",
                    "generated": "\\nclass Greeter {\\n    static standardGreeting = \\\"Hello, there\\\";\\n    greeting: string;\\n    greet() {\\n        if (this.greeting) {\\n            return \\\"Hello, \\\" + this.greeting;\\n        }\\n        else {\\n            return Greeter.standardGreeting;\\n        }\\n    }\\n}\\n"
                },
                {
                    "title": "Class extended by interface",
                    "ittfWrapped": "module \\n    class Point\\n        p x\\n            :number \\n        p y\\n            :number \\n    :interface Point3d\\n        :extends Point\\n        :p z\\n            :number \\n    let point3d\\n        :ref Point3d\\n        { \\n            @ x 1\\n            @ y 2\\n            @ z 3",
                    "generated": "\\nclass Point {\\n    x: number;\\n    y: number;\\n}\\ninterface Point3d implements Point {\\n    z: number;\\n}\\nlet point3d: Point3d = {\\n    x: 1, \\n    y: 2, \\n    z: 3\\n};\\n"
                }
            ]
        },
        {
            "name": "interfaces",
            "tag": "",
            "ast": "",
            "category": "",
            "items": [
                {
                    "title": "Simple interface",
                    "ittfWrapped": "module \\n    :interface LabelledValue\\n        :p label\\n            :string \\n    function printLabel\\n        param labelledObj\\n            :ref LabelledValue\\n        _ console.log(labelledObj.label)",
                    "generated": "\\ninterface LabelledValue {\\n    label: string;\\n}\\nfunction printLabel(labelledObj: LabelledValue) {\\n    console.log(labelledObj.label);\\n}\\n"
                },
                {
                    "title": "Optional properties",
                    "ittfWrapped": "module \\n    :interface SquareConfig\\n        :p color\\n            :optional \\n            :string \\n        :p width\\n            :optional \\n            :number \\n    function createSquare\\n        param config\\n            :ref SquareConfig\\n        :return \\n            :{ \\n                :p color\\n                    :string \\n                :p area\\n                    :number \\n        let newSquare\\n            { \\n                @ color \\\"white\\\"\\n                @ area 100\\n        if config.color\\n            set newSquare.color = config.color\\n        if config.width\\n            set newSquare.area = config.width * config.width\\n        return newSquare\\n    let mySquare\\n        _ createSquare\\n            { \\n                @ color \\\"black\\\"",
                    "generated": "\\ninterface SquareConfig {\\n    color?: string;\\n    width?: number;\\n}\\nfunction createSquare(config: SquareConfig):  {color: string;\\n     {\\n        let newSquare = {\\n            color: \\\"white\\\"area: number;\\n            , \\n            area: 100}\\n    };\\n    if (config.color) {\\n         (\\n            &lt;set&gt;\\n            newSquare.color = config.color\\n            &lt;/set&gt;\\n        )\\n    }\\n    if (config.width) {\\n         (\\n            &lt;set&gt;\\n            newSquare.area = config.width * config.width\\n            &lt;/set&gt;\\n        )\\n    }\\n    return newSquare;\\n}\\nlet mySquare = createSquare({\\n    color: \\\"black\\\"\\n});\\n"
                },
                {
                    "title": "Optional properties 2",
                    "ittfWrapped": "module \\n    :interface SquareConfig\\n        :p color\\n            :optional \\n            :string \\n        :p width\\n            :optional \\n            :number \\n    function createSquare\\n        param config\\n            :ref SquareConfig\\n        :return \\n            :{ \\n                :p color\\n                    :string \\n                :p area\\n                    :number \\n        let newSquare\\n            { \\n                @ color \\\"white\\\"\\n                @ area 100\\n        if config.clor\\n            # Error: Property 'clor' does not exist on type 'SquareConfig'\\n            set newSquare.color = config.clor\\n        if config.width\\n            set newSquare.area = config.width * config.width\\n        return newSquare\\n    let mySquare\\n        _ createSquare\\n            { \\n                @ color \\\"black\\\"",
                    "generated": "\\ninterface SquareConfig {\\n    color?: string;\\n    width?: number;\\n}\\nfunction createSquare(config: SquareConfig):  {color: string;\\n     {\\n        let newSquare = {\\n            color: \\\"white\\\"area: number;\\n            , \\n            area: 100}\\n    };\\n    if (config.clor) {\\n        // Error: Property 'clor' does not exist on type 'SquareConfig'\\n         (\\n            &lt;set&gt;\\n            newSquare.color = config.clor\\n            &lt;/set&gt;\\n        )\\n    }\\n    if (config.width) {\\n         (\\n            &lt;set&gt;\\n            newSquare.area = config.width * config.width\\n            &lt;/set&gt;\\n        )\\n    }\\n    return newSquare;\\n}\\nlet mySquare = createSquare({\\n    color: \\\"black\\\"\\n});\\n"
                },
                {
                    "title": "Readonly properties",
                    "ittfWrapped": "module \\n    :interface Point\\n        :p x\\n            :number \\n        :p y\\n            :number \\n    let p1\\n        :ref Point\\n        { \\n            @ x 10\\n            @ y 20\\n    set p1.x = 5\\n    let a\\n        :[ \\n            :number \\n        [ \\n            @ 1\\n            @ 2\\n            @ 3\\n            @ 4\\n    let ReadonlyArray\\n        :number \\n        := a\\n    set ro[0] = 12\\n    _ ro.push(5)\\n    set ro.length = 100\\n    set a = ro\\n    set a =\\n        :as \\n            :[ \\n                :number \\n            ident ro",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: ident, wzElement: undefined, wzName:, row:32, col:13, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0029         :as \\\",\\n    \\\"0030             :[ \\\",\\n    \\\"0031                 :number \\\",\\n    \\\"0032             ident ro\\\",\\n    \\\"                 ^ Tag not recognized: ident  &lt;--- --- --- --- --- ERROR\\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at typeAs.typeSimple.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7165:23)\\n    at htmlelement.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at htmlelement.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:359:29)\\n    at htmlelement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:6713:48)\\n    at htmlelement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:6723:27)\\n    at module.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at module.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:207:29)\\n    at module.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1127:48)\\n    at module.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1137:27)\\\"\\n}"
                },
                {
                    "title": "Readonly vs const",
                    "ittfWrapped": "module \\n    :interface SquareConfig\\n        :p color\\n            :optional \\n            :string \\n        :p width\\n            :optional \\n            :number \\n    function createSquare\\n        param config\\n            :ref SquareConfig\\n        :return \\n            :{ \\n                :p color\\n                    :string \\n                :p area\\n                    :number \\n    let mySquare\\n        _ createSquare\\n            { \\n                @ colour \\\"red\\\"\\n                @ width 100",
                    "generated": "\\ninterface SquareConfig {\\n    color?: string;\\n    width?: number;\\n}\\nfunction createSquare(config: SquareConfig):  {color: string;\\n     {\\n    }\\n    area: number;\\n    let mySquare = createSquare({\\n        colour: \\\"red\\\"}, \\n    width: 100\\n});\\n"
                },
                {
                    "title": "",
                    "ittfWrapped": "module \\n    let mySquare\\n        _ createSquare\\n            { \\n                @ colour \\\"red\\\"\\n                @ width 100\\n    let mySquare\\n        _ createSquare\\n            :as \\n                :ref SquareConfig\\n                { \\n                    @ width 100\\n                    @ opacity 0.5\\n    :interface SquareConfig\\n        :p color\\n            :optional \\n            :string \\n        :p width\\n            :optional \\n            :number \\n        :index \\n            :any \\n            param propName\\n                :string \\n    let squareOptions\\n        { \\n            @ colour \\\"red\\\"\\n            @ width 100\\n    let mySquare = createSquare(squareOptions)",
                    "generated": "\\nlet mySquare = createSquare({\\n    colour: \\\"red\\\", \\n    width: 100\\n});\\nlet mySquare = createSquare(( as SquareConfig){\\n    width: 100, \\n    opacity: 0.5\\n});\\ninterface SquareConfig {\\n    color?: string;\\n    width?: number;\\n    *** :index }\\nlet squareOptions = {\\n    colour: \\\"red\\\", \\n    width: 100\\n};\\nlet mySquare = createSquare(squareOptions);\\n"
                },
                {
                    "title": "Function Types",
                    "ittfWrapped": "module \\n    :interface SearchFunc\\n        :call \\n            :boolean \\n            param source\\n                :string \\n            param subString\\n                :string \\n    let mySearch\\n        :ref SearchFunc\\n    set mySearch =\\n        function \\n            param source\\n                :string \\n            param subString\\n                :string \\n            let result = source.search(subString)\\n            return result > -1\\n    let mySearch\\n        :ref SearchFunc\\n    set mySearch =\\n        function \\n            param src\\n                :string \\n            param sub\\n                :string \\n            :return \\n                :boolean \\n            let result = src.search(sub)\\n            return result > -1\\n    let mySearch\\n        :ref SearchFunc\\n    set mySearch =\\n        function \\n            param src\\n            param sub\\n            let result = src.search(sub)\\n            return result > -1",
                    "generated": "\\ninterface SearchFunc {\\n    (source: string, subString: string): boolean\\n}\\nlet mySearch: SearchFunc;\\n (\\n    &lt;set&gt;\\n    mySearch =\\n    function(source: string, subString: string) {\\n        let result = source.search(subString);\\n        return result &gt; -1;\\n    }&lt;/set&gt;\\n)\\nlet mySearch: SearchFunc;\\n (\\n    &lt;set&gt;\\n    mySearch =\\n    function(src: string, sub: string):  boolean {\\n        let result = src.search(sub);\\n        return result &gt; -1;\\n    }&lt;/set&gt;\\n)\\nlet mySearch: SearchFunc;\\n (\\n    &lt;set&gt;\\n    mySearch =\\n    function(src, sub) {\\n        let result = src.search(sub);\\n        return result &gt; -1;\\n    }&lt;/set&gt;\\n)\\n"
                },
                {
                    "title": "Indexable Types",
                    "ittfWrapped": "module \\n    :interface StringArray\\n        :index \\n            :string \\n            param index\\n                :number \\n    let myArray\\n        :ref StringArray\\n    set myArray =\\n        [ \\n            @ \\\"Bob\\\"\\n            @ \\\"Fred\\\"\\n    let myStr\\n        :string \\n        := myArray[0]\\n    class Animal\\n        p name\\n            :string \\n    class Dog\\n        super Animal\\n        p breed\\n            :string \\n    :interface NotOkay\\n        :index \\n            :ref Animal\\n            param x\\n                :number \\n        :index \\n            :ref Dog\\n            param x\\n                :string \\n    :interface NumberDictionary\\n        :index \\n            :number \\n            param index\\n                :string \\n        :p length\\n            :number \\n        :p name\\n            :string \\n    :interface ReadonlyStringArray\\n        :index \\n            :string \\n            param index\\n                :number \\n    let myArray\\n        :ref ReadonlyStringArray\\n        [ \\n            @ \\\"Alice\\\"\\n            @ \\\"Bob\\\"\\n    set myArray[2] = \\\"Mallory\\\"",
                    "generated": "\\ninterface StringArray {\\n    *** :index }\\nlet myArray: StringArray;\\n (\\n    &lt;set&gt;\\n    myArray =\\n    [\\n        \\\"Bob\\\", \\n        \\\"Fred\\\"\\n    ]&lt;/set&gt;\\n)\\nlet myStr: string = myArray[0];\\nclass Animal {\\n    name: string;\\n}\\nclass Dog extends Animal {\\n    breed: string;\\n}\\ninterface NotOkay {\\n    *** :index *** :index }\\ninterface NumberDictionary {\\n    *** :index length: number;\\n    name: string;\\n}\\ninterface ReadonlyStringArray {\\n    *** :index }\\nlet myArray: ReadonlyStringArray = [\\n    \\\"Alice\\\", \\n    \\\"Bob\\\"\\n];\\n (\\n    &lt;set&gt;\\n    myArray[2] = \\\"Mallory\\\"\\n    &lt;/set&gt;\\n)\\n"
                },
                {
                    "title": "Class Types",
                    "ittfWrapped": "module \\n    :interface ClockInterface\\n        :p currentTime\\n            :ref Date\\n    class Clock\\n        :extends ClockInterface\\n        p currentTime\\n            :ref Date\\n        ctor \\n            param h\\n                :number \\n            param m\\n                :number \\n    :interface ClockInterface\\n        :p currentTime\\n            :ref Date\\n        :m setTime\\n            param d\\n                :ref Date\\n    class Clock\\n        :extends ClockInterface\\n        p currentTime\\n            :ref Date\\n        m setTime\\n            param d\\n                :ref Date\\n            set this.currentTime = d\\n        ctor \\n            param h\\n                :number \\n            param m\\n                :number ",
                    "generated": "\\ninterface ClockInterface {\\n    currentTime: Date;\\n}\\nclass Clock implements ClockInterface {\\n    constructor(h: number, m: number) {}\\n    currentTime: Date;\\n}\\ninterface ClockInterface {\\n    currentTime: Date;\\n    setTime(d: Date);\\n}\\nclass Clock implements ClockInterface {\\n    constructor(h: number, m: number) {}\\n    currentTime: Date;\\n    setTime(d: Date) {\\n         (\\n            &lt;set&gt;\\n            this.currentTime = d\\n            &lt;/set&gt;\\n        )\\n    }\\n}\\n"
                },
                {
                    "title": "static and instance sides of classes",
                    "ittfWrapped": "module \\n    :interface ClockConstructor\\n        :new \\n            param hour\\n                :number \\n            param minute\\n                :number \\n    class Clock\\n        :extends ClockConstructor\\n        p currentTime\\n            :ref Date\\n        ctor \\n            param h\\n                :number \\n            param m\\n                :number \\n    :interface ClockConstructor\\n        :new \\n            :ref ClockInterface\\n            param hour\\n                :number \\n            param minute\\n                :number \\n    :interface ClockInterface\\n        :m tick\\n    function createClock\\n        param ctor\\n            :ref ClockConstructor\\n        param hour\\n            :number \\n        param minute\\n            :number \\n        :return \\n            :ref ClockInterface\\n        return new ctor(hour, minute)\\n    class DigitalClock\\n        :extends ClockInterface\\n        ctor \\n            param h\\n                :number \\n            param m\\n                :number \\n        m tick\\n            _ console.log(\\\"beep beep\\\")\\n    class AnalogClock\\n        :extends ClockInterface\\n        ctor \\n            param h\\n                :number \\n            param m\\n                :number \\n        m tick\\n            _ console.log(\\\"tick tock\\\")\\n    let digital = createClock(DigitalClock, 12, 17)\\n    let analog = createClock(AnalogClock, 7, 32)",
                    "generated": "\\ninterface ClockConstructor {\\n    *** :new ;\\n}\\nclass Clock implements ClockConstructor {\\n    constructor(h: number, m: number) {}\\n    currentTime: Date;\\n}\\ninterface ClockConstructor {\\n    *** :new ;\\n}\\ninterface ClockInterface {\\n    tick();\\n}\\nfunction createClock(ctor: ClockConstructor, hour: number, minute: number):  ClockInterface {\\n    return new ctor(hour, minute);\\n}\\nclass DigitalClock implements ClockInterface {\\n    constructor(h: number, m: number) {}\\n    tick() {\\n        console.log(\\\"beep beep\\\");\\n    }\\n}\\nclass AnalogClock implements ClockInterface {\\n    constructor(h: number, m: number) {}\\n    tick() {\\n        console.log(\\\"tick tock\\\");\\n    }\\n}\\nlet digital = createClock(DigitalClock, 12, 17);\\nlet analog = createClock(AnalogClock, 7, 32);\\n"
                },
                {
                    "title": "Extending Interfaces",
                    "ittfWrapped": "module \\n    :interface Shape\\n        :p color\\n            :string \\n    :interface Square\\n        :extends Shape\\n        :p sideLength\\n            :number \\n    set square.color = \\\"blue\\\"\\n    set square.sideLength = 10\\n    :interface Shape\\n        :p color\\n            :string \\n    :interface PenStroke\\n        :p penWidth\\n            :number \\n    :interface Square\\n        :extends Shape\\n        :extends PenStroke\\n        :p sideLength\\n            :number \\n    set square.color = \\\"blue\\\"\\n    set square.sideLength = 10\\n    set square.penWidth = 5",
                    "generated": "\\ninterface Shape {\\n    color: string;\\n}\\ninterface Square implements Shape {\\n    sideLength: number;\\n}\\n (\\n    &lt;set&gt;\\n    square.color = \\\"blue\\\"\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    square.sideLength = 10\\n    &lt;/set&gt;\\n)\\ninterface Shape {\\n    color: string;\\n}\\ninterface PenStroke {\\n    penWidth: number;\\n}\\ninterface Square implements Shape, PenStroke {\\n    sideLength: number;\\n}\\n (\\n    &lt;set&gt;\\n    square.color = \\\"blue\\\"\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    square.sideLength = 10\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    square.penWidth = 5\\n    &lt;/set&gt;\\n)\\n"
                },
                {
                    "title": "Hybrid Types",
                    "ittfWrapped": "module \\n    :interface Counter\\n        :call \\n            :string \\n            param start\\n                :number \\n        :p interval\\n            :number \\n        :m reset\\n            :void \\n    function getCounter\\n        :return \\n            :ref Counter\\n        set counter.interval = 123\\n        set counter.reset =\\n            function \\n        return counter\\n    let c = getCounter()\\n    _ c(10)\\n    _ c.reset\\n    set c.interval = 5",
                    "generated": "\\ninterface Counter {\\n    (start: number): string\\n    interval: number;\\n    reset(): void;\\n}\\nfunction getCounter():  Counter {\\n     (\\n        &lt;set&gt;\\n        counter.interval = 123\\n        &lt;/set&gt;\\n    )\\n     (\\n        &lt;set&gt;\\n        counter.reset =\\n        function() {\\n        }&lt;/set&gt;\\n    )\\n    return counter;\\n}\\nlet c = getCounter();\\nc(10);\\nc.reset();\\n (\\n    &lt;set&gt;\\n    c.interval = 5\\n    &lt;/set&gt;\\n)\\n"
                },
                {
                    "title": "Interfaces Extending Classes",
                    "ittfWrapped": "module \\n    class Control\\n        p state\\n            :private \\n            :any \\n    :interface SelectableControl\\n        :extends Control\\n        :m select\\n            :void \\n    class Button\\n        super Control\\n        :extends SelectableControl\\n        m select\\n    class TextBox\\n        super Control\\n        m select\\n    class Image\\n        :extends SelectableControl\\n        m select\\n    class Location",
                    "generated": "\\nclass Control {\\n    state: any;\\n}\\ninterface SelectableControl implements Control {\\n    select(): void;\\n}\\nclass Button implements SelectableControl extends Control {\\n    select() {\\n    }\\n}\\nclass TextBox extends Control {\\n    select() {\\n    }\\n}\\nclass Image implements SelectableControl {\\n    select() {\\n    }\\n}\\nclass Location {\\n}\\n"
                }
            ]
        },
        {
            "name": "generics",
            "tag": "",
            "ast": "",
            "category": "",
            "items": [
                {
                    "title": "Introduction",
                    "ittfWrapped": "module \\n    function identity\\n        param arg\\n            :any \\n        :return \\n            :any \\n        return arg\\n    function identity\\n        :< T\\n        param arg\\n            :ref T\\n        :return \\n            :ref T\\n        return arg",
                    "generated": "\\nfunction identity(arg: any):  any {\\n    return arg;\\n}\\nfunction identity&lt;T&gt;(arg: T):  T {\\n    return arg;\\n}\\n"
                },
                {
                    "title": "Array argument",
                    "ittfWrapped": "module \\n    function loggingIdentity\\n        :< T\\n        param arg\\n            :[ \\n                :ref T\\n        :return \\n            :[ \\n                :ref T\\n        _ console.log(arg.length)\\n        return arg\\n    function loggingIdentity\\n        :< T\\n        param arg\\n            :ref Array\\n                :ref T\\n        :return \\n            :ref Array\\n                :ref T\\n        _ console.log(arg.length)\\n        return arg",
                    "generated": "\\nfunction loggingIdentity&lt;T&gt;(arg: T[]):  T[] {\\n    console.log(arg.length);\\n    return arg;\\n}\\nfunction loggingIdentity&lt;T&gt;(arg: &lt;Array&gt;T):  &lt;Array&gt;T {\\n    console.log(arg.length);\\n    return arg;\\n}\\n"
                },
                {
                    "title": "Generic Types",
                    "ittfWrapped": "module \\n    function identity\\n        :< T\\n        param arg\\n            :ref T\\n        :return \\n            :ref T\\n        return arg\\n    let myIdentity\\n        :=> \\n            :ref T\\n            param arg\\n                :ref T\\n        := identity\\n    function identity\\n        :< T\\n        param arg\\n            :ref T\\n        :return \\n            :ref T\\n        return arg\\n    let myIdentity\\n        :=> \\n            :ref U\\n            param arg\\n                :ref U\\n        := identity\\n    function identity\\n        :< T\\n        param arg\\n            :ref T\\n        :return \\n            :ref T\\n        return arg",
                    "generated": "\\nfunction identity&lt;T&gt;(arg: T):  T {\\n    return arg;\\n}\\nlet myIdentity: (arg: T = identity;\\n)function identity&lt;T&gt;(arg: T):  T {\\n    return arg;\\n}\\nlet myIdentity: (arg: U = identity;\\n)function identity&lt;T&gt;(arg: T):  T {\\n    return arg;\\n}\\n"
                },
                {
                    "title": "Call signature",
                    "ittfWrapped": "module \\n    let myIdentity\\n        :{ \\n            :call \\n                :< T\\n                :ref T\\n                param arg\\n                    :ref T\\n        := identity\\n    function identity\\n        :< T\\n        param arg\\n            :ref T\\n        :return \\n            :ref T\\n        return arg\\n    let myIdentity\\n        :ref GenericIdentityFn\\n        := identity\\n    :interface GenericIdentityFn\\n        :< T\\n        :call \\n            :ref T\\n            param arg\\n                :ref T\\n    function identity\\n        :< T\\n        param arg\\n            :ref T\\n        :return \\n            :ref T\\n        return arg\\n    let GenericIdentityFn\\n        :number \\n        := identity",
                    "generated": "\\nlet myIdentity: {(arg: T = identity;\\n    ): T\\n    function identity&lt;T&gt;(arg: T}):  T {\\n    return arg;\\n}\\nlet myIdentity: GenericIdentityFn = identity;\\ninterface GenericIdentityFn&lt;T&gt; {\\n    (arg: T): T\\n}\\nfunction identity&lt;T&gt;(arg: T):  T {\\n    return arg;\\n}\\nlet GenericIdentityFn: number = identity;\\n"
                },
                {
                    "title": "Generic Classes",
                    "ittfWrapped": "module \\n    class GenericNumber\\n        :< T\\n        p zeroValue\\n            :ref T\\n        p add\\n            :=> \\n                :ref T\\n                param x\\n                    :ref T\\n                param y\\n                    :ref T\\n    let myGenericNumber = new GenericNumber()\\n    set myGenericNumber.zeroValue = 0\\n    set myGenericNumber.add =\\n        function \\n            param x\\n            param y\\n            return x + y",
                    "generated": "\\nclass GenericNumber&lt;T&gt; {\\n    zeroValue: T;\\n    add: (x: T;\\n    , y: T}\\n)let myGenericNumber = new GenericNumber();\\n (\\n    &lt;set&gt;\\n    myGenericNumber.zeroValue = 0\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    myGenericNumber.add =\\n    function(x, y) {\\n        return x + y;\\n    }&lt;/set&gt;\\n)\\n"
                },
                {
                    "title": "Generic Constraints",
                    "ittfWrapped": "module \\n    function loggingIdentity\\n        :< T\\n        param arg\\n            :ref T\\n        :return \\n            :ref T\\n        _ console.log(arg.length)\\n        return arg\\n    :interface Lengthwise\\n        :p length\\n            :number \\n    function loggingIdentity\\n        :< T\\n            :ref Lengthwise\\n        param arg\\n            :ref T\\n        :return \\n            :ref T\\n        _ console.log(arg.length)\\n        return arg",
                    "generated": "\\nfunction loggingIdentity&lt;T&gt;(arg: T):  T {\\n    console.log(arg.length);\\n    return arg;\\n}\\ninterface Lengthwise {\\n    length: number;\\n}\\nfunction loggingIdentity&lt;T extends Lengthwise&gt;(arg: T):  T {\\n    console.log(arg.length);\\n    return arg;\\n}\\n"
                },
                {
                    "title": "Type Parameters in Generic Constraints",
                    "ittfWrapped": "module \\n    function getProperty\\n        :< T\\n        :< K\\n            :keyof \\n                :ref T\\n        param obj\\n            :ref T\\n        param key\\n            :ref K\\n        return obj[key]\\n    let x\\n        { \\n            @ a 1\\n            @ b 2\\n            @ c 3\\n            @ d 4\\n    _ getProperty(x, \\\"a\\\")\\n    _ getProperty(x, \\\"m\\\")",
                    "generated": "\\nfunction getProperty&lt;T, K keyof T&gt;(obj: T, key: K) {\\n    return obj[key];\\n}\\nlet x = {\\n    a: 1, \\n    b: 2, \\n    c: 3, \\n    d: 4\\n};\\ngetProperty(x, \\\"a\\\");\\ngetProperty(x, \\\"m\\\");\\n"
                },
                {
                    "title": "Class Types in Generics",
                    "ittfWrapped": "module \\n    function create\\n        :< T\\n        param c\\n            :{ \\n                :new \\n                    :ref T\\n        :return \\n            :ref T\\n        return new c()",
                    "generated": "\\nfunction create&lt;T&gt;(c: {*** :new ;\\n}):  T {\\n    return new c();\\n}\\n"
                },
                {
                    "title": "Advanced example",
                    "ittfWrapped": "module \\n    class BeeKeeper\\n        p hasMask\\n            :boolean \\n    class ZooKeeper\\n        p nametag\\n            :string \\n    class Animal\\n        p numLegs\\n            :number \\n    class Bee\\n        super Animal\\n        p keeper\\n            :ref BeeKeeper\\n    class Lion\\n        super Animal\\n        p keeper\\n            :ref ZooKeeper\\n    function createInstance\\n        :< A\\n            :ref Animal\\n        param c\\n            :ctor \\n                :ref A\\n        :return \\n            :ref A\\n        return new c()\\n    var x = createInstance(Lion).keeper.nametag\\n    var y = createInstance(Bee).keeper.hasMask",
                    "generated": "\\nclass BeeKeeper {\\n    hasMask: boolean;\\n}\\nclass ZooKeeper {\\n    nametag: string;\\n}\\nclass Animal {\\n    numLegs: number;\\n}\\nclass Bee extends Animal {\\n    keeper: BeeKeeper;\\n}\\nclass Lion extends Animal {\\n    keeper: ZooKeeper;\\n}\\nfunction createInstance&lt;A extends Animal&gt;( = *** :ctor ;\\n):  A {\\n    return new c();\\n}\\n (\\n    &lt;var&gt;\\n    x = createInstance(Lion).keeper.nametag\\n    &lt;/var&gt;\\n)\\n (\\n    &lt;var&gt;\\n    y = createInstance(Bee).keeper.hasMask\\n    &lt;/var&gt;\\n)\\n"
                }
            ]
        },
        {
            "name": "advanced",
            "tag": "",
            "ast": "",
            "category": "",
            "items": [
                {
                    "title": "Intersection Types",
                    "ittfWrapped": "module \\n    function extend\\n        :< T\\n        :< U\\n        param first\\n            :ref T\\n        param second\\n            :ref U\\n        :return \\n            :intersect \\n                :ref T\\n                :ref U\\n        let result\\n            :as \\n                :intersect \\n                    :ref T\\n                    :ref U\\n                { {}\\n        for \\n            left \\n                let id\\n            right first\\n            set =\\n                :as \\n                    ( \\n                        :any \\n                        ident first\\n                    .[ id\\n        for \\n            left \\n                let id\\n            right second\\n            if !result.hasOwnProperty(id)\\n                set =\\n                    :as \\n                        ( \\n                            :any \\n                            ident second\\n                        .[ id\\n        return result\\n    class Person\\n        ctor \\n            param name\\n                :string \\n    :interface Loggable\\n        :m log\\n            :void \\n    class ConsoleLogger\\n        :extends Loggable\\n        m log\\n    var jim = extend(new Person(\\\"Jim\\\"), new ConsoleLogger())\\n    var n = jim.name\\n    _ jim.log",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: left, wzElement: undefined, wzName:, row:20, col:13, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0017                     :ref U\\\",\\n    \\\"0018                 { {}\\\",\\n    \\\"0019         for \\\",\\n    \\\"0020             left \\\",\\n    \\\"                 ^ Tag not recognized: left  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0021                 let id\\\",\\n    \\\"0022             right first\\\",\\n    \\\"0023             set =\\\",\\n    \\\"0024                 :as \\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at xfor.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1053:23)\\n    at xfunction.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at xfunction.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:377:29)\\n    at xfunction.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:2871:48)\\n    at xfunction.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:2881:27)\\n    at module.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at module.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:904:29)\\n    at module.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1127:48)\\n    at module.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1137:27)\\\"\\n}"
                },
                {
                    "title": "Union Types",
                    "ittfWrapped": "module \\n    function padLeft\\n        param value\\n            :string \\n        param padding\\n            :any \\n        if typeof padding === \\\"number\\\"\\n            return Array(padding + 1).join(\\\" \\\") + value\\n        if typeof padding === \\\"string\\\"\\n            return padding + value\\n        throw \\n            new Error\\n                `lit \\n                    + Expected string or number, got '\\n                    @ padding\\n                    + '.\\n    _ padLeft(\\\"Hello world\\\", 4)\\n    let indentedString = padLeft(\\\"Hello world\\\", true)\\n    function padLeft\\n        param value\\n            :string \\n        param padding\\n            :union \\n                :string \\n                :number \\n    let indentedString = padLeft(\\\"Hello world\\\", true)\\n    :interface Bird\\n        :m fly\\n        :m layEggs\\n    :interface Fish\\n        :m swim\\n        :m layEggs\\n    function getSmallPet\\n        :return \\n            :union \\n                :ref Fish\\n                :ref Bird\\n    let pet = getSmallPet()\\n    _ pet.layEggs\\n    _ pet.swim",
                    "generated": "\\nfunction padLeft(value: string, padding: any) {\\n    if (typeof padding === \\\"number\\\") {\\n        return Array(padding + 1).join(\\\" \\\") + value;\\n    }\\n    if (typeof padding === \\\"string\\\") {\\n        return padding + value;\\n    }\\n    throw new Error(`Expected string or number, got '${padding}'.`);\\n}\\npadLeft(\\\"Hello world\\\", 4);\\nlet indentedString = padLeft(\\\"Hello world\\\", true);\\nfunction padLeft(value: string, padding: string | number) {\\n}\\nlet indentedString = padLeft(\\\"Hello world\\\", true);\\ninterface Bird {\\n    fly();\\n    layEggs();\\n}\\ninterface Fish {\\n    swim();\\n    layEggs();\\n}\\nfunction getSmallPet():  Fish | Bird {\\n}\\nlet pet = getSmallPet();\\npet.layEggs();\\npet.swim();\\n"
                },
                {
                    "title": "Type Guards and Differentiating Types",
                    "ittfWrapped": "module \\n    let pet = getSmallPet()\\n    if pet.swim\\n        _ pet.swim\\n    else \\n        if pet.fly\\n            _ pet.fly\\n    let pet = getSmallPet()\\n    if \\n        test \\n            :as \\n                ( \\n                    :ref Fish\\n                    ident pet\\n                . swim\\n        _ \\n            ( \\n                :ref Fish\\n                ident pet\\n            ._ swim\\n    else \\n        _ \\n            ( \\n                :ref Bird\\n                ident pet\\n            ._ fly",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: ident, wzElement: undefined, wzName:, row:14, col:21, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0011             :as \\\",\\n    \\\"0012                 ( \\\",\\n    \\\"0013                     :ref Fish\\\",\\n    \\\"0014                     ident pet\\\",\\n    \\\"                         ^ Tag not recognized: ident  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0015                 . swim\\\",\\n    \\\"0016         _ \\\",\\n    \\\"0017             ( \\\",\\n    \\\"0018                 :ref Fish\\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at callOnValue.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1053:23)\\n    at typeAs.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at typeAs.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:187:29)\\n    at typeAs.typeSimple.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7153:48)\\n    at typeAs.typeSimple.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7163:27)\\n    at test.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at test.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:359:29)\\n    at test.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1051:27)\\n    at xif.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\\"\\n}"
                },
                {
                    "title": "User - Defined Type Guards",
                    "ittfWrapped": "module \\n    function isFish\\n        param pet\\n            :union \\n                :ref Fish\\n                :ref Bird\\n        :return \\n            :predicate pet\\n                :ref Fish\\n        return \\n            !== \\n                :as \\n                    ( \\n                        :ref Fish\\n                        ident pet\\n                    . swim\\n                + undefined\\n    if isFish(pet)\\n        _ pet.swim\\n    else \\n        _ pet.fly\\n    function isNumber\\n        param x\\n            :any \\n        :return \\n            :predicate x\\n                :number \\n        return typeof x === \\\"number\\\"\\n    function isString\\n        param x\\n            :any \\n        :return \\n            :predicate x\\n                :string \\n        return typeof x === \\\"string\\\"\\n    function padLeft\\n        param value\\n            :string \\n        param padding\\n            :union \\n                :string \\n                :number \\n        if isNumber(padding)\\n            return Array(padding + 1).join(\\\" \\\") + value\\n        if isString(padding)\\n            return padding + value\\n        throw \\n            new Error\\n                `lit \\n                    + Expected string or number, got '\\n                    @ padding\\n                    + '.\\n    function padLeft\\n        param value\\n            :string \\n        param padding\\n            :union \\n                :string \\n                :number \\n        if typeof padding === \\\"number\\\"\\n            return Array(padding + 1).join(\\\" \\\") + value\\n        if typeof padding === \\\"string\\\"\\n            return padding + value\\n        throw \\n            new Error\\n                `lit \\n                    + Expected string or number, got '\\n                    @ padding\\n                    + '.",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: ident, wzElement: undefined, wzName:, row:15, col:25, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0012                 :as \\\",\\n    \\\"0013                     ( \\\",\\n    \\\"0014                         :ref Fish\\\",\\n    \\\"0015                         ident pet\\\",\\n    \\\"                             ^ Tag not recognized: ident  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0016                     . swim\\\",\\n    \\\"0017                 + undefined\\\",\\n    \\\"0018     if isFish(pet)\\\",\\n    \\\"0019         _ pet.swim\\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at callOnValue.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1053:23)\\n    at typeAs.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at typeAs.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:187:29)\\n    at typeAs.typeSimple.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7153:48)\\n    at typeAs.typeSimple.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7163:27)\\n    at op_noteq_strict.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at op_noteq_strict.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:359:29)\\n    at op_noteq_strict.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1051:27)\\n    at xreturn.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\\"\\n}"
                },
                {
                    "title": "Instanceof type guards",
                    "ittfWrapped": "module \\n    :interface Padder\\n        :m getPaddingString\\n            :string \\n    class SpaceRepeatingPadder\\n        :extends Padder\\n        ctor \\n            param numSpaces\\n                :number \\n        m getPaddingString\\n            return Array(this.numSpaces + 1).join(\\\" \\\")\\n    class StringPadder\\n        :extends Padder\\n        ctor \\n            param value\\n                :string \\n        m getPaddingString\\n            return this.value\\n    function getRandomPadder\\n        return \\n            iif Math.random() < 0.5\\n                then new SpaceRepeatingPadder(4)\\n                else new StringPadder(\\\"  \\\")\\n    let padder\\n        :ref Padder\\n        _ getRandomPadder\\n    if padder instanceof SpaceRepeatingPadder\\n        ident padder\\n        # type narrowed to 'SpaceRepeatingPadder'\\n    if padder instanceof StringPadder\\n        ident padder",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: ident, wzElement: undefined, wzName:, row:28, col:9, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0025         :ref Padder\\\",\\n    \\\"0026         _ getRandomPadder\\\",\\n    \\\"0027     if padder instanceof SpaceRepeatingPadder\\\",\\n    \\\"0028         ident padder\\\",\\n    \\\"             ^ Tag not recognized: ident  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0029         # type narrowed to 'SpaceRepeatingPadder'\\\",\\n    \\\"0030     if padder instanceof StringPadder\\\",\\n    \\\"0031         ident padder\\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at xif.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1053:23)\\n    at module.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at module.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:321:29)\\n    at module.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1127:48)\\n    at module.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1137:27)\\n    at loadModelFromMTree (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-factory.g.js:66:29)\\n    at C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-factory.g.js:176:21\\n    at C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-mtree\\\\lib\\\\loader\\\\index.js:82:25\\n    at finalize (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-mtree\\\\lib\\\\loader\\\\evaluator.js:106:5)\\\"\\n}"
                },
                {
                    "title": "Nullable types",
                    "ittfWrapped": "module \\n    let s = \\\"foo\\\"\\n    set s = null\\n    let sn\\n        :union \\n            :string \\n            :null \\n        := \\\"bar\\\"\\n    set sn = null\\n    set sn = undefined\\n    function f\\n        param x\\n            :number \\n        param \\n            :number \\n            :optional \\n        return x + y || 0\\n    _ f(1, 2)\\n    _ f(1)\\n    _ f(1, undefined)\\n    _ f(1, null)\\n    class C\\n        p a\\n            :number \\n        p b\\n            :number \\n    let c = new C()\\n    set c.a = 12\\n    set c.a = undefined\\n    set c.b = 13\\n    set c.b = undefined\\n    set c.b = null\\n    function f\\n        param sn\\n            :union \\n                :string \\n                :null \\n        :return \\n            :string \\n        if sn == null\\n            return \\\"default\\\"\\n        else \\n            return sn\\n    function f\\n        param sn\\n            :union \\n                :string \\n                :null \\n        :return \\n            :string \\n        return sn || \\\"default\\\"\\n    function broken\\n        param name\\n            :union \\n                :string \\n                :null \\n        :return \\n            :string \\n        function postfix\\n            param epithet\\n                :string \\n            return name.charAt(0) + '.  the ' + epithet\\n        set name = name || \\\"Bob\\\"\\n        return postfix(\\\"great\\\")\\n    function fixed\\n        param name\\n            :union \\n                :string \\n                :null \\n        :return \\n            :string \\n        function postfix\\n            param epithet\\n                :string \\n            return \\n                op+ \\n                    op+ \\n                        _ \\n                            ._ charAt\\n                                @ 0\\n                        + '.  the '\\n                    + epithet\\n        set name = name || \\\"Bob\\\"\\n        return postfix(\\\"great\\\")",
                    "generated": "\\nlet s = \\\"foo\\\";\\n (\\n    &lt;set&gt;\\n    s = null\\n    &lt;/set&gt;\\n)\\nlet sn: string | null = \\\"bar\\\";\\n (\\n    &lt;set&gt;\\n    sn = null\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    sn = undefined\\n    &lt;/set&gt;\\n)\\nfunction f(x: number, : number) {\\n    return x + y || 0;\\n}\\nf(1, 2);\\nf(1);\\nf(1, undefined);\\nf(1, null);\\nclass C {\\n    a: number;\\n    b: number;\\n}\\nlet c = new C();\\n (\\n    &lt;set&gt;\\n    c.a = 12\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    c.a = undefined\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    c.b = 13\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    c.b = undefined\\n    &lt;/set&gt;\\n)\\n (\\n    &lt;set&gt;\\n    c.b = null\\n    &lt;/set&gt;\\n)\\nfunction f(sn: string | null):  string {\\n    if (sn == null) {\\n        return \\\"default\\\";\\n    }\\n    else {\\n        return sn;\\n    }\\n}\\nfunction f(sn: string | null):  string {\\n    return sn || \\\"default\\\";\\n}\\nfunction broken(name: string | null):  string {\\n    function postfix(epithet: string) {\\n        return name.charAt(0) + '.  the ' + epithet;\\n    }\\n     (\\n        &lt;set&gt;\\n        name = name || \\\"Bob\\\"\\n        &lt;/set&gt;\\n    )\\n    return postfix(\\\"great\\\");\\n}\\nfunction fixed(name: string | null):  string {\\n    function postfix(epithet: string) {\\n        return ((().charAt(0)\\n            ) + '.  the ') + epithet;\\n    }\\n     (\\n        &lt;set&gt;\\n        name = name || \\\"Bob\\\"\\n        &lt;/set&gt;\\n    )\\n    return postfix(\\\"great\\\");\\n}\\n"
                },
                {
                    "title": "Type Aliases",
                    "ittfWrapped": "module \\n    :type Name\\n        :string \\n    :type NameResolver\\n        :=> \\n            :string \\n    :type NameOrResolver\\n        :union \\n            :ref Name\\n            :ref NameResolver\\n    function getName\\n        param n\\n            :ref NameOrResolver\\n        :return \\n            :ref Name\\n        if typeof n === \\\"string\\\"\\n            return n\\n        else \\n            return n()\\n    :type Container\\n        :< T\\n        :{ \\n            :p value\\n                :ref T\\n    :type Tree\\n        :< T\\n        :{ \\n            :p value\\n                :ref T\\n            :p left\\n                :ref Tree\\n                    :ref T\\n            :p right\\n                :ref Tree\\n                    :ref T\\n    :type LinkedList\\n        :< T\\n        :intersect \\n            :ref T\\n            :{ \\n                :p next\\n                    :ref LinkedList\\n                        :ref T\\n    :interface Person\\n        :p name\\n            :string \\n    var people\\n        :ref LinkedList\\n            :ref Person\\n    var s = people.name\\n    var s = people.next.name\\n    var s = people.next.next.name\\n    var s = people.next.next.next.name\\n    :type Yikes\\n        :ref Array\\n            :ref Yikes",
                    "generated": "\\ntype Name = string;\\ntype NameResolver = ();\\ntype NameOrResolver = Name | NameResolver;\\nfunction getName(n: NameOrResolver):  Name {\\n    if (typeof n === \\\"string\\\") {\\n        return n;\\n    }\\n    else {\\n        return n();\\n    }\\n}\\ntype Container&lt;T&gt; = {value: T;\\n};\\ntype Tree&lt;T&gt; = {value: T;\\n    left: &lt;Tree&gt;T;\\n    right: &lt;Tree&gt;T;\\n};\\ntype LinkedList&lt;T&gt; = T & {next: &lt;LinkedList&gt;T;\\n    ;\\n}interface Person {\\n    name: string;\\n}\\n (\\n    &lt;var&gt;\\n    people\\n    &lt;LinkedList&gt;Person&lt;/var&gt;\\n)\\n (\\n    &lt;var&gt;\\n    s = people.name\\n    &lt;/var&gt;\\n)\\n (\\n    &lt;var&gt;\\n    s = people.next.name\\n    &lt;/var&gt;\\n)\\n (\\n    &lt;var&gt;\\n    s = people.next.next.name\\n    &lt;/var&gt;\\n)\\n (\\n    &lt;var&gt;\\n    s = people.next.next.next.name\\n    &lt;/var&gt;\\n)\\ntype Yikes = &lt;Array&gt;Yikes;\\n"
                },
                {
                    "title": "Interfaces vs.Type Aliases",
                    "ittfWrapped": "module \\n    :type Alias\\n        :{ \\n            :p num\\n                :number \\n    :interface Interface\\n        :p num\\n            :number \\n    :function aliased\\n        param arg\\n            :ref Alias\\n        :return \\n            :ref Alias\\n    :function interfaced\\n        param arg\\n            :ref Interface\\n        :return \\n            :ref Interface",
                    "generated": "\\ntype Alias = {num: number;\\n};\\ninterface Interface {\\n    num: number;\\n}\\nfunction aliased(arg: Alias):  Alias;\\nfunction interfaced(arg: Interface):  Interface;\\n"
                },
                {
                    "title": "String Literal Types",
                    "ittfWrapped": "module \\n    :type Easing\\n        :union \\n            :literal \\\"ease-in\\\"\\n            :literal \\\"ease-out\\\"\\n            :literal \\\"ease-in-out\\\"\\n    class UIElement\\n        m animate\\n            param dx\\n                :number \\n            param dy\\n                :number \\n            param easing\\n                :ref Easing\\n            if easing === \\\"ease-in\\\"\\n            else \\n                if easing === \\\"ease-out\\\"\\n                else \\n                    if easing === \\\"ease-in-out\\\"\\n                    else \\n    let button = new UIElement()\\n    _ button.animate(0, 0, \\\"ease-in\\\")\\n    _ button.animate(0, 0, \\\"uneasy\\\")\\n    :function createElement\\n        param tagName\\n            :literal \\\"img\\\"\\n        :return \\n            :ref HTMLImageElement\\n    :function createElement\\n        param tagName\\n            :literal \\\"input\\\"\\n        :return \\n            :ref HTMLInputElement\\n    function createElement\\n        param tagName\\n            :string \\n        :return \\n            :ref Element",
                    "generated": "\\ntype Easing = \\\"ease-in\\\" | \\\"ease-out\\\" | \\\"ease-in-out\\\";\\nclass UIElement {\\n    animate(dx: number, dy: number, easing: Easing) {\\n        if (easing === \\\"ease-in\\\") {\\n        }\\n        else {\\n            if (easing === \\\"ease-out\\\") {\\n            }\\n            else {\\n                if (easing === \\\"ease-in-out\\\") {\\n                }\\n                else {\\n                }\\n            }\\n        }\\n    }\\n}\\nlet button = new UIElement();\\nbutton.animate(0, 0, \\\"ease-in\\\");\\nbutton.animate(0, 0, \\\"uneasy\\\");\\nfunction createElement(tagName: \\\"img\\\"):  HTMLImageElement;\\nfunction createElement(tagName: \\\"input\\\"):  HTMLInputElement;\\nfunction createElement(tagName: string):  Element {\\n}\\n"
                },
                {
                    "title": "Numeric Literal Types",
                    "ittfWrapped": "module \\n    function rollDie\\n        :return \\n            :union \\n                :literal 1\\n                :literal 2\\n                :literal 3\\n                :literal 4\\n                :literal 5\\n                :literal 6\\n    function foo\\n        param x\\n            :number \\n        if x !== 1 || x !== 2",
                    "generated": "\\nfunction rollDie():  1 | 2 | 3 | 4 | 5 | 6 {\\n}\\nfunction foo(x: number) {\\n    if (x !== 1 || x !== 2) {\\n    }\\n}\\n"
                },
                {
                    "title": "Enum Member Types",
                    "ittfWrapped": "module \\n    :interface Square\\n        :p kind\\n            :literal \\\"square\\\"\\n        :p size\\n            :number \\n    :interface Rectangle\\n        :p kind\\n            :literal \\\"rectangle\\\"\\n        :p width\\n            :number \\n        :p height\\n            :number \\n    :interface Circle\\n        :p kind\\n            :literal \\\"circle\\\"\\n        :p radius\\n            :number \\n    :type Shape\\n        :union \\n            :ref Square\\n            :ref Rectangle\\n            :ref Circle\\n    function area\\n        param s\\n            :ref Shape\\n        switch s.kind\\n            case \\\"square\\\"\\n                return s.size * s.size\\n            case \\\"rectangle\\\"\\n                return s.height * s.width\\n            case \\\"circle\\\"\\n                return Math.PI * s.radius ** 2",
                    "generated": "\\ninterface Square {\\n    kind: \\\"square\\\";\\n    size: number;\\n}\\ninterface Rectangle {\\n    kind: \\\"rectangle\\\";\\n    width: number;\\n    height: number;\\n}\\ninterface Circle {\\n    kind: \\\"circle\\\";\\n    radius: number;\\n}\\ntype Shape = Square | Rectangle | Circle;\\nfunction area(s: Shape) {\\n     (\\n        &lt;switch&gt;\\n        s.kind\\n        case \\\"square\\\": {\\n            return s.size * s.size;\\n        }\\n        case \\\"rectangle\\\": {\\n            return s.height * s.width;\\n        }\\n        case \\\"circle\\\": {\\n            return Math.PI * s.radius ** 2;\\n        }\\n        &lt;/switch&gt;\\n    )\\n}\\n"
                },
                {
                    "title": "Exhaustiveness checking",
                    "ittfWrapped": "module \\n    :type Shape\\n        :union \\n            :ref Square\\n            :ref Rectangle\\n            :ref Circle\\n            :ref Triangle\\n    function area\\n        param s\\n            :ref Shape\\n        switch s.kind\\n            case \\\"square\\\"\\n                return s.size * s.size\\n            case \\\"rectangle\\\"\\n                return s.height * s.width\\n            case \\\"circle\\\"\\n                return Math.PI * s.radius ** 2\\n    function area\\n        param s\\n            :ref Shape\\n        :return \\n            :number \\n        switch s.kind\\n            case \\\"square\\\"\\n                return s.size * s.size\\n            case \\\"rectangle\\\"\\n                return s.height * s.width\\n            case \\\"circle\\\"\\n                return Math.PI * s.radius ** 2\\n    function assertNever\\n        param x\\n            :never \\n        :return \\n            :never \\n        throw new Error(\\\"Unexpected object: \\\" + x)\\n    function area\\n        param s\\n            :ref Shape\\n        switch s.kind\\n            case \\\"square\\\"\\n                return s.size * s.size\\n            case \\\"rectangle\\\"\\n                return s.height * s.width\\n            case \\\"circle\\\"\\n                return Math.PI * s.radius ** 2\\n            default \\n                return assertNever(s)",
                    "generated": "\\ntype Shape = Square | Rectangle | Circle | Triangle;\\nfunction area(s: Shape) {\\n     (\\n        &lt;switch&gt;\\n        s.kind\\n        case \\\"square\\\": {\\n            return s.size * s.size;\\n        }\\n        case \\\"rectangle\\\": {\\n            return s.height * s.width;\\n        }\\n        case \\\"circle\\\": {\\n            return Math.PI * s.radius ** 2;\\n        }\\n        &lt;/switch&gt;\\n    )\\n}\\nfunction area(s: Shape):  number {\\n     (\\n        &lt;switch&gt;\\n        s.kind\\n        case \\\"square\\\": {\\n            return s.size * s.size;\\n        }\\n        case \\\"rectangle\\\": {\\n            return s.height * s.width;\\n        }\\n        case \\\"circle\\\": {\\n            return Math.PI * s.radius ** 2;\\n        }\\n        &lt;/switch&gt;\\n    )\\n}\\nfunction assertNever( = never):  never {\\n    throw new Error(\\\"Unexpected object: \\\" + x);\\n}\\nfunction area(s: Shape) {\\n     (\\n        &lt;switch&gt;\\n        s.kind\\n        case \\\"square\\\": {\\n            return s.size * s.size;\\n        }\\n        case \\\"rectangle\\\": {\\n            return s.height * s.width;\\n        }\\n        case \\\"circle\\\": {\\n            return Math.PI * s.radius ** 2;\\n        }\\n        default: {\\n            return assertNever(s);\\n        }\\n        &lt;/switch&gt;\\n    )\\n}\\n"
                },
                {
                    "title": "Polymorphic this types",
                    "ittfWrapped": "module \\n    class BasicCalculator\\n        ctor \\n            :public \\n            param value\\n                :number \\n                := 0\\n        m currentValue\\n            :public \\n            return this.value\\n        m add\\n            :public \\n            param operand\\n                :number \\n            set this.value += operand\\n            return this\\n        m multiply\\n            :public \\n            param operand\\n                :number \\n            set this.value *= operand\\n            return this\\n    let v = new BasicCalculator(2).multiply(5).add(1).currentValue()\\n    class ScientificCalculator\\n        super BasicCalculator\\n        ctor \\n            :public \\n            param value = 0\\n            _ super(value)\\n        m sin\\n            :public \\n            set this.value = Math.sin(this.value)\\n            return this\\n    let v = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue()",
                    "generated": "\\nclass BasicCalculator {\\n    constructor( = 0) {}\\n    currentValue() {\\n        return this.value;\\n    }\\n    add(operand: number) {\\n         (\\n            &lt;set&gt;\\n            this.value += operand\\n            &lt;/set&gt;\\n        )\\n        return this;\\n    }\\n    multiply(operand: number) {\\n         (\\n            &lt;set&gt;\\n            this.value *= operand\\n            &lt;/set&gt;\\n        )\\n        return this;\\n    }\\n}\\nlet v = new BasicCalculator(2).multiply(5).add(1).currentValue();\\nclass ScientificCalculator extends BasicCalculator {\\n    constructor(value = 0) {super(value);\\n    }\\n    sin() {\\n         (\\n            &lt;set&gt;\\n            this.value = Math.sin(this.value)\\n            &lt;/set&gt;\\n        )\\n        return this;\\n    }\\n}\\nlet v = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue();\\n"
                },
                {
                    "title": "Index types",
                    "ittfWrapped": "module \\n    function pluck\\n        param o\\n        param names\\n        return \\n            _ names.map\\n                => \\n                    param n\\n                    + o[n]\\n    function pluck\\n        :< T\\n        :< K\\n            :keyof \\n                :ref T\\n        param o\\n            :ref T\\n        param names\\n            :[ \\n                :ref K\\n        :return \\n            :[ \\n                :[] \\n                    :ref T\\n                    :ref K\\n        return \\n            _ names.map\\n                => \\n                    param n\\n                    + o[n]\\n    :interface Person\\n        :p name\\n            :string \\n        :p age\\n            :number \\n    let person\\n        :ref Person\\n        { \\n            @ name 'Jarid'\\n            @ age 35\\n    let strings\\n        :[ \\n            :string \\n        _ pluck\\n            @ person\\n            [ \\n                @ 'name'\\n    let personProps\\n        :keyof \\n            :ref Person\\n    _ pluck\\n        @ person\\n        [ \\n            @ 'age'\\n            @ 'unknown'\\n    function getProperty\\n        :< T\\n        :< K\\n            :keyof \\n                :ref T\\n        param o\\n            :ref T\\n        param name\\n            :ref K\\n        :return \\n            :[] \\n                :ref T\\n                :ref K\\n        return o[name]\\n    let name\\n        :string \\n        _ getProperty(person, 'name')\\n    let age\\n        :number \\n        _ getProperty(person, 'age')\\n    let unknown = getProperty(person, 'unknown')\\n    :interface Map\\n        :< T\\n        :index \\n            :ref T\\n            param key\\n                :string \\n    let keys\\n        :keyof \\n            :ref Map\\n                :number \\n    let value\\n        :[] \\n            :ref Map\\n                :number \\n            :literal 'foo'",
                    "generated": "\\nfunction pluck(o, names) {\\n    return names.map((n) =&gt;\\n            o[n]);\\n}\\nfunction pluck&lt;T, K keyof T&gt;(o: T, names: K[]):  T[K][] {\\n    return names.map((n) =&gt;\\n            o[n]);\\n}\\ninterface Person {\\n    name: string;\\n    age: number;\\n}\\nlet person: Person = {\\n    name: 'Jarid', \\n    age: 35\\n};\\nlet strings: string[] = pluck(person, [\\n    'name'\\n]);\\nlet personProps =  keyof Person;\\npluck(person, [\\n    'age', \\n    'unknown'\\n]);\\nfunction getProperty&lt;T, K keyof T&gt;(o: T, name: K):  T[K] {\\n    return o[name];\\n}\\nlet name: string = getProperty(person, 'name');\\nlet age: number = getProperty(person, 'age');\\nlet unknown = getProperty(person, 'unknown');\\ninterface Map&lt;T&gt; {\\n    *** :index }\\nlet keys =  keyof &lt;Map&gt;number;\\nlet value = &lt;Map&gt;number['foo'];\\n"
                },
                {
                    "title": "Mapped types",
                    "ittfWrapped": "module \\n    :interface PersonPartial\\n        :p name\\n            :optional \\n            :string \\n        :p age\\n            :optional \\n            :number \\n    :interface PersonReadonly\\n        :p name\\n            :string \\n        :p age\\n            :number \\n    :type Readonly\\n        :< T\\n        :mapped \\n            :< P\\n                :keyof \\n                    :ref T\\n            :[] \\n                :ref T\\n                :ref P\\n    :type Partial\\n        :< T\\n        :mapped \\n            :optional \\n            :< P\\n                :keyof \\n                    :ref T\\n            :[] \\n                :ref T\\n                :ref P\\n    :type PersonPartial\\n        :ref Partial\\n            :ref Person\\n    :type ReadonlyPerson\\n        :ref Readonly\\n            :ref Person\\n    :type Keys\\n        :union \\n            :literal 'option1'\\n            :literal 'option2'\\n    :type Flags\\n        :mapped \\n            :< K\\n                :ref Keys\\n            :boolean ",
                    "generated": "\\ninterface PersonPartial {\\n    name?: string;\\n    age?: number;\\n}\\ninterface PersonReadonly {\\n    name: string;\\n    age: number;\\n}\\ntype Readonly&lt;T&gt; = [P in  keyof T] : T[P];\\ntype Partial&lt;T&gt; = [P in  keyof T] : T[P];\\ntype PersonPartial = &lt;Partial&gt;Person;\\ntype ReadonlyPerson = &lt;Readonly&gt;Person;\\ntype Keys = 'option1' | 'option2';\\ntype Flags = [K extends Keys] : boolean;\\n"
                },
                {
                    "title": "Mapped types 2",
                    "ittfWrapped": "module \\n    :type Flags\\n        :{ \\n            :p option1\\n                :boolean \\n            :p option2\\n                :boolean \\n    :type NullablePerson\\n        :mapped \\n            :< P\\n                :keyof \\n                    :ref Person\\n            :union \\n                :[] \\n                    :ref Person\\n                    :ref P\\n                :null \\n    :type PartialPerson\\n        :mapped \\n            :optional \\n            :< P\\n                :keyof \\n                    :ref Person\\n            :[] \\n                :ref Person\\n                :ref P\\n    :type Nullable\\n        :< T\\n        :mapped \\n            :< P\\n                :keyof \\n                    :ref T\\n            :union \\n                :[] \\n                    :ref T\\n                    :ref P\\n                :null \\n    :type Partial\\n        :< T\\n        :mapped \\n            :optional \\n            :< P\\n                :keyof \\n                    :ref T\\n            :[] \\n                :ref T\\n                :ref P\\n    :type Proxy\\n        :< T\\n        :{ \\n            :m get\\n                :ref T\\n            :m set\\n                :void \\n                param value\\n                    :ref T\\n    :type Proxify\\n        :< T\\n        :mapped \\n            :< P\\n                :keyof \\n                    :ref T\\n            :ref Proxy\\n                :[] \\n                    :ref T\\n                    :ref P\\n    function proxify\\n        :< T\\n        param o\\n            :ref T\\n        :return \\n            :ref Proxify\\n                :ref T\\n    let proxyProps = proxify(props)\\n    :type Pick\\n        :< T\\n        :< K\\n            :keyof \\n                :ref T\\n        :mapped \\n            :< P\\n                :ref K\\n            :[] \\n                :ref T\\n                :ref P\\n    :type Record\\n        :< K\\n            :string \\n        :< T\\n        :mapped \\n            :< P\\n                :ref K\\n            :ref T\\n    :type ThreeStringProps\\n        :ref Record\\n            :union \\n                :literal 'prop1'\\n                :literal 'prop2'\\n                :literal 'prop3'\\n            :string ",
                    "generated": "\\ntype Flags = {option1: boolean;\\n    option2: boolean;\\n};\\ntype NullablePerson = [P in  keyof Person] : Person[P] | null;\\ntype PartialPerson = [P in  keyof Person] : Person[P];\\ntype Nullable&lt;T&gt; = [P in  keyof T] : T[P] | null;\\ntype Partial&lt;T&gt; = [P in  keyof T] : T[P];\\ntype Proxy&lt;T&gt; = {get(): T;\\n    set(value: T): void;\\n};\\ntype Proxify&lt;T&gt; = [P in  keyof T] : &lt;Proxy&gt;T[P];\\nfunction proxify&lt;T&gt;(o: T):  &lt;Proxify&gt;T {\\n}\\nlet proxyProps = proxify(props);\\ntype Pick&lt;T, K keyof T&gt; = [P extends K] : T[P];\\ntype Record&lt;Kstring, T&gt; = [P extends K] : T;\\ntype ThreeStringProps = Record;\\n"
                },
                {
                    "title": "Inference from mapped types",
                    "ittfWrapped": "module \\n    function unproxify\\n        :< T\\n        param t\\n            :ref Proxify\\n                :ref T\\n        :return \\n            :ref T\\n        let result\\n            :as \\n                :ref T\\n                { {}\\n        for \\n            left \\n                const k\\n            right t\\n            set result[k] = t[k].get()\\n        return result\\n    let originalProps = unproxify(proxyProps)",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: left, wzElement: undefined, wzName:, row:14, col:13, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0011                 :ref T\\\",\\n    \\\"0012                 { {}\\\",\\n    \\\"0013         for \\\",\\n    \\\"0014             left \\\",\\n    \\\"                 ^ Tag not recognized: left  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0015                 const k\\\",\\n    \\\"0016             right t\\\",\\n    \\\"0017             set result[k] = t[k].get()\\\",\\n    \\\"0018         return result\\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at xfor.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1053:23)\\n    at xfunction.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at xfunction.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:377:29)\\n    at xfunction.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:2871:48)\\n    at xfunction.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:2881:27)\\n    at module.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at module.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:904:29)\\n    at module.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1127:48)\\n    at module.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1137:27)\\\"\\n}"
                },
                {
                    "title": "Conditional Types",
                    "ittfWrapped": "module \\n    :function f\\n        :< T\\n            :boolean \\n        param x\\n            :ref T\\n        :return \\n            :conditional \\n                :literal true\\n                :ref T\\n                :string \\n                :number \\n    let x = f(Math.random() < 0.5)\\n    :type TypeName\\n        :< T\\n        :conditional \\n            :string \\n            :ref T\\n            :literal \\\"string\\\"\\n            :conditional \\n                :number \\n                :ref T\\n                :literal \\\"number\\\"\\n                :conditional \\n                    :boolean \\n                    :ref T\\n                    :literal \\\"boolean\\\"\\n                    :conditional \\n                        :void \\n                        :ref T\\n                        :literal \\\"undefined\\\"\\n                        :conditional \\n                            :ref Function\\n                            :ref T\\n                            :literal \\\"function\\\"\\n                            :literal \\\"object\\\"",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: :conditional, wzElement: undefined, wzName:, row:8, col:13, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0005         param x\\\",\\n    \\\"0006             :ref T\\\",\\n    \\\"0007         :return \\\",\\n    \\\"0008             :conditional \\\",\\n    \\\"                 ^ Tag not recognized: :conditional  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0009                 :literal true\\\",\\n    \\\"0010                 :ref T\\\",\\n    \\\"0011                 :string \\\",\\n    \\\"0012                 :number \\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at typeReturn.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1053:23)\\n    at typeFunctionDeclare.tsBase.wzLoadOneToOne (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:127:18)\\n    at typeFunctionDeclare.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:3312:29)\\n    at typeFunctionDeclare.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:3325:27)\\n    at module.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at module.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:925:29)\\n    at module.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1127:48)\\n    at module.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1137:27)\\n    at loadModelFromMTree (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-factory.g.js:66:29)\\\"\\n}"
                },
                {
                    "title": "Distributive conditional types",
                    "ittfWrapped": "module \\n    :type T10\\n        :ref TypeName\\n            :union \\n                :string \\n                :paren \\n                    :=> \\n                        :void \\n    :type T12\\n        :ref TypeName\\n            :union \\n                :string \\n                :[ \\n                    :string \\n                :void \\n    :type T11\\n        :ref TypeName\\n            :union \\n                :[ \\n                    :string \\n                :[ \\n                    :number \\n    :type BoxedValue\\n        :< T\\n        :{ \\n            :p value\\n                :ref T\\n    :type BoxedArray\\n        :< T\\n        :{ \\n            :p array\\n                :[ \\n                    :ref T\\n    :type Boxed\\n        :< T\\n        :conditional \\n            :[ \\n                :any \\n            :ref T\\n            :ref BoxedArray\\n                :[] \\n                    :ref T\\n                    :number \\n            :ref BoxedValue\\n                :ref T\\n    :type T20\\n        :ref Boxed\\n            :string \\n    :type T21\\n        :ref Boxed\\n            :[ \\n                :number \\n    :type T22\\n        :ref Boxed\\n            :union \\n                :string \\n                :[ \\n                    :number \\n    :type Diff\\n        :< T\\n        :< U\\n        :conditional \\n            :ref U\\n            :ref T\\n            :never \\n            :ref T\\n    :type Filter\\n        :< T\\n        :< U\\n        :conditional \\n            :ref U\\n            :ref T\\n            :ref T\\n            :never \\n    :type T30\\n        :ref Diff\\n            :union \\n                :literal \\\"a\\\"\\n                :literal \\\"b\\\"\\n                :literal \\\"c\\\"\\n                :literal \\\"d\\\"\\n            :union \\n                :literal \\\"a\\\"\\n                :literal \\\"c\\\"\\n                :literal \\\"f\\\"\\n    :type T31\\n        :ref Filter\\n            :union \\n                :literal \\\"a\\\"\\n                :literal \\\"b\\\"\\n                :literal \\\"c\\\"\\n                :literal \\\"d\\\"\\n            :union \\n                :literal \\\"a\\\"\\n                :literal \\\"c\\\"\\n                :literal \\\"f\\\"\\n    :type T32\\n        :ref Diff\\n            :union \\n                :string \\n                :number \\n                :paren \\n                    :=> \\n                        :void \\n            :ref Function\\n    :type T33\\n        :ref Filter\\n            :union \\n                :string \\n                :number \\n                :paren \\n                    :=> \\n                        :void \\n            :ref Function\\n    :type NonNullable\\n        :< T\\n        :ref Diff\\n            :ref T\\n            :union \\n                :null \\n                :void \\n    :type T34\\n        :ref NonNullable\\n            :union \\n                :string \\n                :number \\n                :void \\n    :type T35\\n        :ref NonNullable\\n            :union \\n                :string \\n                :[ \\n                    :string \\n                :null \\n                :void \\n    function f1\\n        :< T\\n        param x\\n            :ref T\\n        param y\\n            :ref NonNullable\\n                :ref T\\n        set x = y\\n        set y = x\\n    function f2\\n        :< T\\n            :union \\n                :string \\n                :void \\n        param x\\n            :ref T\\n        param y\\n            :ref NonNullable\\n                :ref T\\n        set x = y\\n        set y = x\\n        let s1\\n            :string \\n            := x\\n        let s2\\n            :string \\n            := y",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: :conditional, wzElement: undefined, wzName:, row:36, col:9, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0033                     :ref T\\\",\\n    \\\"0034     :type Boxed\\\",\\n    \\\"0035         :&lt; T\\\",\\n    \\\"0036         :conditional \\\",\\n    \\\"             ^ Tag not recognized: :conditional  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0037             :[ \\\",\\n    \\\"0038                 :any \\\",\\n    \\\"0039             :ref T\\\",\\n    \\\"0040             :ref BoxedArray\\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at typeTypeAlias.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:3229:23)\\n    at module.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at module.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:605:29)\\n    at module.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1127:48)\\n    at module.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1137:27)\\n    at loadModelFromMTree (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-factory.g.js:66:29)\\n    at C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-factory.g.js:176:21\\n    at C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-mtree\\\\lib\\\\loader\\\\index.js:82:25\\n    at finalize (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-mtree\\\\lib\\\\loader\\\\evaluator.js:106:5)\\\"\\n}"
                },
                {
                    "title": "Conditional types combined with mapped types:",
                    "ittfWrapped": "module \\n    :type FunctionPropertyNames\\n        :< T\\n        :[] \\n            :mapped \\n                :< K\\n                    :keyof \\n                        :ref T\\n                :conditional \\n                    :ref Function\\n                    :[] \\n                        :ref T\\n                        :ref K\\n                    :ref K\\n                    :never \\n            :keyof \\n                :ref T\\n    :type FunctionProperties\\n        :< T\\n        :ref Pick\\n            :ref T\\n            :ref FunctionPropertyNames\\n                :ref T\\n    :type NonFunctionPropertyNames\\n        :< T\\n        :[] \\n            :mapped \\n                :< K\\n                    :keyof \\n                        :ref T\\n                :conditional \\n                    :ref Function\\n                    :[] \\n                        :ref T\\n                        :ref K\\n                    :never \\n                    :ref K\\n            :keyof \\n                :ref T\\n    :type NonFunctionProperties\\n        :< T\\n        :ref Pick\\n            :ref T\\n            :ref NonFunctionPropertyNames\\n                :ref T\\n    :interface Part\\n        :p id\\n            :number \\n        :p name\\n            :string \\n        :p subparts\\n            :[ \\n                :ref Part\\n        :m updatePart\\n            :void \\n            param newName\\n                :string \\n    :type T40\\n        :ref FunctionPropertyNames\\n            :ref Part\\n    :type T41\\n        :ref NonFunctionPropertyNames\\n            :ref Part\\n    :type T42\\n        :ref FunctionProperties\\n            :ref Part\\n    :type T43\\n        :ref NonFunctionProperties\\n            :ref Part\\n    :type ElementType\\n        :< T\\n        :conditional \\n            :[ \\n                :any \\n            :ref T\\n            :ref ElementType\\n                :[] \\n                    :ref T\\n                    :number \\n            :ref T",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: :conditional, wzElement: undefined, wzName:, row:9, col:17, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0006                 :&lt; K\\\",\\n    \\\"0007                     :keyof \\\",\\n    \\\"0008                         :ref T\\\",\\n    \\\"0009                 :conditional \\\",\\n    \\\"                     ^ Tag not recognized: :conditional  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0010                     :ref Function\\\",\\n    \\\"0011                     :[] \\\",\\n    \\\"0012                         :ref T\\\",\\n    \\\"0013                         :ref K\\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at typeMapped.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:3645:23)\\n    at typeIndexedAccess.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at typeIndexedAccess.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:824:29)\\n    at typeIndexedAccess.statement.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1051:27)\\n    at typeTypeAlias.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at typeTypeAlias.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:362:29)\\n    at typeTypeAlias.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:3217:48)\\n    at typeTypeAlias.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:3227:27)\\n    at module.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\\"\\n}"
                },
                {
                    "title": "Type inference in conditional types",
                    "ittfWrapped": "module \\n    :type ReturnType\\n        :< T\\n        :conditional \\n            :=> \\n                :infer \\n                    :< R\\n                param ...args\\n                    :[ \\n                        :any \\n            :ref T\\n            :ref R\\n            :any \\n    :type Unpacked\\n        :< T\\n        :conditional \\n            :[ \\n                :paren \\n                    :infer \\n                        :< U\\n            :ref T\\n            :ref U\\n            :conditional \\n                :=> \\n                    :infer \\n                        :< U\\n                    param ...args\\n                        :[ \\n                            :any \\n                :ref T\\n                :ref U\\n                :conditional \\n                    :ref Promise\\n                        :infer \\n                            :< U\\n                    :ref T\\n                    :ref U\\n                    :ref T\\n    :type T0\\n        :ref Unpacked\\n            :string \\n    :type T1\\n        :ref Unpacked\\n            :[ \\n                :string \\n    :type T2\\n        :ref Unpacked\\n            :=> \\n                :string \\n    :type T3\\n        :ref Unpacked\\n            :ref Promise\\n                :string \\n    :type T4\\n        :ref Unpacked\\n            :[ \\n                :ref Promise\\n                    :string \\n    :type T5\\n        :ref Unpacked\\n            :ref Unpacked\\n                :[ \\n                    :ref Promise\\n                        :string \\n    :type Foo\\n        :< T\\n        :conditional \\n            :{ \\n                :p a\\n                    :infer \\n                        :< U\\n                :p b\\n                    :infer \\n                        :< U\\n            :ref T\\n            :ref U\\n            :never \\n    :type T10\\n        :ref Foo\\n            :{ \\n                :p a\\n                    :string \\n                :p b\\n                    :string \\n    :type T11\\n        :ref Foo\\n            :{ \\n                :p a\\n                    :string \\n                :p b\\n                    :number \\n    :type Bar\\n        :< T\\n        :conditional \\n            :{ \\n                :p a\\n                    :=> \\n                        :void \\n                        param x\\n                            :infer \\n                                :< U\\n                :p b\\n                    :=> \\n                        :void \\n                        param x\\n                            :infer \\n                                :< U\\n            :ref T\\n            :ref U\\n            :never \\n    :type T20\\n        :ref Bar\\n            :{ \\n                :p a\\n                    :=> \\n                        :void \\n                        param x\\n                            :string \\n                :p b\\n                    :=> \\n                        :void \\n                        param x\\n                            :string \\n    :type T21\\n        :ref Bar\\n            :{ \\n                :p a\\n                    :=> \\n                        :void \\n                        param x\\n                            :string \\n                :p b\\n                    :=> \\n                        :void \\n                        param x\\n                            :number \\n    :function foo\\n        param x\\n            :string \\n        :return \\n            :number \\n    :function foo\\n        param x\\n            :number \\n        :return \\n            :string \\n    :function foo\\n        param x\\n            :union \\n                :string \\n                :number \\n        :return \\n            :union \\n                :string \\n                :number \\n    :type T30\\n        :ref ReturnType\\n            :typeof foo\\n    :type ReturnType\\n        :< T\\n            :=> \\n                :infer \\n                    :< R\\n                param ...args\\n                    :[ \\n                        :any \\n        :ref R\\n    :type AnyFunction\\n        :=> \\n            :any \\n            param ...args\\n                :[ \\n                    :any \\n    :type ReturnType\\n        :< T\\n            :ref AnyFunction\\n        :conditional \\n            :=> \\n                :infer \\n                    :< R\\n                param ...args\\n                    :[ \\n                        :any \\n            :ref T\\n            :ref R\\n            :any ",
                    "generated": "\\n{\\n  \\\"name\\\": \\\"WizziModelLoadError\\\",\\n  \\\"message\\\": \\\"Error: Tag not recognized: :conditional, wzElement: undefined, wzName:, row:4, col:9, source:c:/basefolder/temp.ts.ittf\\nIn ts Factory, calling loadFromNode.\\nLoading ittf document c:/basefolder/temp.ts.ittf\\\",\\n  \\\"errorLines\\\": [\\n    \\\"0001 module \\\",\\n    \\\"0002     :type ReturnType\\\",\\n    \\\"0003         :&lt; T\\\",\\n    \\\"0004         :conditional \\\",\\n    \\\"             ^ Tag not recognized: :conditional  &lt;--- --- --- --- --- ERROR\\\",\\n    \\\"0005             :=&gt; \\\",\\n    \\\"0006                 :infer \\\",\\n    \\\"0007                     :&lt; R\\\",\\n    \\\"0008                 param ...args\\\"\\n  ],\\n  \\\"stack\\\": \\\"Error\\n    at new tsModelException (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:7879:23)\\n    at typeTypeAlias.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:3229:23)\\n    at module.tsBase.wzLoadToChildColl (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:100:18)\\n    at module.statement.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:605:29)\\n    at module.loadChild (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1127:48)\\n    at module.loadFromNode (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-model.g.js:1137:27)\\n    at loadModelFromMTree (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-factory.g.js:66:29)\\n    at C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-js\\\\lib\\\\wizzi\\\\models\\\\ts-factory.g.js:176:21\\n    at C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-mtree\\\\lib\\\\loader\\\\index.js:82:25\\n    at finalize (C:\\\\my\\\\wizzi\\\\v5\\\\apps\\\\node_modules\\\\wizzi-mtree\\\\lib\\\\loader\\\\evaluator.js:106:5)\\\"\\n}"
                },
                {
                    "title": "Predefined conditional types",
                    "ittfWrapped": "module \\n    :type T00\\n        :ref Exclude\\n            :union \\n                :literal \\\"a\\\"\\n                :literal \\\"b\\\"\\n                :literal \\\"c\\\"\\n                :literal \\\"d\\\"\\n            :union \\n                :literal \\\"a\\\"\\n                :literal \\\"c\\\"\\n                :literal \\\"f\\\"\\n    :type T01\\n        :ref Extract\\n            :union \\n                :literal \\\"a\\\"\\n                :literal \\\"b\\\"\\n                :literal \\\"c\\\"\\n                :literal \\\"d\\\"\\n            :union \\n                :literal \\\"a\\\"\\n                :literal \\\"c\\\"\\n                :literal \\\"f\\\"\\n    :type T02\\n        :ref Exclude\\n            :union \\n                :string \\n                :number \\n                :paren \\n                    :=> \\n                        :void \\n            :ref Function\\n    :type T03\\n        :ref Extract\\n            :union \\n                :string \\n                :number \\n                :paren \\n                    :=> \\n                        :void \\n            :ref Function\\n    :type T04\\n        :ref NonNullable\\n            :union \\n                :string \\n                :number \\n                :void \\n    :type T05\\n        :ref NonNullable\\n            :union \\n                :paren \\n                    :=> \\n                        :string \\n                :[ \\n                    :string \\n                :null \\n                :void \\n    function f1\\n        param s\\n            :string \\n        return \\n            { \\n                @ a 1\\n                @ b s\\n    class C\\n        p x\\n            := 0\\n        p y\\n            := 0\\n    :type T10\\n        :ref ReturnType\\n            :=> \\n                :string \\n    :type T11\\n        :ref ReturnType\\n            :=> \\n                :void \\n                param s\\n                    :string \\n    :type T12\\n        :ref ReturnType\\n            :paren \\n                :=> \\n                    :ref T\\n    :type T13\\n        :ref ReturnType\\n            :paren \\n                :=> \\n                    :ref T\\n    :type T14\\n        :ref ReturnType\\n            :typeof f1\\n    :type T15\\n        :ref ReturnType\\n            :any \\n    :type T16\\n        :ref ReturnType\\n            :never \\n    :type T17\\n        :ref ReturnType\\n            :string \\n    :type T18\\n        :ref ReturnType\\n            :ref Function\\n    :type T20\\n        :ref InstanceType\\n            :typeof C\\n    :type T21\\n        :ref InstanceType\\n            :any \\n    :type T22\\n        :ref InstanceType\\n            :never \\n    :type T23\\n        :ref InstanceType\\n            :string \\n    :type T24\\n        :ref InstanceType\\n            :ref Function",
                    "generated": "\\ntype T00 = Exclude;\\ntype T01 = Extract;\\ntype T02 = Exclude;\\ntype T03 = Extract;\\ntype T04 = &lt;NonNullable&gt;string | number | void;\\ntype T05 = &lt;NonNullable&gt;(()) | string[] | null | void;\\nfunction f1(s: string) {\\n    return {\\n            a: 1, \\n            b: s\\n        };\\n}\\nclass C {\\n    x = 0;\\n    y = 0;\\n}\\ntype T10 = &lt;ReturnType&gt;();\\ntype T11 = &lt;ReturnType&gt;(s: string;\\n)type T12 = &lt;ReturnType&gt;(());\\ntype T13 = &lt;ReturnType&gt;(());\\ntype T14 = &lt;ReturnType&gt;typeof f1;\\ntype T15 = &lt;ReturnType&gt;any;\\ntype T16 = &lt;ReturnType&gt;never;\\ntype T17 = &lt;ReturnType&gt;string;\\ntype T18 = &lt;ReturnType&gt;Function;\\ntype T20 = &lt;InstanceType&gt;typeof C;\\ntype T21 = &lt;InstanceType&gt;any;\\ntype T22 = &lt;InstanceType&gt;never;\\ntype T23 = &lt;InstanceType&gt;string;\\ntype T24 = &lt;InstanceType&gt;Function;\\n"
                }
            ]
        }
    ]
}
