element advanced
	tag
	ast 
	category
	
	item
		title Intersection Types
		expected
			+ function extend<T, U>(first: T, second: U): T & U {
				+ let result = {} as T & U;
				+ for (let id in first) {
					+ (result as any)[id] = (first as any)[id];
				+ }
				+ for (let id in second) {
					+ if (!result.hasOwnProperty(id)) {
						+ (result as any)[id] = (second as any)[id];
					+ }
				+ }
				+ return result;
			+ }
			+ class Person {
				+ constructor(public name: string) {}
			+ }
			+ interface Loggable {
				+ log(): void;
			+ }
			+ class ConsoleLogger implements Loggable {
				+ log() {
					+ // ...
				+ }
			+ }
			+ var jim = extend(new Person("Jim"), new ConsoleLogger());
			+ var n = jim.name;
			+ jim.log();

		ittf
			+
				function extend
					:< T
					:< U
					param first
						:ref T
					param second
						:ref U
					:return
						:intersect 
							:ref T
							:ref U
					let result
						:as 
							:intersect 
								:ref T
								:ref U
							{ {}
					for let id in first
						set =
							@expr 
								( 
									@id result
										:as 
											:any 
								.[ id
							@expr 
								( 
									@id first
										:as 
											:any 
								.[ id
					for let id in second
						if !result.hasOwnProperty(id)
							set =
								@expr 
									( 
										@id result
											:as 
												:any 
									.[ id
								@expr 
									( 
										@id second
											:as 
												:any 
									.[ id
					return result
				class Person
					ctor 
						param name
							:string 
				:interface Loggable
					:m log
						:void 
				class ConsoleLogger
					:extends Loggable
					m log
				var jim = extend(new Person("Jim"), new ConsoleLogger())
				var n = jim.name
				_ jim.log

	item
		title Union Types - fail at run time
		expected
			+ function padLeft(value: string, padding: any) {
				+ if (typeof padding === "number") {
					+ return Array(padding + 1).join(" ") + value;
				+ }
				+ if (typeof padding === "string") {
					+ return padding + value;
				+ }
				+ throw new Error(`Expected string or number, got '${padding}'.`);
			+ }
			+ padLeft("Hello world", 4); // returns "    Hello world"
			+ let indentedString = padLeft("Hello world", true); // passes at compile time, fails at runtime.
		
		ittf
			+
				function padLeft
					param value
						:string 
					param padding
						:any 
					if typeof padding === "number"
						return Array(padding + 1).join(" ") + value
					if typeof padding === "string"
						return padding + value
					throw 
						new Error
							`lit 
								+ Expected string or number, got '
								@ padding
								+ '.
				_ padLeft("Hello world", 4)
				let indentedString = padLeft("Hello world", true)
	item
		title Union Types - succeds at run time
		expected
			+ function padLeft(value: string, padding: string | number) {
				+ // ...
			+ }
			+ let indentedString = padLeft("Hello world", true); // errors during compilation

		ittf
			+
				function padLeft
					param value
						:string 
					param padding
						:union 
							:string 
							:number 
				let indentedString = padLeft("Hello world", true)
				
	item
		title Union Types - common members
		expected
			+ // If we have a value that has a union type, we can only access members that are common to all types in the union.
			+ interface Bird {
				+ fly();
				+ layEggs();
			+ }
			+ interface Fish {
				+ swim();
				+ layEggs();
			+ }
			+ function getSmallPet(): Fish | Bird {
				+ // ...
			+ }
		ittf
			+
				:interface Bird
					:m fly
					:m layEggs
				:interface Fish
					:m swim
					:m layEggs
				function getSmallPet
					:return
						:union 
							:ref Fish
							:ref Bird
				let pet = getSmallPet()
				_ pet.layEggs
				_ pet.swim

	item
		title Type Guards and Differentiating Types
		expected
			+ let pet = getSmallPet();
			+ if ((pet as Fish).swim) {
				+ (pet as Fish).swim();
			+ } else {
				+ (pet as Bird).fly();
			+ }
		ittf
			+
				let pet = getSmallPet()
				if 
					test
						@expr 
							( 
								@id pet
									:as 
										:ref Fish
							. swim
					_ 
						( 
							@id pet
								:as 
									:ref Fish
						._ swim
				else
					_ 
						( 
							@id pet
								:as 
									:ref Bird
						._ fly
    
	item
		title User - Defined Type Guards
		expected
			+ function isFish(pet: Fish | Bird): pet is Fish {
				+ return (pet as Fish).swim !== undefined;
			+ }
			+ function isNumber(x: any): x is number {
				+ return typeof x === "number";
			+ }
			+ function isString(x: any): x is string {
				+ return typeof x === "string";
			+ }
			+ function padLeft(value: string, padding: string | number) {
				+ if (isNumber(padding)) {
					+ return Array(padding + 1).join(" ") + value;
				+ }
				+ if (isString(padding)) {
					+ return padding + value;
				+ }
				+ throw new Error(`Expected string or number, got '${padding}'.`);
			+ }

		ittf
			+
				function isFish
					param pet
						:union 
							:ref Fish
							:ref Bird
					:return
						:predicate pet
							:ref Fish
					return 
						!== 
							@expr 
								( 
									@id pet
										:as 
											:ref Fish
								. swim
							+ undefined
				function isNumber
					param x
						:any 
					:return
						:predicate x
							:number 
					return typeof x === "number"
				function isString
					param x
						:any 
					:return
						:predicate x
							:string 
					return typeof x === "string"
				function padLeft
					param value
						:string 
					param padding
						:union 
							:string 
							:number 
					if isNumber(padding)
						return Array(padding + 1).join(" ") + value
					if isString(padding)
						return padding + value
					throw 
						new Error
							`lit 
								+ Expected string or number, got '
								@ padding
								+ '.

	item
		title Instanceof type guards
		expected
			+ interface Padder {
				+ getPaddingString(): string
			+ }
			+ class SpaceRepeatingPadder implements Padder {
				+ constructor(private numSpaces: number) {}
				+ getPaddingString() {
					+ return Array(this.numSpaces + 1).join(" ");
				+ }
			+ }
			+ class StringPadder implements Padder {
				+ constructor(private value: string) { }
				+ getPaddingString() {
					+ return this.value;
				+ }
			+ }
			+ function getRandomPadder() {
				+ return Math.random() < 0.5 ?
					+ new SpaceRepeatingPadder(4) :
					+ new StringPadder("  ");
			+ }
			+ // Type is 'SpaceRepeatingPadder | StringPadder'
			+ let padder: Padder = getRandomPadder();
			+ if (padder instanceof SpaceRepeatingPadder) {
				+ var x = padder; // type narrowed to 'SpaceRepeatingPadder'
			+ }
			+ if (padder instanceof StringPadder) {
				+ var x = padder; // type narrowed to 'StringPadder'
			+ }

		ittf
			+
				:interface Padder
					:m getPaddingString
						:string 
				class SpaceRepeatingPadder
					:extends Padder
					ctor 
						param numSpaces
							:private 
							:number 
					m getPaddingString
						return Array(this.numSpaces + 1).join(" ")
				class StringPadder
					:extends Padder
					ctor 
						param value
							:private 
							:string 
					m getPaddingString
						return this.value
				function getRandomPadder
					return 
						iif Math.random() < 0.5
							then new SpaceRepeatingPadder(4)
							else new StringPadder("  ")
				# Type is 'SpaceRepeatingPadder | StringPadder'
				let padder
					:ref Padder
					_ getRandomPadder
				if padder instanceof SpaceRepeatingPadder
					var x = padder
					# type narrowed to 'SpaceRepeatingPadder'
				if padder instanceof StringPadder
					var x = padder
					# type narrowed to 'StringPadder'

	item
		title Nullable types
		expected
			+ let s = "foo";
			+ s = null; // error, 'null' is not assignable to 'string'
			+ let sn: string | null = "bar";
			+ sn = null; // ok
			+ sn = undefined; // error, 'undefined' is not assignable to 'string | null'
			+ // Note that TypeScript treats null and undefined differently in order to match JavaScript semantics. 
			+ // string | null is a different type than string | undefined and string | undefined | null.
			+ /*
				+ Optional parameters and properties
				+ With --strictNullChecks, an optional parameter automatically adds | undefined:
			+ */
			+ function f(x: number, y?: number) {
				+ return x + (y || 0);
			+ }
			+ f(1, 2);
			+ f(1);
			+ f(1, undefined);
			+ f(1, null); // error, 'null' is not assignable to 'number | undefined'
			+ // The same is true for optional properties:
			+ class C {
				+ a: number;
				+ b?: number;
			+ }
			+ let c = new C();
			+ c.a = 12;
			+ c.a = undefined; // error, 'undefined' is not assignable to 'number'
			+ c.b = 13;
			+ c.b = undefined; // ok
			+ c.b = null; // error, 'null' is not assignable to 'number | undefined'
		
		ittf
			+
				let s = "foo"
				set s = null
				let sn
					:union 
						:string 
						:null 
					:= "bar"
				set sn = null
				set sn = undefined
				function f
					param x
						:number 
					param 
						:number 
						:optional 
					return x + y || 0
				_ f(1, 2)
				_ f(1)
				_ f(1, undefined)
				_ f(1, null)
				class C
					p a
						:number 
					p b
						:number 
				let c = new C()
				set c.a = 12
				set c.a = undefined
				set c.b = 13
				set c.b = undefined
				set c.b = null

	item
		title Type guards and type assertions
		expected
			+ function f(sn: string | null): string {
				+ if (sn == null) {
					+ return "default";
				+ } else {
					+ return sn;
				+ }
			+ }
			+ // The null elimination is pretty obvious here, but you can use terser operators too:
			+ function f(sn: string | null): string {
				+ return sn || "default";
			+ }
			+ // In cases where the compiler can’t eliminate null or undefined, 
			+ // you can use the type assertion operator to manually remove them. 
			+ // The syntax is postfix !: identifier! removes null and undefined from the type of identifier:
			+ function broken(name: string | null): string {
				+ function postfix(epithet: string) {
					+ return name.charAt(0) + '.  the ' + epithet; // error, 'name' is possibly null
				+ }
				+ name = name || "Bob";
				+ return postfix("great");
			+ }
			+ function fixed(name: string | null): string {
				+ function postfix(epithet: string) {
					+ return name!.charAt(0) + '.  the ' + epithet; // ok
				+ }
				+ name = name || "Bob";
				+ return postfix("great");
			+ }
		ittf
			+
				function f
					param sn
						:union 
							:string 
							:null 
					:return
						:string 
					if sn == null
						return "default"
					else
						return sn
				function f
					param sn
						:union 
							:string 
							:null 
					:return
						:string 
					return sn || "default"
				function broken
					param name
						:union 
							:string 
							:null 
					:return
						:string 
					function postfix
						param epithet
							:string 
						return name.charAt(0) + '.  the ' + epithet
					set name = name || "Bob"
					return postfix("great")
				function fixed
					param name
						:union 
							:string 
							:null 
					:return
						:string 
					function postfix
						param epithet
							:string 
						return 
							op+ 
								op+ 
									_ 
										._ charAt
											@ 0
									+ '.  the '
								+ epithet
					set name = name || "Bob"
					return postfix("great")

	item
		title Type Aliases
		expected
			+ type Name = string;
			+ type NameResolver = () => string;
			+ type NameOrResolver = Name | NameResolver;
			+ function getName(n: NameOrResolver): Name {
				+ if (typeof n === "string") {
					+ return n;
				+ } else {
					+ return n();
				+ }
			+ }
			+ // Aliasing doesn’t actually create a new type - it creates a new name to refer to that type. 
			+ // Aliasing a primitive is not terribly useful, though it can be used as a form of documentation.
			+ // Just like interfaces, type aliases can also be generic - we can just add type parameters and use them on the right side of the alias declaration:
			+ type Container<T> = { value: T };
			+ // We can also have a type alias refer to itself in a property:
			+ type Tree<T> = {
				+ value: T;
				+ left: Tree<T>;
				+ right: Tree<T>;
			+ }
			+ // Together with intersection types, we can make some pretty mind-bending types:
			+ type LinkedList<T> = T & { next: LinkedList<T> };
			+ interface Person {
				+ name: string;
			+ }
			+ var people: LinkedList<Person>;
			+ var s = people.name;
			+ var s = people.next.name;
			+ var s = people.next.next.name;
			+ var s = people.next.next.next.name;
			+ // However, it’s not possible for a type alias to appear anywhere else on the right side of the declaration:
			+ type Yikes = Array<Yikes>; // error

		ittf
			+
				:type Name
					:string 
				:type NameResolver
					:=> 
						:string 
				:type NameOrResolver
					:union 
						:ref Name
						:ref NameResolver
				function getName
					param n
						:ref NameOrResolver
					:return
						:ref Name
					if typeof n === "string"
						return n
					else
						return n()
				:type Container
					:< T
					:{ 
						:p value
							:ref T
				:type Tree
					:< T
					:{ 
						:p value
							:ref T
						:p left
							:ref Tree
								:ref T
						:p right
							:ref Tree
								:ref T
				:type LinkedList
					:< T
					:intersect 
						:ref T
						:{ 
							:p next
								:ref LinkedList
									:ref T
				:interface Person
					:p name
						:string 
				var people
					:ref LinkedList
						:ref Person
				var s = people.name
				var s = people.next.name
				var s = people.next.next.name
				var s = people.next.next.next.name
				:type Yikes
					:ref Array
						:ref Yikes

	item
		title Interfaces vs.Type Aliases
		expected
			+
		ittf
			+
				:type Alias
					:{ 
						:p num
							:number 
				:interface Interface
					:p num
						:number 
				:function aliased
					param arg
						:ref Alias
					:return
						:ref Alias
				:function interfaced
					param arg
						:ref Interface
					:return
						:ref Interface
	
	item
		title String Literal Types
		expected
			+ type Easing = "ease-in" | "ease-out" | "ease-in-out";
			+ class UIElement {
				+ animate(dx: number, dy: number, easing: Easing) {
					+ if (easing === "ease-in") {
					+ } else if (easing === "ease-out") {
					+ } else if (easing === "ease-in-out") {
					+ } else {
						+ // error! should not pass null or undefined.
					+ }
				+ }
			+ }
			+ let button = new UIElement();
			+ button.animate(0, 0, "ease-in");
			+ button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed here
			+ // You can pass any of the three allowed strings, but any other string will give the error
			+ // Argument of type '"uneasy"' is not assignable to parameter of type '"ease-in" | "ease-out" | "ease-in-out"'
			+ // String literal types can be used in the same way to distinguish overloads:
			+ function createElement(tagName: "img"): HTMLImageElement;
			+ function createElement(tagName: "input"): HTMLInputElement;
			+ // ... more overloads ...
			+ function createElement(tagName: string): Element {
				+ // ... code goes here ...
			+ }

		ittf
			+
				:type Easing
					:union 
						:literal "ease-in"
						:literal "ease-out"
						:literal "ease-in-out"
				class UIElement
					m animate
						param dx
							:number 
						param dy
							:number 
						param easing
							:ref Easing
						if easing === "ease-in"
						else
							if easing === "ease-out"
							else
								if easing === "ease-in-out"
								else
				let button = new UIElement()
				_ button.animate(0, 0, "ease-in")
				_ button.animate(0, 0, "uneasy")
				:function createElement
					param tagName
						:literal "img"
					:return
						:ref HTMLImageElement
				:function createElement
					param tagName
						:literal "input"
					:return
						:ref HTMLInputElement
				function createElement
					param tagName
						:string 
					:return
						:ref Element

	item
		title Numeric Literal Types
		expected
			+ function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 {
			+ }
			+ // These are seldom written explicitly, they can be useful when narrowing can catch bugs:
			+ function foo(x: number) {
				+ if (x !== 1 || x !== 2) {
					+ // Operator '!==' cannot be applied to types '1' and '2'.
				+ }
			+ }
			+ // In other words, x must be 1 when it gets compared to 2, meaning that the above check is making an invalid comparison.

		ittf
			+
				function rollDie
					:return
						:union 
							:literal 1
							:literal 2
							:literal 3
							:literal 4
							:literal 5
							:literal 6
				function foo
					param x
						:number 
					if x !== 1 || x !== 2

	item
		title Enum Member Types
		expected
			+ interface Square {
				+ kind: "square";
				+ size: number;
			+ }
			+ interface Rectangle {
				+ kind: "rectangle";
				+ width: number;
				+ height: number;
			+ }
			+ interface Circle {
				+ kind: "circle";
				+ radius: number;
			+ }
			+ // First we declare the interfaces we will union. Each interface has a kind property with 
			+ // a different string literal type.The kind property is called the discriminant or tag.The other properties are specific to each interface.Notice that the interfaces are currently unrelated.Let’s put them into a union:
			+ type Shape = Square | Rectangle | Circle;
			+ // Now let’s use the discriminated union:
			+ function area(s: Shape) {
				+ switch (s.kind) {
					+ case "square": return s.size * s.size;
					+ case "rectangle": return s.height * s.width;
					+ case "circle": return Math.PI * s.radius ** 2;
				+ }
			+ }

		ittf
			+
				:interface Square
					:p kind
						:literal "square"
					:p size
						:number 
				:interface Rectangle
					:p kind
						:literal "rectangle"
					:p width
						:number 
					:p height
						:number 
				:interface Circle
					:p kind
						:literal "circle"
					:p radius
						:number 
				:type Shape
					:union 
						:ref Square
						:ref Rectangle
						:ref Circle
				function area
					param s
						:ref Shape
					switch s.kind
						case "square"
							return s.size * s.size
						case "rectangle"
							return s.height * s.width
						case "circle"
							return Math.PI * s.radius ** 2

	item
		title Exhaustiveness checking
		expected
			+ type Shape = Square | Rectangle | Circle | Triangle;
			+ function area(s: Shape) {
				+ switch (s.kind) {
					+ case "square": return s.size * s.size;
					+ case "rectangle": return s.height * s.width;
					+ case "circle": return Math.PI * s.radius ** 2;
				+ }
				+ // should error here - we didn't handle case "triangle"
			+ }
			+ // There are two ways to do this. The first is to turn on --strictNullChecks and specify a return type:
			+ function area(s: Shape): number { // error: returns number | undefined
				+ switch (s.kind) {
					+ case "square": return s.size * s.size;
					+ case "rectangle": return s.height * s.width;
					+ case "circle": return Math.PI * s.radius ** 2;
				+ }
			+ }
			+ // Because the switch is no longer exhaustive, TypeScript is aware that the function could sometimes 
			+ // return undefined.If you have an explicit return type number, then you will get an error that 
			+ // the return type is actually number | undefined.However, this method is quite subtle and, besides, --strictNullChecks does not always work with old code.
			+ // The second method uses the never type that the compiler uses to check for exhaustiveness:
			+ function assertNever(x: never): never {
				+ throw new Error("Unexpected object: " + x);
			+ }
			+ function area(s: Shape) {
				+ switch (s.kind) {
					+ case "square": return s.size * s.size;
					+ case "rectangle": return s.height * s.width;
					+ case "circle": return Math.PI * s.radius ** 2;
					+ default: return assertNever(s); // error here if there are missing cases
				+ }
			+ }

		ittf
			+
				:type Shape
					:union 
						:ref Square
						:ref Rectangle
						:ref Circle
						:ref Triangle
				function area
					param s
						:ref Shape
					switch s.kind
						case "square"
							return s.size * s.size
						case "rectangle"
							return s.height * s.width
						case "circle"
							return Math.PI * s.radius ** 2
				function area
					param s
						:ref Shape
					:return
						:number 
					switch s.kind
						case "square"
							return s.size * s.size
						case "rectangle"
							return s.height * s.width
						case "circle"
							return Math.PI * s.radius ** 2
				function assertNever
					param x
						:never 
					:return
						:never 
					throw new Error("Unexpected object: " + x)
				function area
					param s
						:ref Shape
					switch s.kind
						case "square"
							return s.size * s.size
						case "rectangle"
							return s.height * s.width
						case "circle"
							return Math.PI * s.radius ** 2
						default 
							return assertNever(s)
	
	item
		title Polymorphic this types
		expected
			+ class BasicCalculator {
				+ public constructor(protected value: number = 0) { }
				+ public currentValue(): number {
					+ return this.value;
				+ }
				+ public add(operand: number): this {
					+ this.value += operand;
					+ return this;
				+ }
				+ public multiply(operand: number): this {
					+ this.value *= operand;
					+ return this;
				+ }
				+ // ... other operations go here ...
			+ }
			+ let v = new BasicCalculator(2)
				+ .multiply(5)
				+ .add(1)
				+ .currentValue();
			+ // Since the class uses this types, you can extend it and the new class can use the old methods with no changes.
			+ class ScientificCalculator extends BasicCalculator {
				+ public constructor(value = 0) {
					+ super(value);
				+ }
				+ public sin() {
					+ this.value = Math.sin(this.value);
					+ return this;
				+ }
				+ // ... other operations go here ...
			+ }
			+ let v = new ScientificCalculator(2)
				+ .multiply(5)
				+ .sin()
				+ .add(1)
				+ .currentValue();
			+ // Without this types, ScientificCalculator would not have been able to extend BasicCalculator and keep the fluent interface. multiply would have returned BasicCalculator, which doesn’t have the sin method. However, with this types, multiply returns this, which is ScientificCalculator here.

		ittf
			+
				class BasicCalculator
					ctor 
						:public 
						param value
							:number 
							:= 0
					m currentValue
						:public 
						return this.value
					m add
						:public 
						param operand
							:number 
						set this.value += operand
						return this
					m multiply
						:public 
						param operand
							:number 
						set this.value *= operand
						return this
				let v = new BasicCalculator(2).multiply(5).add(1).currentValue()
				class ScientificCalculator
					super BasicCalculator
					ctor 
						:public 
						param value = 0
						_ super(value)
					m sin
						:public 
						set this.value = Math.sin(this.value)
						return this
				let v = new ScientificCalculator(2).multiply(5).sin().add(1).currentValue()

	item
		title Index types
		expected
			+ function pluck(o, names) {
				+ return names.map(n => o[n]);
			+ }
			+ // Here’s how you would write and use this function in TypeScript, using the index type query and indexed access operators:
			+ function pluck<T, K extends keyof T>(o: T, names: K[]): T[K][] {
				+ return names.map(n => o[n]);
			+ }
			+ interface Person {
				+ name: string;
				+ age: number;
			+ }
			+ let person: Person = {
				+ name: 'Jarid',
				+ age: 35
			+ };
			+ let strings: string[] = pluck(person, ['name']); // ok, string[]
			+ // The compiler checks that name is actually a property on Person. The example introduces a couple of new type operators. 
			+ // First is keyof T, the index type query operator.For any type T, keyof T is the union of known, public property names of T.For example:
			+ let personProps: keyof Person; // 'name' | 'age'
			+ // keyof Person is completely interchangeable with 'name' | 'age'. The difference is that if you add another property to Person, 
			+ // say address: string, then keyof Person will automatically update to be 'name' | 'age' | 'address'.And you can use keyof in generic 
			+ // contexts like pluck, where you can’t possibly know the property names ahead of time.That means the compiler will check that you pass 
			+ // the right set of property names to pluck:
			+ pluck(person, ['age', 'unknown']); // error, 'unknown' is not in 'name' | 'age'
			+ // The second operator is T[K], the indexed access operator. Here, the type syntax reflects the expression syntax. 
			+ // That means that person['name'] has the type Person['name']— which in our example is just string.However, just like index type queries, 
			+ // you can use T[K] in a generic context, which is where its real power comes to life.You just have to make sure that the type variable K extends keyof T.
			+ // Here’s another example with a function named getProperty.
			+ function getProperty<T, K extends keyof T>(o: T, name: K): T[K] {
				+ return o[name]; // o[name] is of type T[K]
			+ }
			+ // In getProperty, o: T and name: K, so that means o[name]: T[K]. Once you return the T[K] result, the compiler will instantiate the actual type of the key, 
			+ // so the return type of getProperty will vary according to which property you request.
			+ let name: string = getProperty(person, 'name');
			+ let age: number = getProperty(person, 'age');
			+ let unknown = getProperty(person, 'unknown'); // error, 'unknown' is not in 'name' | 'age'
			+ // Index types and string index signatures
			+ // keyof and T[K] interact with string index signatures. If you have a type with a string index signature, keyof T will just be string. 
			+ // And T[string] is just the type of the index signature:
			+ interface Map<T> {
				+ [key: string]: T;
			+ }
			+ let keys: keyof Map<number>; // string
			+ let value: Map<number>['foo']; // number

		ittf
			+
				function pluck
					param o
					param names
					return 
						_ names.map
							=> 
								param n
								+ o[n]
				function pluck
					:< T
					:< K
						:keyof 
							:ref T
					param o
						:ref T
					param names
						:[ 
							:ref K
					:return
						:[ 
							:[] 
								:ref T
								:ref K
					return 
						_ names.map
							=> 
								param n
								+ o[n]
				:interface Person
					:p name
						:string 
					:p age
						:number 
				let person
					:ref Person
					{ 
						@ name 'Jarid'
						@ age 35
				let strings
					:[ 
						:string 
					_ pluck
						@ person
						[ 
							@ 'name'
				let personProps
					:keyof 
						:ref Person
				_ pluck
					@ person
					[ 
						@ 'age'
						@ 'unknown'
				function getProperty
					:< T
					:< K
						:keyof 
							:ref T
					param o
						:ref T
					param name
						:ref K
					:return
						:[] 
							:ref T
							:ref K
					return o[name]
				let name
					:string 
					_ getProperty(person, 'name')
				let age
					:number 
					_ getProperty(person, 'age')
				let unknown = getProperty(person, 'unknown')
				:interface Map
					:< T
					:index 
						:ref T
						param key
							:string 
				let keys
					:keyof 
						:ref Map
							:number 
				let value
					:[] 
						:ref Map
							:number 
						:literal 'foo'

	item
		title Mapped types
		expected
			+ interface PersonPartial {
				+ name?: string;
				+ age?: number;
			+ }
			+ // Or we might want a readonly version:
			+ interface PersonReadonly {
				+ readonly name: string;
				+ readonly age: number;
			+ }
			+ // This happens often enough in Javascript that TypeScript provides a way to create new types based on old types — mapped types. 
			+ // In a mapped type, the new type transforms each property in the old type in the same way.For example, you can make all properties 
			+ // of a type readonly or optional.Here are a couple of examples:
			+ type Readonly<T> = {
				+ readonly [P in keyof T]: T[P];
			+ }
			+ type Partial<T> = {
				+ [P in keyof T]?: T[P];
			+ }
			+ // And to use it:
			+ type PersonPartial = Partial<Person>;
			+ type ReadonlyPerson = Readonly<Person>;
			+ // Let’s take a look at the simplest mapped type and its parts:
			+ type Keys = 'option1' | 'option2';
			+ type Flags = {[K in Keys]: boolean };
			+ // The syntax resembles the syntax for index signatures with a for .. in inside. There are three parts:

		ittf
			+
				:interface PersonPartial
					:p name
						:optional 
						:string 
					:p age
						:optional 
						:number 
				:interface PersonReadonly
					:p name
						:string 
					:p age
						:number 
				:type Readonly
					:< T
					:mapped 
						:< P
							:keyof 
								:ref T
						:[] 
							:ref T
							:ref P
				:type Partial
					:< T
					:mapped 
						:optional 
						:< P
							:keyof 
								:ref T
						:[] 
							:ref T
							:ref P
				:type PersonPartial
					:ref Partial
						:ref Person
				:type ReadonlyPerson
					:ref Readonly
						:ref Person
				:type Keys
					:union 
						:literal 'option1'
						:literal 'option2'
				:type Flags
					:mapped 
						:< K
							:ref Keys
						:boolean 

	item
		title Mapped types 2
		expected
			+ /*
				+ The type variable K, which gets bound to each property in turn.
				+ The string literal union Keys, which contains the names of properties to iterate over.
				+ The resulting type of the property.
				+ In this simple example, Keys is a hard-coded list of property names and the property type is always boolean, so this mapped type is equivalent to writing: */
			+ type Flags = {
				+ option1: boolean;
				+ option2: boolean;
			+ }
			+ // Real applications, however, look like Readonly or Partial above. They’re based on some existing type, and they transform the properties 
			+ // in some way. That’s where keyof and indexed access types come in:
			+ type NullablePerson = {[P in keyof Person]: Person[P] | null }
			+ type PartialPerson = {[P in keyof Person]?: Person[P]}
			+ // But it’s more useful to have a general version.
			+ type Nullable<T> = {[P in keyof T]: T[P] | null }
			+ type Partial<T> = {[P in keyof T]?: T[P]}
			+ // In these examples, the properties list is keyof T and the resulting type is some variant of T[P]. 
			+ // This is a good template for any general use of mapped types. That’s because this kind of transformation is homomorphic, 
			+ // which means that the mapping applies only to properties of T and no others. The compiler knows that it can copy all the existing property 
			+ // modifiers before adding any new ones. For example, if Person.name was readonly, Partial<Person>.name would be readonly and optional.
			+ // Here’s one more example, in which T[P] is wrapped in a Proxy<T> class:
			+ type Proxy<T> = {
				+ get(): T;
				+ set(value: T): void;
			+ }
			+ type Proxify<T> = {
				+ [P in keyof T]: Proxy<T[P]>;
			+ }
			+ function proxify<T>(o: T): Proxify<T> {
				+ // ... wrap proxies ...
			+ }
			+ let proxyProps = proxify(props);
			+ // Note that Readonly<T> and Partial<T> are so useful, they are included in TypeScript’s standard library along with Pick and Record:
			+ type Pick<T, K extends keyof T> = {
				+ [P in K]: T[P];
			+ }
			+ type Record<K extends string, T> = {
				+ [P in K]: T;
			+ }
			+ // Readonly, Partial and Pick are homomorphic whereas Record is not. One clue that Record is not homomorphic is that it doesn’t take 
			+ // an input type to copy properties from:
			+ type ThreeStringProps = Record<'prop1' | 'prop2' | 'prop3', string>
			+ // Non-homomorphic types are essentially creating new properties, so they can’t copy property modifiers from anywhere.
		ittf
			+
				:type Flags
					:{ 
						:p option1
							:boolean 
						:p option2
							:boolean 
				:type NullablePerson
					:mapped 
						:< P
							:keyof 
								:ref Person
						:union 
							:[] 
								:ref Person
								:ref P
							:null 
				:type PartialPerson
					:mapped 
						:optional 
						:< P
							:keyof 
								:ref Person
						:[] 
							:ref Person
							:ref P
				:type Nullable
					:< T
					:mapped 
						:< P
							:keyof 
								:ref T
						:union 
							:[] 
								:ref T
								:ref P
							:null 
				:type Partial
					:< T
					:mapped 
						:optional 
						:< P
							:keyof 
								:ref T
						:[] 
							:ref T
							:ref P
				:type Proxy
					:< T
					:{ 
						:m get
							:ref T
						:m set
							:void 
							param value
								:ref T
				:type Proxify
					:< T
					:mapped 
						:< P
							:keyof 
								:ref T
						:ref Proxy
							:[] 
								:ref T
								:ref P
				function proxify
					:< T
					param o
						:ref T
					:return
						:ref Proxify
							:ref T
				let proxyProps = proxify(props)
				:type Pick
					:< T
					:< K
						:keyof 
							:ref T
					:mapped 
						:< P
							:ref K
						:[] 
							:ref T
							:ref P
				:type Record
					:< K
						:string 
					:< T
					:mapped 
						:< P
							:ref K
						:ref T
				:type ThreeStringProps
					:ref Record
						:union 
							:literal 'prop1'
							:literal 'prop2'
							:literal 'prop3'
						:string 

	item
		title Inference from mapped types
		expected
			+ function unproxify<T>(t: Proxify<T>): T {
				+ let result = {} as T;
				+ for (const k in t) {
					+ result[k] = t[k].get();
				+ }
				+ return result;
			+ }
			+ let originalProps = unproxify(proxyProps);

		ittf
			+
				function unproxify
					:< T
					param t
						:ref Proxify
							:param 
								:ref T
					:return
						:ref T
					let result = {}
					for const k in t
						set result[k] = t[k].get()
					return result
				let originalProps = unproxify(proxyProps)

	item
		title Conditional Types
		expected
			+ declare function f<T extends boolean>(x: T): T extends true ? string : number;
			+ // Type is 'string | number
			+ let x = f(Math.random() < 0.5)
			+ // Another example would be the TypeName type alias, which uses nested conditional types:
			+ type TypeName<T> =
				+ T extends string ? "string" :
					+ T extends number ? "number" :
						+ T extends boolean ? "boolean" :
							+ T extends undefined ? "undefined" :
								+ T extends Function ? "function" :
									+ "object";
			+ type T0 = TypeName<string>;  // "string"
			+ type T1 = TypeName<"a">;  // "string"
			+ type T2 = TypeName<true>;  // "boolean"
			+ type T3 = TypeName<() => void>;  // "function"
			+ type T4 = TypeName<string[]>;  // "object"
			+ // But as an example of a place where conditonal types are deferred - where they stick around instead of picking a branch - would be in the following:
			+ interface Foo {
				+ propA: boolean;
				+ propB: boolean;
			+ }
			+ declare function f<T>(x: T): T extends Foo ? string : number;
			+ function foo<U>(x: U) {
				+ // Has type 'U extends Foo ? string : number'
				+ let a = f(x);
				+ // This assignment is allowed though!
				+ let b: string | number = a;
			+ }

		ittf
			+
				:function f
					:< T
						:boolean 
					param x
						:ref T
					:return
						:iif 
							:check 
								:ref T
							:extends 
								:literal true
							:then 
								:string 
							:else 
								:number 
				# Type is 'string | number
				let x = f(Math.random() < 0.5)
				# Another example would be the TypeName type alias, which uses nested conditional types:
				:type TypeName
					:< T
					:iif 
						:check 
							:ref T
						:extends 
							:string 
						:then 
							:literal "string"
						:else 
							:iif 
								:check 
									:ref T
								:extends 
									:number 
								:then 
									:literal "number"
								:else 
									:iif 
										:check 
											:ref T
										:extends 
											:boolean 
										:then 
											:literal "boolean"
										:else 
											:iif 
												:check 
													:ref T
												:extends 
													:void 
												:then 
													:literal "undefined"
												:else 
													:iif 
														:check 
															:ref T
														:extends 
															:ref Function
														:then 
															:literal "function"
														:else 
															:literal "object"
				:type T0
					:ref TypeName
						:param string
				# "string"
				:type T1
					:ref TypeName
						:param 
							:literal "a"
				# "string"
				:type T2
					:ref TypeName
						:param 
							:literal true
				# "boolean"
				:type T3
					:ref TypeName
						:param 
							:=> 
								:void 
				# "function"
				:type T4
					:ref TypeName
						:param 
							:[ 
								:string 
				# "object"
				# But as an example of a place where conditonal types are deferred - where they stick around instead of picking a branch - would be in the following:
				:interface Foo
					:p propA
						:boolean 
					:p propB
						:boolean 
				:function f
					:< T
					param x
						:ref T
					:return
						:iif 
							:check 
								:ref T
							:extends 
								:ref Foo
							:then 
								:string 
							:else 
								:number 
				function foo
					:< U
					param x
						:ref U
					# Has type 'U extends Foo ? string : number'
					let a = f(x)
					# This assignment is allowed though!
					let b
						:union 
							:string 
							:number 
						:= a

	item
		title Distributive conditional types
		expected
			+ type T10 = TypeName<string | (() => void)>;  // "string" | "function"
			+ type T12 = TypeName<string | string[] | undefined>;  // "string" | "object" | "undefined"
			+ type T11 = TypeName<string[] | number[]>;  // "object"
			+ /* In instantiations of a distributive conditional type T extends U ? X : Y, references to T within the conditional type are resolved
				+ to individual constituents of the union type (i.e. T refers to the individual constituents after the conditional type is distributed
				+ over the union type). Furthermore, references to T within X have an additional type parameter constraint U (i.e. T is considered
				+ assignable to U within X).*/
			+ // Example
			+ type BoxedValue<T> = { value: T };
			+ type BoxedArray<T> = { array: T[] };
			+ type Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;
			+ type T20 = Boxed<string>;  // BoxedValue<string>;
			+ type T21 = Boxed<number[]>;  // BoxedArray<number>;
			+ type T22 = Boxed<string | number[]>;  // BoxedValue<string> | BoxedArray<number>;
			+ // Notice that T has the additional constraint any[] within the true branch of Boxed<T> and it is therefore possible to refer to the element type of the array as T[number]. Also, notice how the conditional type is distributed over the union type in the last example.
			+ // The distributive property of conditional types can conveniently be used to filter union types:
			+ type Diff<T, U> = T extends U ? never : T;  // Remove types from T that are assignable to U
			+ type Filter<T, U> = T extends U ? T : never;  // Remove types from T that are not assignable to U
			+ type T30 = Diff<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"
			+ type T31 = Filter<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"
			+ type T32 = Diff<string | number | (() => void), Function>;  // string | number
			+ type T33 = Filter<string | number | (() => void), Function>;  // () => void
			+ type NonNullable<T> = Diff<T, null | undefined>;  // Remove null and undefined from T
			+ type T34 = NonNullable<string | number | undefined>;  // string | number
			+ type T35 = NonNullable<string | string[] | null | undefined>;  // string | string[]
			+ function f1<T>(x: T, y: NonNullable<T>) {
				+ x = y;  // Ok
				+ y = x;  // Error
			+ }
			+ function f2<T extends string | undefined>(x: T, y: NonNullable<T>) {
				+ x = y;  // Ok
				+ y = x;  // Error
				+ let s1: string = x;  // Error
				+ let s2: string = y;  // Ok
			+ }

		ittf
			+
				:type T10
					:ref TypeName
						:param 
							:union 
								:string 
								:paren 
									:=> 
										:void 
				:type T12
					:ref TypeName
						:param 
							:union 
								:string 
								:[ 
									:string 
								:void 
				:type T11
					:ref TypeName
						:param 
							:union 
								:[ 
									:string 
								:[ 
									:number 
				#
					# In instantiations of a distributive conditional type T extends U ? X : Y, references to T within the conditional type are resolved
					# to individual constituents of the union type (i.e. T refers to the individual constituents after the conditional type is distributed
					# over the union type). Furthermore, references to T within X have an additional type parameter constraint U (i.e. T is considered
					# assignable to U within X).
				:type BoxedValue
					:< T
					:{ 
						:p value
							:ref T
				:type BoxedArray
					:< T
					:{ 
						:p array
							:[ 
								:ref T
				:type Boxed
					:< T
					:iif 
						:check 
							:ref T
						:extends 
							:[ 
								:any 
						:then 
							:ref BoxedArray
								:param 
									:[] 
										:ref T
										:number 
						:else 
							:ref BoxedValue
								:param 
									:ref T
				:type T20
					:ref Boxed
						:param string
				:type T21
					:ref Boxed
						:param 
							:[ 
								:number 
				:type T22
					:ref Boxed
						:param 
							:union 
								:string 
								:[ 
									:number 
				:type Diff
					:< T
					:< U
					:iif 
						:check 
							:ref T
						:extends 
							:ref U
						:then 
							:never 
						:else 
							:ref T
				:type Filter
					:< T
					:< U
					:iif 
						:check 
							:ref T
						:extends 
							:ref U
						:then 
							:ref T
						:else 
							:never 
				:type T30
					:ref Diff
						:param 
							:union 
								:literal "a"
								:literal "b"
								:literal "c"
								:literal "d"
						:param 
							:union 
								:literal "a"
								:literal "c"
								:literal "f"
				:type T31
					:ref Filter
						:param 
							:union 
								:literal "a"
								:literal "b"
								:literal "c"
								:literal "d"
						:param 
							:union 
								:literal "a"
								:literal "c"
								:literal "f"
				:type T32
					:ref Diff
						:param 
							:union 
								:string 
								:number 
								:paren 
									:=> 
										:void 
						:param 
							:ref Function
				:type T33
					:ref Filter
						:param 
							:union 
								:string 
								:number 
								:paren 
									:=> 
										:void 
						:param 
							:ref Function
				:type NonNullable
					:< T
					:ref Diff
						:param 
							:ref T
						:param 
							:union 
								:null 
								:void 
				:type T34
					:ref NonNullable
						:param 
							:union 
								:string 
								:number 
								:void 
				:type T35
					:ref NonNullable
						:param 
							:union 
								:string 
								:[ 
									:string 
								:null 
								:void 
				function f1
					:< T
					param x
						:ref T
					param y
						:ref NonNullable
							:param 
								:ref T
					set x = y
					set y = x
				function f2
					:< T
						:union 
							:string 
							:void 
					param x
						:ref T
					param y
						:ref NonNullable
							:param 
								:ref T
					set x = y
					set y = x
					let s1
						:string 
						:= x
					let s2
						:string 
						:= y
	item
		title Conditional types combined with mapped types:
		expected
			+ // conditional types are particularly useful when combined with mapped types:
			+ type FunctionPropertyNames<T> = {[K in keyof T]: T[K] extends Function ? K : never }[keyof T];
			+ type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;
			+ type NonFunctionPropertyNames<T> = {[K in keyof T]: T[K] extends Function ? never : K }[keyof T];
			+ type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;
			+ interface Part {
				+ id: number;
				+ name: string;
				+ subparts: Part[];
				+ updatePart(newName: string): void;
			+ }
			+ type T40 = FunctionPropertyNames<Part>;  // "updatePart"
			+ type T41 = NonFunctionPropertyNames<Part>;  // "id" | "name" | "subparts"
			+ type T42 = FunctionProperties<Part>;  // { updatePart(newName: string): void }
			+ type T43 = NonFunctionProperties<Part>;  // { id: number, name: string, subparts: Part[] }
			+ // Similar to union and intersection types, conditional types are not permitted to reference themselves recursively.For example the following is an error.
			+ // Example
			+ type ElementType<T> = T extends any[] ? ElementType<T[number]> : T;  // Error

		ittf
			+
				:type FunctionPropertyNames
					:< T
					:[] 
						:mapped 
							:< K
								:keyof 
									:ref T
							:iif 
								:check 
									:[] 
										:ref T
										:ref K
								:extends 
									:ref Function
								:then 
									:ref K
								:else 
									:never 
						:keyof 
							:ref T
				:type FunctionProperties
					:< T
					:ref Pick
						:param 
							:ref T
						:param 
							:ref FunctionPropertyNames
								:param 
									:ref T
				:type NonFunctionPropertyNames
					:< T
					:[] 
						:mapped 
							:< K
								:keyof 
									:ref T
							:iif 
								:check 
									:[] 
										:ref T
										:ref K
								:extends 
									:ref Function
								:then 
									:never 
								:else 
									:ref K
						:keyof 
							:ref T
				:type NonFunctionProperties
					:< T
					:ref Pick
						:param 
							:ref T
						:param 
							:ref NonFunctionPropertyNames
								:param 
									:ref T
				:interface Part
					:p id
						:number 
					:p name
						:string 
					:p subparts
						:[ 
							:ref Part
					:m updatePart
						:void 
						param newName
							:string 
				:type T40
					:ref FunctionPropertyNames
						:param 
							:ref Part
				:type T41
					:ref NonFunctionPropertyNames
						:param 
							:ref Part
				:type T42
					:ref FunctionProperties
						:param 
							:ref Part
				:type T43
					:ref NonFunctionProperties
						:param 
							:ref Part
				:type ElementType
					:< T
					:iif 
						:check 
							:ref T
						:extends 
							:[ 
								:any 
						:then 
							:ref ElementType
								:param 
									:[] 
										:ref T
										:number 
						:else 
							:ref T

	item
		title Type inference in conditional types
		expected
			+ //For example, the following extracts the return type of a function type:
			+ type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any;
			+ // Conditional types can be nested to form a sequence of pattern matches that are evaluated in order:
			+ type Unpacked<T> =
				+ T extends (infer U)[] ? U :
					+ T extends (...args: any[]) => infer U ? U :
						+ T extends Promise < infer U> ? U :
							+ T;
			+ type T0 = Unpacked<string>;  // string
			+ type T1 = Unpacked<string[]>;  // string
			+ type T2 = Unpacked<() => string>;  // string
			+ type T3 = Unpacked<Promise<string>>;  // string
			+ type T4 = Unpacked<Promise<string>[]>;  // Promise<string>
			+ type T5 = Unpacked<Unpacked<Promise<string>[]>>;  // string
			+ // The following example demonstrates how multiple candidates for the same type variable in co - variant positions causes a union type to be inferred:
			+ type Foo<T> = T extends { a: infer U, b: infer U } ? U: never;
			+ type T10 = Foo<{ a: string, b: string }>;  // string
			+ type T11 = Foo<{ a: string, b: number }>;  // string | number
			+ // Likewise, multiple candidates for the same type variable in contra - variant positions causes an intersection type to be inferred:
			+ type Bar<T> = T extends { a: (x: infer U) => void, b: (x: infer U) => void } ? U: never;
			+ type T20 = Bar<{ a: (x: string) => void, b: (x: string) => void }>;  // string
			+ type T21 = Bar<{ a: (x: string) => void, b: (x: number) => void }>;  // string & number
			+ // When inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made 
			+ // from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload 
			+ // resolution based on a list of argument types.
			+ declare function foo(x: string): number;
			+ declare function foo(x: number): string;
			+ declare function foo(x: string | number): string | number;
			+ type T30 = ReturnType<typeof foo>;  // string | number
			+ // It is not possible to use infer declarations in constraint clauses for regular type parameters:
			+ type ReturnType<T extends (...args: any[]) => infer R> = R;  // Error, not supported
			+ // However, much the same effect can be obtained by erasing the type variables in the constraint and instead specifying a conditional type:
			+ type AnyFunction = (...args: any[]) => any;
			+ type ReturnType<T extends AnyFunction> = T extends (...args: any[]) => infer R ? R : any;

		ittf
			+
				:type ReturnType
					:< T
					:iif 
						:check 
							:ref T
						:extends 
							:=> 
								:infer 
									:< R
								param ...args
									:[ 
										:any 
						:then 
							:ref R
						:else 
							:any 
				:type Unpacked
					:< T
					:iif 
						:check 
							:ref T
						:extends 
							:[ 
								:paren 
									:infer 
										:< U
						:then 
							:ref U
						:else 
							:iif 
								:check 
									:ref T
								:extends 
									:=> 
										:infer 
											:< U
										param ...args
											:[ 
												:any 
								:then 
									:ref U
								:else 
									:iif 
										:check 
											:ref T
										:extends 
											:ref Promise
												:param 
													:infer 
														:< U
										:then 
											:ref U
										:else 
											:ref T
				:type T0
					:ref Unpacked
						:param string
				:type T1
					:ref Unpacked
						:param 
							:[ 
								:string 
				:type T2
					:ref Unpacked
						:param 
							:=> 
								:string 
				:type T3
					:ref Unpacked
						:param 
							:ref Promise
								:param string
				:type T4
					:ref Unpacked
						:param 
							:[ 
								:ref Promise
									:param string
				:type T5
					:ref Unpacked
						:param 
							:ref Unpacked
								:param 
									:[ 
										:ref Promise
											:param string
				:type Foo
					:< T
					:iif 
						:check 
							:ref T
						:extends 
							:{ 
								:p a
									:infer 
										:< U
								:p b
									:infer 
										:< U
						:then 
							:ref U
						:else 
							:never 
				:type T10
					:ref Foo
						:param 
							:{ 
								:p a
									:string 
								:p b
									:string 
				:type T11
					:ref Foo
						:param 
							:{ 
								:p a
									:string 
								:p b
									:number 
				:type Bar
					:< T
					:iif 
						:check 
							:ref T
						:extends 
							:{ 
								:p a
									:=> 
										:void 
										param x
											:infer 
												:< U
								:p b
									:=> 
										:void 
										param x
											:infer 
												:< U
						:then 
							:ref U
						:else 
							:never 
				:type T20
					:ref Bar
						:param 
							:{ 
								:p a
									:=> 
										:void 
										param x
											:string 
								:p b
									:=> 
										:void 
										param x
											:string 
				:type T21
					:ref Bar
						:param 
							:{ 
								:p a
									:=> 
										:void 
										param x
											:string 
								:p b
									:=> 
										:void 
										param x
											:number 
				:function foo
					param x
						:string 
					:return
						:number 
				:function foo
					param x
						:number 
					:return
						:string 
				:function foo
					param x
						:union 
							:string 
							:number 
					:return
						:union 
							:string 
							:number 
				:type T30
					:ref ReturnType
						:param 
							:typeof foo
				:type ReturnType
					:< T
						:=> 
							:infer 
								:< R
							param ...args
								:[ 
									:any 
					:ref R
				:type AnyFunction
					:=> 
						:any 
						param ...args
							:[ 
								:any 
				:type ReturnType
					:< T
						:ref AnyFunction
					:iif 
						:check 
							:ref T
						:extends 
							:=> 
								:infer 
									:< R
								param ...args
									:[ 
										:any 
						:then 
							:ref R
						:else 
							:any 


	item
		title Predefined conditional types
		expected
			+ type T00 = Exclude<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "b" | "d"
			+ type T01 = Extract<"a" | "b" | "c" | "d", "a" | "c" | "f">;  // "a" | "c"
			+ type T02 = Exclude<string | number | (() => void), Function>;  // string | number
			+ type T03 = Extract<string | number | (() => void), Function>;  // () => void
			+ type T04 = NonNullable<string | number | undefined>;  // string | number
			+ type T05 = NonNullable<(() => string) | string[] | null | undefined>;  // (() => string) | string[]
			+ function f1(s: string) {
				+ return { a: 1, b: s }
			+ }
			+ class C {
				+ x = 0;
				+ y = 0;
			+ }
			+ type T10 = ReturnType<() => string>;  // string
			+ type T11 = ReturnType<(s: string) => void>;  // void
			+ type T12 = ReturnType<(<T>() => T)>;  // {}
			+ type T13 = ReturnType<(<T extends U, U extends number[]>() => T)>;  // number[]
			+ type T14 = ReturnType<typeof f1>;  // { a: number, b: string }
			+ type T15 = ReturnType<any>;  // any
			+ type T16 = ReturnType<never>;  // any
			+ type T17 = ReturnType<string>;  // Error
			+ type T18 = ReturnType<Function>;  // Error
			+ type T20 = InstanceType<typeof C>;  // C
			+ type T21 = InstanceType<any>;  // any
			+ type T22 = InstanceType<never>;  // any
			+ type T23 = InstanceType<string>;  // Error
			+ type T24 = InstanceType<Function>;  // Error
		
		ittf
			+
				:type T00
					:ref Exclude
						:param 
							:union 
								:literal "a"
								:literal "b"
								:literal "c"
								:literal "d"
						:param 
							:union 
								:literal "a"
								:literal "c"
								:literal "f"
				:type T01
					:ref Extract
						:param 
							:union 
								:literal "a"
								:literal "b"
								:literal "c"
								:literal "d"
						:param 
							:union 
								:literal "a"
								:literal "c"
								:literal "f"
				:type T02
					:ref Exclude
						:param 
							:union 
								:string 
								:number 
								:paren 
									:=> 
										:void 
						:param 
							:ref Function
				:type T03
					:ref Extract
						:param 
							:union 
								:string 
								:number 
								:paren 
									:=> 
										:void 
						:param 
							:ref Function
				:type T04
					:ref NonNullable
						:param 
							:union 
								:string 
								:number 
								:void 
				:type T05
					:ref NonNullable
						:param 
							:union 
								:paren 
									:=> 
										:string 
								:[ 
									:string 
								:null 
								:void 
				function f1
					param s
						:string 
					return 
						{ 
							@ a 1
							@ b s
				class C
					p x
						:= 0
					p y
						:= 0
				:type T10
					:ref ReturnType
						:param 
							:=> 
								:string 
				:type T11
					:ref ReturnType
						:param 
							:=> 
								:void 
								param s
									:string 
				:type T12
					:ref ReturnType
						:param 
							:paren 
								:=> 
									:< T
									:ref T
				:type T13
					:ref ReturnType
						:param 
							:paren 
								:=> 
									:< T
										:ref U
									:< U
										:[ 
											:number 
									:ref T
				:type T14
					:ref ReturnType
						:param 
							:typeof f1
				:type T15
					:ref ReturnType
						:param any
				:type T16
					:ref ReturnType
						:param never
				:type T17
					:ref ReturnType
						:param string
				:type T18
					:ref ReturnType
						:param 
							:ref Function
				:type T20
					:ref InstanceType
						:param 
							:typeof C
				:type T21
					:ref InstanceType
						:param any
				:type T22
					:ref InstanceType
						:param never
				:type T23
					:ref InstanceType
						:param string
				:type T24
					:ref InstanceType
						:param 
							:ref Function
				# Error


