/*
    artifact generator: C:\My\wizzi\v5\node_modules\wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v5\kernel\wizzi-utils\src\ittf\lib\fs\vfile.js.ittf
*/
'use strict';
// generated by wizzi.codegen.js4.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

/** -àà
     virtual file manager
     WORK IN PROGRESS
*/
var path = require('path');
var iconv = require('iconv-lite');
var async = require('async');
var _ = require('lodash');
var glob = require('../glob');
var verify = require('../verify');
var errors = require('../errors');
var uriParser = require('./uriParser');

var fs;
try {
    // set fs = require('graceful-fs')
    fs = require('fs');
} catch (ex) {
    fs = require('fs');
}


var PATH_SEPARATOR_RE = /[\/\\]/g;
var DEFAULT_DECODING = 'utf8';
var PRESERVE_BOM = false;
var win32 = process.platform === 'win32';

var GET_FILES_DEFAULTS = {
    deep: true, 
    extension: null, 
    documentContent: false
};
var GET_FOLDERS_DEFAULTS = {
    deep: true, 
    tFoldersOnly: false, 
    documentNames: false
};

//
module.exports = function(options, callback) {
    if (typeof callback === 'undefined') {
        if (verify.isObject(options) && verify.isFunction(options.stat)) {
            // options is fsimpl
            // allow this sync call:
            // var file = vfile(fsimpl)
            return new VFile(options);
        }
        else {
            callback = options;
            // not used yet
            options = {};
        }
    }
    if (typeof callback === 'undefined') {
        // allow this sync call defaulting to storeKind 'filesystem'
        // var file = vfile()
        return new VFile(build_default_fsimpl(fs, 'filesystem'));
    }
    if (verify.isObject(options) && verify.isFunction(options.stat)) {
        // options is fsimpl
        return callback(null, new VFile(options));
    }
    else if (verify.isObject(options) && verify.isNotEmpty(options.storeName)) {
        // options has storename for browserFS
        default_fs(options, function(err, fsimpl) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-utils.lib.fs.vfile. Got fsimpl', fsimpl
            callback(null, new VFile(fsimpl));
        });
    }
    else {
        default_fs(function(err, fsimpl) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-utils.lib.fs.vfile. Got fsimpl', fsimpl
            callback(null, new VFile(fsimpl));
        });
    }
};
var VFile = (function () {
    function VFile(fsimpl) {
        _classCallCheck(this, VFile);
        this.fsimpl = fsimpl;
    }
    VFile.prototype.unixifyPath = function(path_string) {
        if (win32) {
            return path_string.replace(/\\/g, '/');
        }
        else {
            return path_string;
        }
    }
    VFile.prototype.close = function() {
        if (this.fsimpl.close) {
            this.fsimpl.close();
        }
    }
    VFile.prototype.stat = function(path_string, callback) {
        return this.fsimpl.stat(path_string, callback);
    }
    VFile.prototype.statSync = function(path_string) {
        return this.fsimpl.statSync(path_string);
    }
    VFile.prototype.lstat = function(path_string, callback) {
        // lstat() is identical to stat(),
        // except that if path is a symbolic link,
        // then the link itself is stat-ed,
        // not the file that it refers to.
        return this.fsimpl.lstat(path_string, callback);
    }
    VFile.prototype.lstatSync = function(path_string) {
        // lstat() is identical to stat(),
        // except that if path is a symbolic link,
        // then the link itself is stat-ed,
        // not the file that it refers to.
        return this.fsimpl.lstatSync(path_string);
    }
    VFile.prototype.unlink = function(path_string, callback) {
        if (verify.isFunction(callback)) {
            return this.fsimpl.unlink(path_string, callback);
        }
        else {
            return this.unlinkSync(path_string);
        }
    }
    VFile.prototype.unlinkSync = function(path_string) {
        return this.fsimpl.unlinkSync(path_string);
    }
    VFile.prototype.rename = function(old_path_string, new_path_string, callback) {
        return this.fsimpl.rename(old_path_string, new_path_string, callback);
    }
    VFile.prototype.renameSync = function(old_path_string, new_path_string, callback) {
        return this.fsimpl.renameSync(old_path_string, new_path_string, callback);
    }
    VFile.prototype.readdir = function(path_string, options, callback) {
        return this.fsimpl.readdir(path_string, options, callback);
    }
    VFile.prototype.readdirSync = function(path_string, options) {
        return this.fsimpl.readdirSync(path_string, options);
    }
    VFile.prototype.read = function(path_string, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        if (!options) {
            options = {
                encoding: DEFAULT_DECODING
            };
        }
        if (verify.isFunction(callback)) {
            return this.readAsync(path_string, options, callback);
        }
        else {
            return this.readSync(path_string, options);
        }
    }
    VFile.prototype.readAsync = function(path_string, options, callback) {
        var parsedUri = uriParser(path_string);
        // read buffer (no options)
        var that = this;
        this.fsimpl.readFile(path_string, function(err, contents) {
            if (err) {
                return callback(err);
            }
            // TODO OLD VIA if parsedUri.storeKind === 'filesystem'
            if (that.fsimpl.kind === 'filesystem') {
                if (options.encoding !== null) {
                    contents = iconv.decode(contents, (options.encoding || DEFAULT_DECODING));
                    if (!PRESERVE_BOM && contents.charCodeAt(0) === 0xFEFF) {
                        contents = contents.substring(1);
                    }
                }
            }
            if (that.fsimpl.kind === 'browser') {
                contents = contents.toString('utf8');
            }
            return callback(null, contents);
        });
    }
    VFile.prototype.readSync = function(path_string, options) {
        if (verify.isFunction(this.fsimpl.readFileSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'readFileSync\'. Unable to execute \'read\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        var parsedUri = uriParser(path_string);
        // read buffer (no options)
        var contents = this.fsimpl.readFileSync(path_string);
        if (this.fsimpl.kind === 'filesystem') {
            if (options.encoding !== null) {
                contents = iconv.decode(contents, (options.encoding || DEFAULT_DECODING));
                if (!PRESERVE_BOM && contents.charCodeAt(0) === 0xFEFF) {
                    contents = contents.substring(1);
                }
            }
        }
        return contents;
    }
    VFile.prototype.write = function(path_string, contents, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        var parsedUri = uriParser(path_string);
        if (!options) {
            options = {};
        }
        // log 'wizzi-utils.vfile.write.contents 1', contents
        if (parsedUri.storeKind === 'filesystem') {
            if (!Buffer.isBuffer(contents)) {
                contents = iconv.encode(contents, (options.encoding || DEFAULT_DECODING));
            }
        }
        // log 'wizzi-utils.vfile.write.contents 2', contents
        if (verify.isFunction(callback)) {
            return this.writeAsync(path_string, contents, options, callback);
        }
        else {
            return this.writeSync(path_string, contents, options);
        }
    }
    VFile.prototype.writeAsync = function(path_string, contents, options, callback) {
        var that = this;
        this.mkpath(path_string, function(err, notUsed) {
            if (err) {
                return callback(err);
            }
            // log 'write async', path_string, that.fsimpl.writeFile, callback
            return that.fsimpl.writeFile(path_string, contents, callback);
        });
    }
    VFile.prototype.writeSync = function(path_string, contents, options) {
        if (verify.isFunction(this.fsimpl.writeFileSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'writeFileSync\'. Unable to execute \'write\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        this.mkpath(path_string);
        try {
            // log 'write sync', path_string, that.fsimpl.writeFile, callback
            this.fsimpl.writeFileSync(path_string, contents);
        } catch (ex) {
            ex.message = 'Writing file ' + path_string + '.\n' + ex.message;
            throw ex;
        }
    }
    VFile.prototype.openWrite = function(path_string, callback) {
        var stream;
        var that = this;
        this.isDirectoryAsync(path_string, function(err, isDirectory) {
            if (err) {
                return callback(err);
            }
            if (isDirectory) {
                return callback(error('VFileError', 'openWrite', 'Write path already exists and is a directory path : ' + path_string));
            }
            that.isFileAsync(path_string, function(err, isFile) {
                if (err) {
                    return callback(err);
                }
                if (isFile) {
                    that.fsimpl.unlink(path_string, function(err, notUsed) {
                        if (err) {
                            return callback(err);
                        }
                        var stream = that.fsimpl.createWriteStream(path_string);
                        if (stream && stream.__is_error) {
                            console.log('__is_error ', stream);
                            return callback(stream);
                        }
                        callback(null, stream);
                    });
                }
                else {
                    that.mkpath(path_string, function(err, notUsed) {
                        if (err) {
                            return callback(err);
                        }
                        var stream = that.fsimpl.createWriteStream(path_string);
                        if (stream && stream.__is_error) {
                            console.log('__is_error ', stream);
                            return callback(stream);
                        }
                        callback(null, stream);
                    });
                }
            });
        });
    }
    VFile.prototype.mkpath = function(path_string, callback) {
        
        // legacy
        if (verify.isFunction(callback)) {
            return this.mkpathAsync(path_string, callback);
        }
        else {
            return this.mkpathSync(path_string);
        }
    }
    VFile.prototype.mkpathAsync = function(path_string, callback) {
        // log 'mkpath async', path_string
        this.ensureParentDir(path_string, callback);
    }
    VFile.prototype.mkpathSync = function(path_string) {
        if (verify.isFunction(this.fsimpl.mkdirSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'mkdirSync\'. Unable to execute \'mkpath\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        // log 'mkpath sync', path_string
        return this.ensureParentDir(path_string);
    }
    VFile.prototype.ensureParentDir = function(path_string, callback) {
        
        if (verify.isFunction(callback)) {
            return this.ensureParentDirAsync(path_string, callback);
        }
        else {
            return this.ensureParentDirSync(path_string);
        }
    }
    VFile.prototype.ensureParentDirAsync = function(path_string, callback) {
        // log 'ensureParentDir', path_string
        var that = this;
        var pathParent = path.dirname(path_string);
        this.isDirectory(pathParent, function(err, result) {
            if (err) {
                return callback(err);
            }
            // log 'ensureParentDir.isDirectory', result, path_string
            if (result == true) {
                return callback(null);
            }
            else {
                that.mkdir(pathParent, callback);
            }
        });
    }
    VFile.prototype.ensureParentDirSync = function(path_string) {
        if (verify.isFunction(this.fsimpl.mkdirSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'mkdirSync\'. Unable to execute \'ensureParentDir\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        var pathParent = path.dirname(path_string);
        if (this.isDirectory(pathParent)) {
            return ;
        }
        else {
            this.mkdir(pathParent);
            this.mkpath(pathParent);
        }
    }
    VFile.prototype.mkdir = function(path_string, callback) {
        
        if (verify.isFunction(callback)) {
            return this.mkdirAsync(path_string, callback);
        }
        else {
            return this.mkdirSync(path_string);
        }
    }
    VFile.prototype.mkdirAsync = function(path_string, callback) {
        var curpath, subpath, parts, len;
        var parsedUri = uriParser(path_string);
        if (parsedUri.protocol === 'db') {
            curpath = parsedUri.protocol + '://' + parsedUri.userId;
            if (parsedUri.projectId) {
                curpath += '/' + parsedUri.projectId;
            }
            // set parts = parsedUri.path.split(PATH_SEPARATOR_RE)
            parts = parsedUri.parts;
        }
        else if (parsedUri.protocol === 'ixdb') {
            curpath = '/' + parsedUri.protocol;
            parts = parsedUri.parts;
        }
        else {
            // set curpath = ''
            // protocol will be the root folder
            curpath = parsedUri.protocol + ':';
            // set parts = path_string.split(PATH_SEPARATOR_RE)
            parts = parsedUri.parts;
        }
        len = parts.length;
        var that = this;
        function repeater(index) {
            if (index === len) {
                return callback(null);
            }
            var part = parts[index];
            // TODO the if has no meaning
            if (parsedUri.protocol === 'db' || parsedUri.protocol === 'ixdb') {
                curpath += '/' + part;
                subpath = curpath;
            }
            else {
                curpath += '/' + part;
                subpath = curpath;
            }
            that.exists(subpath, function(err, exists) {
                if (err) {
                    return callback(err);
                }
                if (!exists) {
                    that.fsimpl.mkdir(subpath, null, function(err, notUsed) {
                        if (err) {
                            return callback(err);
                        }
                        return process.nextTick(function() {
                                repeater(index + 1);
                            });
                    });
                }
                else {
                    return process.nextTick(function() {
                            repeater(index + 1);
                        });
                }
            });
        }
        repeater(0);
    }
    VFile.prototype.mkdirSync = function(path_string) {
        if (verify.isFunction(this.fsimpl.mkdirSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'mkdirSync\'. Unable to execute \'mkdir\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        var that = this;
        path_string.split(PATH_SEPARATOR_RE).reduce(function(parts, part) {
            parts += part + '/';
            var subpath = path.resolve(parts);
            if (!that.exists(subpath)) {
                try {
                    that.fsimpl.mkdirSync(subpath);
                } catch (ex) {
                    throw new errors.FileError('Unable to create directory "' + subpath + '" (Error code: ' + ex.code + ').', ex);
                }
            }
            return parts;
        }, '');
    }
    VFile.prototype.exists = function(path_string, callback) {
        
        if (verify.isFunction(callback)) {
            return this.existsAsync(path_string, callback);
        }
        else {
            return this.existsSync(path_string);
        }
    }
    VFile.prototype.existsAsync = function(path_string, callback) {
        this.fsimpl.stat(path_string, function(err, stats) {
            if (err) {
                if (err.code === 'ENOENT') {
                    return callback(null, false);
                }
                else {
                    return callback(err);
                }
            }
            return callback(null, stats.isDirectory() || stats.isFile());
        });
    }
    VFile.prototype.existsSync = function(path_string) {
        if (verify.isFunction(this.fsimpl.statSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'statSync\'. Unable to execute \'exists\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        try {
            var stats = this.fsimpl.statSync(path_string);
            return stats.isDirectory() || stats.isFile();
        } catch (ex) {
            if (ex.code === 'ENOENT') {
                return false;
            }
            else {
                throw ex;
            }
        }
        return false;
    }
    VFile.prototype.isDirectory = function(path_string, callback) {
        
        if (verify.isFunction(callback)) {
            return this.isDirectoryAsync(path_string, callback);
        }
        else {
            return this.isDirectorySync(path_string);
        }
    }
    VFile.prototype.isDirectoryAsync = function(path_string, callback) {
        this.fsimpl.stat(path_string, function(err, stats) {
            if (err) {
                if (err.code === 'ENOENT') {
                    return callback(null, false);
                }
                else {
                    return callback(err);
                }
            }
            else {
                return callback(null, stats.isDirectory());
            }
        });
    }
    VFile.prototype.isDirectorySync = function(path_string) {
        if (verify.isFunction(this.fsimpl.statSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'statSync\'. Unable to execute \'isDirectory\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        try {
            var stat = this.fsimpl.statSync(path_string);
            return stat.isDirectory();
        } catch (ex) {
            if (ex.code === 'ENOENT') {
                return false;
            }
            else {
                throw ex;
            }
        }
        return false;
    }
    VFile.prototype.isFile = function(path_string, callback) {
        
        if (verify.isFunction(callback)) {
            return this.isFileAsync(path_string, callback);
        }
        else {
            return this.isFileSync(path_string);
        }
    }
    VFile.prototype.isFileAsync = function(path_string, callback) {
        this.fsimpl.stat(path_string, function(err, stats) {
            if (err) {
                if (err.code === 'ENOENT') {
                    return callback(null, false);
                }
                else {
                    return callback(err);
                }
            }
            return callback(null, stats.isFile());
        });
    }
    VFile.prototype.isFileSync = function(path_string) {
        if (verify.isFunction(this.fsimpl.statSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'statSync\'. Unable to execute \'isFile\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        try {
            var stat = this.fsimpl.statSync(path_string);
            return stat.isFile();
        } catch (ex) {
            if (ex.code === 'ENOENT') {
                return false;
            }
            else {
                throw ex;
            }
        }
        return false;
    }
    VFile.prototype.exec_copyFile = function(src, dest, options, callback) {
        if (typeof options === 'function' && !callback) {
            callback = options;
            options = {};
        }
        var that = this;
        this.read(src, function(err, content) {
            if (err) {
                return callback(err);
            }
            that.write(dest, content, callback);
        });
    }
    VFile.prototype.exec_copyFolder = function(src, dest, options, callback) {
        var that = this;
        this.fsimpl.readdir(src, function(err, items) {
            if (err) {
                return callback(err);
            }
            return that.copyFolderItems(items, src, dest, options, callback);
        });
    }
    VFile.prototype.copyFolderItems = function(items, src, dest, options, callback) {
        const item = items.pop();
        if (!item) {
            return callback();
        }
        return this.copyFolderItem(items, item, src, dest, options, callback);
    }
    VFile.prototype.copyFolderItem = function(items, item, src, dest, options, callback) {
        const srcItem = path.join(src, item);
        const destItem = path.join(dest, item);
        var that = this;
        this.isFile(srcItem, function(err, result) {
            if (err) {
                return callback(err);
            }
            if (result == true) {
                that.exec_copyFile(srcItem, destItem, options, function(err, notUsed) {
                    if (err) {
                        return callback(err);
                    }
                    return that.copyFolderItems(items, src, dest, options, callback);
                });
            }
            else {
                that.exec_copyFolder(srcItem, destItem, options, function(err, notUsed) {
                    if (err) {
                        return callback(err);
                    }
                    return that.copyFolderItems(items, src, dest, options, callback);
                });
            }
        });
    }
    VFile.prototype.rimraf = function(path_string, options, callback) {
        if (typeof options === 'function') {
            callback = options;
            options = {};
        }
        var that = this;
        var busyTries = 0;
        this.rimraf_try(path_string, options, function tryCallback(err) {
            if (err) {
                if (err.code === 'EBUSY' || err.code === 'ENOTEMPTY' || err.code === 'EPERM' && busyTries < options.maxBusyTries) {
                    busyTries++;
                    const time = busyTries * 100;
                    // try again, with the same exact callback as this one.
                    return setTimeout(() => {
                            that.rimraf_try(path_string, options, tryCallback);
                        }, time);
                }
                // already gone
                if (err.code === 'ENOENT') {
                    err = null;
                }
            }
            callback(err);
        });
    }
    VFile.prototype.rimraf_try = function(path_string, options, callback) {
        var that = this;
        this.fsimpl.lstat(path_string, function(err, stat) {
            if (err && err.code === 'ENOENT') {
                return callback(null);
            }
            // Windows can EPERM on stat.  Life is suffering.
            if (err && err.code === 'EPERM' && isWindows) {
                return that.rimraf_fixWinEPERM(path_string, options, err, callback);
            }
            if (stat && stat.isDirectory()) {
                return that.rimraf_rmdir(path_string, options, err, callback);
            }
            that.fsimpl.unlink(path_string, function(err, notUsed) {
                if (err) {
                    if (err.code === 'ENOENT') {
                        return callback(null);
                    }
                    if (err.code === 'EPERM') {
                        return isWindows ? that.rimraf_fixWinEPERM(path_string, options, err, callback) : that.rimraf_rmdir(path_string, options, err, callback);
                    }
                    if (err.code === 'EISDIR') {
                        return that.rimraf_rmdir(path_string, options, err, callback);
                    }
                }
                return callback(err);
            });
        });
    }
    VFile.prototype.rimraf_rmdir = function(path_string, options, originalEr, callback) {
        // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
        // if we guessed wrong, and it's not a directory, then
        // raise the original error.
        this.fsimpl.rmdir(path_string, (err) => {
            if (err && (err.code === 'ENOTEMPTY' || err.code === 'EEXIST' || err.code === 'EPERM')) {
                this.rimraf_rmchildren(path_string, options, callback);
            }
            else {
                if (err && err.code === 'ENOTDIR') {
                    callback(originalEr);
                }
                else {
                    callback(err);
                }
            }
        });
    }
    VFile.prototype.rimraf_rmchildren = function(path_string, options, callback) {
        var that = this;
        this.fsimpl.readdir(path_string, function(err, files) {
            if (err) {
                return callback(err);
            }
            var n = files.length;
            var errState;
            if (n === 0) {
                return that.fsimpl.rmdir(path_string, callback);
            }
            files.forEach((file) => {
                that.rimraf(path.join(path_string, file), options, function(err, notUsed) {
                    if (errState) {
                        return ;
                    }
                    if (err) {
                        return callback(errState = err);
                    }
                    if (--n === 0) {
                        that.fsimpl.rmdir(path_string, callback);
                    }
                })});
        });
    }
    VFile.prototype.rimraf_fixWinEPERM = function(path_string, options, tofixErr, callback) {
        var that = this;
        this.fsimpl.chmod(path_string, 438, function(err, notUsed) {
            if (err) {
                callback(err.code === 'ENOENT' ? null : tofixErr);
            }
            else {
                that.fsimpl.stat(path_string, function(err, stats) {
                    if (err) {
                        callback(err.code === 'ENOENT' ? null : tofixErr);
                    }
                    else {
                        if (stats.isDirectory()) {
                            that.rimraf_rmdir(path_string, options, tofixErr, callback);
                        }
                        else {
                            that.fsimpl.unlink(path_string, callback);
                        }
                    }
                });
            }
        });
    }
    VFile.prototype.copyFile = function(path_string, dest, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        options = options || {};
        if (verify.isFunction(callback)) {
            return this.copyFileAsync(path_string, dest, options, callback);
        }
        else {
            return this.copyFileSync(path_string, dest, options);
        }
    }
    VFile.prototype.copyFileAsync = function(path_string, dest, options, callback) {
        var src = path_string;
        var that = this;
        this.isFile(src, function(err, result) {
            if (err) {
                return callback(err);
            }
            if (result == false) {
                return callback(null, new Error(`Source 'Æ{src}' is not a file`));
            }
            that.isFile(dest, function(err, result) {
                if (err) {
                    return callback(err);
                }
                if (result == false) {
                    if (src === dest) {
                        return callback(null, new Error(`Source 'Æ{src}' and destination 'Æ{dest}' are the same file.`));
                    }
                    else {
                        // no need to ensure parent dir
                        // write method always ensures
                        return that.exec_copyFile(src, dest, options, callback);
                    }
                }
                else {
                    if (options && options.overwrite) {
                        that.unlink(dest, function(err, notUsed) {
                            if (err) {
                                return callback(err);
                            }
                            return that.exec_copyFile(src, dest, options, callback);
                        });
                    }
                    else {
                        if (options.errorOnExist) {
                            return callback(null, new Error(`Destination 'Æ{dest}' already exists.`));
                        }
                        else {
                            return callback();
                        }
                    }
                }
            });
        });
    }
    VFile.prototype.copyFileSync = function(path_string, dest, options) {
        if (verify.isFunction(this.fsimpl.writeFileSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'writeFileSync\'. Unable to execute \'copyFile\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        var src = path_string;
        if (this.fsimpl.copyFileSync) {
            return this.fsimpl.copyFileSync(src, dest);
        }
        else {
            throw new Error('Not implemented');
        }
    }
    VFile.prototype.copyFolder = function(path_string, dest, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        options = options || {};
        if (verify.isFunction(callback)) {
            return this.copyFolderAsync(path_string, dest, options, callback);
        }
        else {
            return this.copyFolderSync(path_string, dest, options);
        }
    }
    VFile.prototype.copyFolderAsync = function(path_string, dest, options, callback) {
        var src = path_string;
        var that = this;
        this.isDirectory(src, function(err, result) {
            if (err) {
                return callback(err);
            }
            if (result == false) {
                return callback(null, new Error(`Source 'Æ{src}' is not a directory`));
            }
            that.isDirectory(dest, function(err, result) {
                if (err) {
                    return callback(err);
                }
                if (result == false) {
                    if (isSrcSubdir(src, dest)) {
                        return callback(null, new Error(`Cannot copy source 'Æ{src}' to subdir destination 'Æ{dest}'.`));
                    }
                    else {
                        // no need to ensure parent dir
                        // write method always ensures
                        return that.exec_copyFolder(src, dest, options, callback);
                    }
                }
                else {
                    // do not allow folder overwrite
                    return callback(null, new Error(`Destination 'Æ{dest}' already exists.`));
                }
            });
        });
    }
    VFile.prototype.copyFolderSync = function(path_string, dest, options) {
        if (verify.isFunction(this.fsimpl.writeFileSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'writeFileSync\'. Unable to execute \'copyFolder\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        throw new Error('Not implemented');
    }
    VFile.prototype.moveFile = function(path_string, dest, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        options = options || {};
        if (verify.isFunction(callback)) {
            return this.moveFileAsync(path_string, dest, options, callback);
        }
        else {
            return this.moveFileSync(path_string, dest, options);
        }
    }
    VFile.prototype.moveFileAsync = function(path_string, dest, options, callback) {
        var src = path_string;
        var that = this;
        this.copyFile(src, dest, options, function(err, result) {
            if (err) {
                return callback(err);
            }
            that.unlink(src, callback);
        });
    }
    VFile.prototype.moveFileSync = function(path_string, dest, options) {
        if (verify.isFunction(this.fsimpl.writeFileSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'writeFileSync\'. Unable to execute \'moveFile\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        throw new Error('Not implemented');
    }
    VFile.prototype.moveFolder = function(path_string, dest, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        options = options || {};
        if (verify.isFunction(callback)) {
            return this.moveFolderAsync(path_string, dest, options, callback);
        }
        else {
            return this.moveFolderSync(path_string, dest, options);
        }
    }
    VFile.prototype.moveFolderAsync = function(path_string, dest, options, callback) {
        var src = path_string;
        var that = this;
        this.copyFolder(src, dest, options, function(err, result) {
            if (err) {
                return callback(err);
            }
            that.deleteFolder(src, callback);
        });
    }
    VFile.prototype.moveFolderSync = function(path_string, dest, options) {
        if (verify.isFunction(this.fsimpl.writeFileSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'writeFileSync\'. Unable to execute \'moveFolder\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        throw new Error('Not implemented');
    }
    VFile.prototype.deleteFolder = function(path_string, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        options = options || {};
        if (verify.isFunction(callback)) {
            return this.deleteFolderAsync(path_string, options, callback);
        }
        else {
            return this.deleteFolderSync(path_string, options);
        }
    }
    VFile.prototype.deleteFolderAsync = function(path_string, options, callback) {
        var that = this;
        this.isDirectory(path_string, function(err, result) {
            if (err) {
                return callback(err);
            }
            if (result == false) {
                return callback(null, new Error(`'Æ{path_string}' is not a directory`));
            }
            that.rimraf(path_string, options, callback);
        });
    }
    VFile.prototype.deleteFolderSync = function(path_string, options) {
        if (verify.isFunction(this.fsimpl.rmdir) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'rmdir\'. Unable to execute \'deleteFolder\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        new Error('Not implemented');
    }
    VFile.prototype.readJSON = function(path_string, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        if (verify.isString(options) && verify.isNotEmpty(options)) {
            options = {
                encoding: options
            };
        }
        else {
            options = options || {};
        }
        if (verify.isFunction(callback)) {
            return this.readJSONAsync(path_string, options, callback);
        }
        else {
            return this.readJSONSync(path_string, options);
        }
    }
    VFile.prototype.readJSONAsync = function(path_string, options, callback) {
        this.read(path_string, options, function(err, contents) {
            if (err) {
                return callback(err);
            }
            var result;
            try {
                result = JSON.parse(contents);
            } catch (ex) {
                return callback(new errors.FileError('Unable to JSON parse "' + path_string + '" file (' + ex.message + ').', ex));
            }
            return callback(null, result);
        });
    }
    VFile.prototype.readJSONSync = function(path_string, options) {
        if (verify.isFunction(this.fsimpl.readFileSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'readFileSync\'. Unable to execute \'readJSON\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        try {
            var contents = this.readSync(path_string, options);
            return JSON.parse(contents, options.reviver);
        } catch (ex) {
            if (shouldThrow) {
                throw new errors.FileError('Unable to JSON parse "' + path_string + '" file (' + ex.message + ').', ex);
            }
            else {
                return null;
            }
        }
    }
    VFile.prototype.writeJSON = function(path_string, obj, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        if (verify.isFunction(callback)) {
            return this.writeJSONAsync(path_string, obj, options, callback);
        }
        else {
            return this.writeJSONSync(path_string, obj, options);
        }
    }
    VFile.prototype.writeJSONAsync = function(path_string, obj, options, callback) {
        return this.writeAsync(path_string, stringify(obj, options), options || {}, callback);
    }
    VFile.prototype.writeJSONSync = function(path_string, obj, options) {
        if (verify.isFunction(this.fsimpl.writeFileSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'writeFileSync\'. Unable to execute \'writeJSON\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        return this.writeSync(path_string, stringify(obj, options), options || {});
    }
    VFile.prototype.getFiles = function(path_string, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        options = Object.assign({}, GET_FILES_DEFAULTS, options || {});
        if (verify.isFunction(callback)) {
            return this.getFilesAsync(path_string, options, callback);
        }
        else {
            return this.getFilesSync(path_string, options);
        }
    }
    VFile.prototype.getFilesAsync = function(path_string, options, callback) {
        // log 'wizzi-utils.vfile.getFiles', path_string, options
        var that = this;
        function getItems(callback) {
            that.isDirectory(path_string, function(err, isDirectory) {
                if (err) {
                    return callback(err);
                }
                // log 'wizzi-utils.vfile.getFiles.isDirectory', isDirectory
                if (isDirectory) {
                    var files = [];
                    var relPath = [];
                    that._appendFiles(path_string, files, relPath, options, function(err, notUsed) {
                        if (err) {
                            return callback(err);
                        }
                        // log 'wizzi-utils.vfile.getFiles.after_appendFiles.files', files
                        return callback(null, files);
                    });
                }
                else {
                    that.isFile(path_string, function(err, isFile) {
                        if (err) {
                            return callback(err);
                        }
                        // log 'wizzi-utils.vfile.getFiles.isFile', isFile
                        if (isFile) {
                            return callback(null, [
                                    {
                                        fullPath: unixifyPath(path_string), 
                                        relPath: path.basename(path_string)
                                    }
                                ]);
                        }
                        else {
                            return callback(null, []);
                        }
                    });
                }
            });
        }
        getItems(function(err, items) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-utils.vfile.getFiles.items', items, options.documentContent
            if (options.documentContent) {
                async.map(items, function(item, callback) {
                    that.read(item.fullPath, function(err, content) {
                        if (err) {
                            return callback(err);
                        }
                        return callback(null, {
                                fullPath: item.fullPath, 
                                relPath: item.relPath, 
                                content: content
                            });
                    });
                }, function(err, itemsWithContent) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, itemsWithContent);
                });
            }
            else {
                return callback(null, items);
            }
        });
    }
    VFile.prototype.getFilesSync = function(path_string, options) {
        if (verify.isFunction(this.fsimpl.readdirSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'readdirSync\'. Unable to execute \'getFiles\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        var result;
        if (this.isDirectory(path_string)) {
            var files = [];
            var relPath = [];
            this._appendFiles(path_string, files, relPath, options);
            result = files;
        }
        else if (this.isFile(path_string)) {
            result = [
                {
                    fullPath: unixifyPath(path_string), 
                    relPath: path.basename(path_string)
                }
            ];
        }
        else {
            result = [];
        }
        if (options.documentContent) {
            var resultWithContents = [],
                content;
            var i, i_items=result, i_len=result.length, item;
            for (i=0; i<i_len; i++) {
                item = result[i];
                content = this.read(item.fullPath);
                resultWithContents.push({
                    fullPath: item.fullPath, 
                    relPath: item.relPath, 
                    content: content
                });
            }
            return resultWithContents;
        }
        else {
            return result;
        }
    }
    VFile.prototype._appendFiles = function(path_string, files, relPath, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        if (verify.isFunction(callback)) {
            return this._appendFilesAsync(path_string, files, relPath, options, callback);
        }
        else {
            return this._appendFilesSync(path_string, files, relPath, options);
        }
    }
    VFile.prototype._appendFilesAsync = function(path_string, files, relPath, options, callback) {
        // log 'wizzi-utils.vfile._appendFiles.async.files', files, options
        var that = this;
        this.fsimpl.readdir(path_string, function(err, dir) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-utils.vfile._appendFiles.async.dir', dir
            var folders = [];
            async.map(dir, function(item, callback) {
                var filePath = path.join(path_string, item);
                // log 'wizzi-utils.vfile._appendFiles.filePath', filePath
                that.isDirectory(filePath, function(err, isDirectory) {
                    if (err) {
                        return callback(err);
                    }
                    // log 'wizzi-utils.vfile._appendFiles.async.isDirectory', filePath, isDirectory
                    if (isDirectory) {
                        return callback(null, (options.deep ? item : null ));
                    }
                    else {
                        if (!options.extension || verify.endsWith(item, options.extension)) {
                            files.push({
                                fullPath: filePath, 
                                relPath: unixifyPath(path.join(relPath.join('/'), item))
                            });
                        }
                        return callback(null, null);
                    }
                });
            }, function(err, items) {
                if (err) {
                    return callback(err);
                }
                // log 'wizzi-utils.vfile._appendFiles.async.items', items
                var len = items.length;
                function repeat(index) {
                    if (index == len) {
                        return callback(null);
                    }
                    var item = items[index];
                    // log '*** item', item
                    if (item !== null) {
                        var filePath = path.join(path_string, item);
                        var newRelPath = relPath.slice(0);
                        newRelPath.push(item);
                        // log '*** item', item, filePath
                        that._appendFiles(filePath, files, newRelPath, options, function(err, result) {
                            if (err) {
                                return callback(err);
                            }
                            // log 'wizzi-utils.vfile._appendFiles.deep.async.files', files
                            return repeat(index + 1);
                        });
                    }
                    else {
                        return repeat(index + 1);
                    }
                }
                repeat(0);
            });
        });
    }
    VFile.prototype._appendFilesSync = function(path_string, files, relPath, options) {
        if (verify.isFunction(this.fsimpl.readdirSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'readdirSync\'. Unable to execute \'_appendFiles\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        var dir = this.fsimpl.readdirSync(path_string);
        var folders = [];
        var i, i_items=dir, i_len=dir.length, item;
        for (i=0; i<i_len; i++) {
            item = dir[i];
            var filePath = path.join(path_string, item);
            // log 'wizzi-utils.vfile._appendFiles.filePath', filePath
            if (this.isDirectory(filePath)) {
                if (options.deep) {
                    folders.push(item);
                }
            }
            else {
                if (!options.extension || verify.endsWith(item, options.extension)) {
                    files.push({
                        fullPath: filePath, 
                        relPath: unixifyPath(path.join(relPath.join('/'), item))
                    });
                }
            }
        }
        var i, i_items=folders, i_len=folders.length, item;
        for (i=0; i<i_len; i++) {
            item = folders[i];
            var filePath = path.join(path_string, item);
            var newRelPath = relPath.slice(0);
            newRelPath.push(item);
            this._appendFiles(filePath, files, newRelPath, options);
        }
    }
    VFile.prototype.getFolders = function(path_string, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        options = Object.assign({}, GET_FOLDERS_DEFAULTS, options || {});
        if (verify.isFunction(callback)) {
            return this.getFoldersAsync(path_string, options, callback);
        }
        else {
            return this.getFoldersSync(path_string, options);
        }
    }
    VFile.prototype.getFoldersAsync = function(path_string, options, callback) {
        // log 'wizzi-utils.vfile.getFolders', path_string, options
        var that = this;
        function getItems(callback) {
            that.isDirectory(path_string, function(err, isDirectory) {
                if (err) {
                    return callback(err);
                }
                // log 'wizzi-utils.vfile.getFolders.isDirectory', isDirectory
                if (isDirectory) {
                    var folders = [];
                    var relPath = [];
                    that._appendFolders(path_string, folders, relPath, options, function(err, notUsed) {
                        if (err) {
                            return callback(err);
                        }
                        // log 'wizzi-utils.vfile.getFolders.folders', folders
                        return callback(null, folders);
                    });
                }
                else {
                    return callback(null, []);
                }
            });
        }
        getItems(function(err, items) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-utils.vfile.getFiles.items', items, options.documentNames
            if (options.documentNames) {
                async.map(items, function(item, callback) {
                    if (item !== null) {
                        that.getFiles(item.fullPath, {
                            deep: false
                        }, function(err, files) {
                            if (err) {
                                return callback(err);
                            }
                            return callback(null, {
                                    fullPath: item.fullPath, 
                                    relPath: item.relPath, 
                                    documents: files
                                });
                        });
                    }
                    else {
                        return callback(null, {
                                fullPath: item.fullPath, 
                                relPath: item.relPath
                            });
                    }
                }, function(err, itemsWithNames) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, itemsWithNames);
                });
            }
            else {
                return callback(null, items);
            }
        });
    }
    VFile.prototype.getFoldersSync = function(path_string, options) {
        if (verify.isFunction(this.fsimpl.readdirSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'readdirSync\'. Unable to execute \'getFolders\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        var result;
        if (this.isDirectory(path_string)) {
            var folders = [];
            var relPath = [];
            this._appendFolders(path_string, folders, relPath, options);
            result = folders;
        }
        else {
            result = [];
        }
        if (options.documentNames) {
            var resultWithFileNames = [],
                files;
            var i, i_items=result, i_len=result.length, item;
            for (i=0; i<i_len; i++) {
                item = result[i];
                files = this.getFiles(item.fullPath, {deep: false });
                resultWithFileNames.push({
                    folderFullPath: item.fullPath, 
                    folderRelPath: item.relPath, 
                    documents: files
                });
            }
            return resultWithFileNames;
        }
        else {
            return result;
        }
    }
    VFile.prototype._appendFolders = function(path_string, folders, relPath, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        if (verify.isFunction(callback)) {
            return this._appendFoldersAsync(path_string, folders, relPath, options, callback);
        }
        else {
            return this._appendFoldersSync(path_string, folders, relPath, options);
        }
    }
    VFile.prototype._appendFoldersAsync = function(path_string, folders, relPath, options, callback) {
        var that = this;
        this.fsimpl.readdir(path_string, function(err, dir) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-utils.vfile._appendFolders.dir', dir
            async.map(dir, function(item, callback) {
                var filePath = path.join(path_string, item);
                that.isDirectory(filePath, function(err, isDirectory) {
                    if (err) {
                        return callback(err);
                    }
                    // log 'wizzi-utils.vfile._appendFolders.isDirectory', filePath, isDirectory
                    if (isDirectory) {
                        folders.push({
                            fullPath: filePath, 
                            relPath: unixifyPath(path.join(relPath.join('/'), item))
                        });
                    }
                    callback(null, ( isDirectory && options.deep ? item : null ));
                });
            }, function(err, items) {
                if (err) {
                    return callback(err);
                }
                // log 'wizzi-utils.vfile._appendFolders.async.items, folders', items, folders
                var len = items.length;
                function repeat(index) {
                    if (index == len) {
                        return callback(null);
                    }
                    var item = items[index];
                    if (item !== null) {
                        var filePath = path.join(path_string, item);
                        var newRelPath = relPath.slice(0);
                        newRelPath.push(item);
                        that._appendFolders(filePath, folders, newRelPath, options, function(err, result) {
                            if (err) {
                                return callback(err);
                            }
                            return repeat(index + 1);
                        });
                    }
                    else {
                        return repeat(index + 1);
                    }
                }
                repeat(0);
            });
        });
    }
    VFile.prototype._appendFoldersSync = function(path_string, folders, relPath, options) {
        if (verify.isFunction(this.fsimpl.readdirSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'readdirSync\'. Unable to execute \'_appendFolders\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        var dir = this.fsimpl.readdirSync(path_string);
        var i, i_items=dir, i_len=dir.length, item;
        for (i=0; i<i_len; i++) {
            item = dir[i];
            var filePath = path.join(path_string, item);
            if (this.isDirectory(filePath)) {
                if (options.tFoldersOnly) {
                    if (item.toLowerCase() === 't') {
                        folders.push({
                            fullPath: filePath, 
                            relPath: unixifyPath(path.join(relPath.join('/'), item))
                        });
                        return ;
                    }
                }
                else {
                    folders.push({
                        fullPath: filePath, 
                        relPath: unixifyPath(path.join(relPath.join('/'), item))
                    });
                }
                if (options.deep) {
                    var newRelPath = relPath.slice(0);
                    newRelPath.push(item);
                    this._appendFolders(filePath, folders, newRelPath, options);
                }
            }
        }
    }
    VFile.prototype.getGlobbedFilesEx = function(path_string, options, callback) {
        var options = options || {};
        return this.getGlobbedFiles(path_string, options.removeRoot, options, callback);
    }
    VFile.prototype.getGlobbedFiles = function(path_string, removeRoot, options, callback) {
        
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = null;
        }
        if (verify.isObject(removeRoot)) {
            options = removeRoot;
            removeRoot = options.removeRoot;
        }
        else {
            options = options || {};
        }
        if (verify.isFunction(callback)) {
            return this.getGlobbedFilesAsync(path_string, removeRoot, options, callback);
        }
        else {
            return this.getGlobbedFilesSync(path_string, removeRoot, options);
        }
    }
    VFile.prototype.getGlobbedFilesAsync = function(path_string, removeRoot, options, callback) {
        var urlRegex = new RegExp('^(?:[a-z]+:)?\/\/', 'i');
        var output = [];
        if (verify.isArray(path_string)) {
            async.map(path_string, function(globPattern, callback) {
                this.getGlobbedFilesAsync(globPattern, removeRoot, options, function(err, globbed) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null, globbed);
                });
            }, function(err, globbeds) {
                if (err) {
                    return callback(err);
                }
                var i, i_items=globbeds, i_len=globbeds.length, globbed;
                for (i=0; i<i_len; i++) {
                    globbed = globbeds[i];
                    _.union(output, globbed);
                }
                return callback(null, output);
            });
        }
        else if (verify.isString(path_string)) {
            if (urlRegex.test(path_string)) {
                return callback(null, [
                        path_string
                    ]);
            }
            else {
                // log 'wizzi-utils.fs.vfile.glob.path_string, options', path_string, options
                glob(path_string, this, options, function(err, files) {
                    if (err) {
                        return callback(err);
                    }
                    // log 'wizzi-utils.fs.vfile.glob.after_glob.path_string ', path_string, 'files', files.length
                    if (removeRoot) {
                        // log 'wizzi-utils.fs.vfile.glob.after_glob.removeRoot', removeRoot
                        files = files.map(function(file) {
                            if (_.isArray(removeRoot)) {
                                for (var i in removeRoot) {
                                    file = file.replace(removeRoot[i], '');
                                }
                            }
                            else {
                                // log unixifyPath(file), removeRoot
                                file = unixifyPath(file).replace(unixifyPath(removeRoot), '')
                                ;
                            }
                            return file;
                        });
                        return callback(null, files);
                    }
                    else {
                        return callback(null, files);
                    }
                });
            }
        }
    }
    VFile.prototype.getGlobbedFilesSync = function(path_string, removeRoot, options) {
        if (verify.isFunction(this.fsimpl.readdirSync) === false) {
            throw new errors.FileError('The filesystem implementation does not support method \'readdirSync\'. Unable to execute \'getGlobbedFiles\' method for path: \'' + path_string + '\'');
        }
        var shouldThrow = true;
        if (verify.isObject(options)) {
            shouldThrow = ('throws' in options) ? options.throws : shouldThrow;
        }
        var urlRegex = new RegExp('^(?:[a-z]+:)?\/\/', 'i');
        var output = [];
        if (verify.isArray(path_string)) {
            var i, i_items=path_string, i_len=path_string.length, globPattern;
            for (i=0; i<i_len; i++) {
                globPattern = path_string[i];
                output = _.union(output, this.getGlobbedFiles(globPattern, removeRoot, options));
            }
        }
        else if (verify.isString(path_string)) {
            if (urlRegex.test(path_string)) {
                output.push(path_string);
            }
            else {
                options.sync = true;
                // log 'path_string, options', path_string, options
                var files = glob(path_string, this, options);
                // log 'wizzi-meta.file.path_string ', path_string, 'files', files.length
                if (removeRoot) {
                    // log 'removeRoot', removeRoot
                    files = files.map(function(file) {
                        if (_.isArray(removeRoot)) {
                            for (var i in removeRoot) {
                                file = file.replace(removeRoot[i], '');
                            }
                        }
                        else {
                            // log unixifyPath(file), removeRoot
                            file = unixifyPath(file).replace(unixifyPath(removeRoot), '')
                            ;
                        }
                        return file;
                    });
                }
                output = _.union(output, files);
            }
        }
        return output;
    }
    return VFile;
})();

VFile.prototype.glob = VFile.prototype.getGlobbedFilesEx;
VFile.prototype.globAsync = VFile.prototype.getGlobbedFilesEx;
function unixifyPath(path_string) {
    if (win32) {
        return path_string.replace(/\\/g, '/');
    }
    else {
        return path_string;
    }
}
// return true if dest is a subdir of src, otherwise false.
function isSrcSubdir(src, dest) {
    const srcArray = path.resolve(src).split(path.sep);
    const destArray = path.resolve(dest).split(path.sep);
    return srcArray.reduce((acc, current, i) => {
            return acc && destArray[i] === current;
        }, true);
}
function stringify(obj, options) {
    var spaces;
    var EOL = '\n';
    if (verify.isObject(options)) {
        spaces = options.spaces;
        if (options.EOL) {
            EOL = options.EOL;
        }
    }
    var str = JSON.stringify(obj, options ? options.replacer : null, spaces);
    return str.replace(/\n/g, EOL) + EOL;
}
/** -àà
     The default fsimpl is 'filesystem'
*/
function default_fs(options, callback) {
    if (typeof callback === 'undefined') {
        callback = options;
        options = {};
    }
    return callback(null, build_default_fsimpl(fs, 'filesystem'));
}
function build_default_fsimpl(fs, kind) {
    // lstat() is identical to stat(),
    // except that if path is a symbolic link,
    // then the link itself is stat-ed,
    // not the file that it refers to.
    return {
            kind: kind, 
            stat: fs.stat, 
            statSync: fs.statSync, 
            lstat: fs.lstat, 
            lstatSync: fs.lstatSync, 
            chmod: fs.chmod, 
            chmodSync: fs.chmodSync, 
            exists: fs.exists, 
            existsSync: fs.existsSync, 
            readFile: fs.readFile, 
            readFileSync: fs.readFileSync, 
            writeFile: fs.writeFile, 
            writeFileSync: fs.writeFileSync, 
            readdir: fs.readdir, 
            readdirSync: fs.readdirSync, 
            mkdir: fs.mkdir, 
            mkdirSync: fs.mkdirSync, 
            rmdir: fs.rmdir, 
            rmdirSync: fs.rmdirSync, 
            unlink: fs.unlink, 
            unlinkSync: fs.unlinkSync, 
            rename: fs.rename, 
            renameSync: fs.renameSync, 
            copyFile: fs.copyFile, 
            copyFileSync: fs.copyFileSync, 
            createWriteStream: fs.createWriteStream
        };
}
function error(code, method, message, innerError) {
    var parameter = null;
    if (verify.isObject(message)) {
        parameter = message.parameter;
        message = message.message;
    }
    innerError = innerError || new Error('Error created for trace.');
    return verify.error(innerError, {
            name: verify.isNumber(code) ? 'Err-' + code : code, 
            method: 'wizzi-utils.fs.vfile.' + method, 
            parameter: parameter, 
            sourcePath: __filename
        }, message || 'Error message unavailable');
}
