/*
    artifact generator: C:\My\wizzi\v5\node_modules\wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v5\kernel\wizzi-utils\src\ittf\lib\scanners\ittffsnode.js.ittf
*/
'use strict';
// generated by wizzi.codegen.js4.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var path = require('path');
var async = require('async');
var vfile = require('../fs/vfile');
var verify = require('../verify');
var IttfMTreeEx = require('../ittfTree/ittfMTreeEx');
var ittfHtmlPrettifier = require('../prettifiers/ittfHtmlPrettifier');
var mTreeHtmlPrettifier = require('../prettifiers/mTreeHtmlPrettifier');
/** -àà
    
     File or directory in a folder tree structure of ittf documents.
     Is the result of a folderScanner(folderPath, option) execution.
     Can export its content to a wizzi.utils.ittfMTreeEx, calling
     the method 'toIttf'
     The root node collects mixed or included ittf fragments that are
     outside (up) of root.ittfBasePath.
    
     { IttfFsNode
     { parent
     ref IttfFsNode || null
     string path
     string basename
     string dirname
     boolean isDirectory
     [ parts
     string schema
     # schema of ittf document file
     boolean isFragment
     # ittf document file is inside a t-folder
     boolean isTFolder
     # folder basename is t
     boolean isInsideTFolder
     # folder is descendant of a t-folder
     [ folders
     [ documents
     # if method 'setSourcePaths' is called
     string ittfBasePath
     string jsCodeBasePath
     # if method 'analize' is called
     boolean isTest
     boolean isExample
     boolean isUtil
     boolean isTest
     boolean isJobFolder
     boolean isPackageRoot
    
*/
var IttfFsNode = (function () {
    function IttfFsNode(nodePath, parent, options) {
        _classCallCheck(this, IttfFsNode);
        this.path = unixifyPath(nodePath);
        this.parent = parent;
        this.isDirectory = options.isDirectory;
        this.file = options.file;
        this.isFragment = false;
        this.isExternal = false;
        this.parts = this.path.split('/');
        this.segments = this.parts.slice(0, this.parts.length -1);
        this.basename = this.parts[this.parts.length -1];
        this.dirname = this.segments.join('/');
        if (!options.isDirectory) {
            this.schema = detectSchema(this.basename);
            this.isFragment = isTFragment(this.parts);
        }
        else {
            this.isTFolder = this.basename.toLowerCase() === 't';
            this.isInsideTFolder = isTFragment(this.parts) && (!this.isTFolder);
        }
        this.folders = [];
        this.documents = [];
        this.info = {
            schemas: {}, 
            lib: {
                documents: []
            }, 
            test: {
                documents: []
            }, 
            example: {
                documents: []
            }, 
            util: {
                documents: []
            }
        };
        if (this.parent == null) {
            // mixed or included ittf fragments that are outside (up) of root.ittfBasePath
            this.ittfBasePath = unixifyPath(nodePath);
            this.jsCodeBasePath = null;
            this.externalFragments = [];
            this.externalIttfFsNodes = [];
        }
    }
    IttfFsNode.prototype.root = function() {
        return this.parent == null ? this : this.parent.root();
    }
    IttfFsNode.prototype.setInfo = function() {
        var r = this.root();
        if (r === this) {
            this.setIds();
            this.analize();
        }
        if (!this.isDirectory && !this.isFragment) {
            var schema = r.info.schemas[this.schema];
            if (!schema) {
                schema = {
                    name: this.schema, 
                    documents: []
                };
                r.info.schemas[this.schema] = schema;
                // log 'created schema', schema, r.info.schemas
            }
            else {
                // log 'found', schema, r.info.schemas
            }
            schema.documents.push(this);
            if (this.isTest) {
                r.info.test.documents.push(this);
            }
            else if (this.isExample) {
                r.info.example.documents.push(this);
            }
            else if (this.isUtil) {
                r.info.util.documents.push(this);
            }
            else {
                r.info.lib.documents.push(this);
            }
        }
        if (this.isDirectory) {
            var i, i_items=this.folders, i_len=this.folders.length, folder;
            for (i=0; i<i_len; i++) {
                folder = this.folders[i];
                folder.setInfo();
            }
            var i, i_items=this.documents, i_len=this.documents.length, d;
            for (i=0; i<i_len; i++) {
                d = this.documents[i];
                d.setInfo();
            }
        }
    }
    IttfFsNode.prototype.addDocument = function(relPath, options) {
        //
        // FIXME options.basePath seems not used
        //
        // log 'addDocument relPath', relPath, 'to this.path', this.path
        var r = this.root();
        relPath = unixifyPath(relPath);
        var parts = relPath.split('/');
        // log 'addDocument parts.length', parts.length, 'to this.parts.length', this.parts.length
        if (parts.length <= this.parts.length) {
            return null;
        }
        if (this.match(parts) == false) {
            // log 'addDocument this.match(parts) == false return null'
            return null;
        }
        if (parts.length == this.parts.length + 1) {
            // log 'addDocument could be a document try match'
            if (this.match(parts)) {
                var dnode = new IttfFsNode(relPath, this, {
                    isDirectory: false, 
                    file: r.file
                });
                this.documents.push(dnode);
                // log 'addDocument match ok added document', relPath, 'to', this.path
                return dnode;
            }
            else {
                return null;
            }
        }
        else {
            var subfolderPath = parts.slice(0, this.parts.length + 1).join('/');
            // log 'addDocument try subfolder', subfolderPath
            var added;
            var i, i_items=this.folders, i_len=this.folders.length, f;
            for (i=0; i<i_len; i++) {
                f = this.folders[i];
                if (f.path === subfolderPath) {
                    added = f.addDocument(relPath, options);
                    if (added) {
                        return added;
                    }
                }
            }
            var fnode = new IttfFsNode(subfolderPath, this, {
                isDirectory: true, 
                file: r.file
            });
            this.folders.push(fnode);
            // log 'addDocument created subfolder', subfolderPath
            added = fnode.addDocument(relPath, options);
            return added;
        }
    }
    IttfFsNode.prototype.addExternalDocument = function(fullPath) {
        var r = this.root();
        if (r !== this) {
            throw new Error('wizzi-utils.ittfFsNode.addExternalDocument must be called on root node only.');
        }
        var relPath = path.relative(this.ittfBasePath, fullPath);
        // log 'addExternalDocument.relPath', relPath, 'fullPath', fullPath
        var dnode = this.searchDocument(relPath);
        if (dnode) {
            // log 'addExternalDocument.relPath already exists', relPath,
            return dnode;
        }
        else {
            dnode = new IttfFsNode(relPath, this, {
                isDirectory: false, 
                file: r.file
            });
            dnode.isExternal = true;
            this.documents.push(dnode);
            // log 'addExternalDocument.relPath added', relPath
            return dnode;
        }
    }
    IttfFsNode.prototype.match = function(parts) {
        if (parts.length < this.parts.length) {
            return false;
        }
        var i, i_items=this.parts, i_len=this.parts.length, part;
        for (i=0; i<i_len; i++) {
            part = this.parts[i];
            if (part !== this.parts[i]) {
                return false;
            }
        }
        return true;
    }
    IttfFsNode.prototype.setIds = function(r) {
        if (typeof r === 'undefined') {
            r = this.root();
        }
        if (this === r) {
            this.id = 'root-parent-folder';
        }
        else {
            this.id = r.__getNewId(this.isDirectory);
        }
        if (this.isDirectory) {
            var i, i_items=this.folders, i_len=this.folders.length, folder;
            for (i=0; i<i_len; i++) {
                folder = this.folders[i];
                folder.setIds();
            }
            var i, i_items=this.documents, i_len=this.documents.length, d;
            for (i=0; i<i_len; i++) {
                d = this.documents[i];
                d.setIds();
            }
        }
    }
    // returns
    // fnnn for folders
    // dnnn for documents
    IttfFsNode.prototype.__getNewId = function(isDirectory) {
        if (isDirectory) {
            if (typeof(this.f_idcount) === 'undefined') {
                this.f_idcount = 0;
            }
            return 'f_' + (++this.f_idcount);
        }
        else {
            if (typeof(this.d_idcount) === 'undefined') {
                this.d_idcount = 0;
            }
            return 'd_' + (++this.d_idcount);
        }
    }
    // called for example by folderScanner.scan on the root node
    IttfFsNode.prototype.setSourcePaths = function(options) {
        if (verify.isNotEmpty(options.ittfBasePath)) {
            this.ittfBasePath = unixifyPath(options.ittfBasePath);
        }
        if (verify.isNotEmpty(options.jsCodeBasePath)) {
            this.jsCodeBasePath = unixifyPath(options.jsCodeBasePath);
        }
        // log 'wizzi-utils.ittfFsNode.setSourcePaths - ittfBasePath, jsCodeBasePath : ', options.ittfBasePath, options.jsCodeBasePath
    }
    //
    // FIXME this is NOT OK
    // ittfHtmlPrettifier uses IttfMTreeEx to analize the ittf document and to recognize fragments.
    // That is a scanning operation that must be executed before prettifying.
    //
    IttfFsNode.prototype.getPrettyAnalizedIttfSource = function() {
        var r = this.root();
        // log 'wizzi-utils.ittfFsNode.getPrettyAnalizedIttfSource', r.ittfBasePath, this.parts.join('/')
        if (verify.isNotEmpty(r.ittfBasePath)) {
            return ittfHtmlPrettifier(path.join(r.ittfBasePath, this.parts.join('/')), {
                    ittfFsNode: this, 
                    ittfBasePath: (r.ittfBasePath)
                });
        }
        else {
            return {
                    __is_error: true
                };
        }
    }
    IttfFsNode.prototype.getJsCode = function() {
        var r = this.root();
        // cut '.ittf' from basename
        var name = this.basename.substr(0, this.basename.length - 5);
        // log r.jsCodeBasePath, this.parts.slice(1, this.parts.length -1).join('/'), name
        if (this.schema == 'js') {
            return file.read(path.join(r.jsCodeBasePath, this.parts.slice(2, this.parts.length -1).join('/'), name));
        }
        else {
            return null;
        }
    }
    IttfFsNode.prototype.containsDocument = function(testBaseName) {
        var i, i_items=this.documents, i_len=this.documents.length, d;
        for (i=0; i<i_len; i++) {
            d = this.documents[i];
            if (d.basename === testBaseName) {
                return true;
            }
        }
    }
    IttfFsNode.prototype.containsFolder = function(testBaseName) {
        var i, i_items=this.folders, i_len=this.folders.length, f;
        for (i=0; i<i_len; i++) {
            f = this.folders[i];
            if (f.basename === testBaseName) {
                return true;
            }
        }
    }
    IttfFsNode.prototype.searchDocument = function(dpath) {
        var searchPath = unixifyPath(dpath);
        var r = this.root();
        return r.__searchDocument(searchPath);
    }
    IttfFsNode.prototype.__searchDocument = function(dpath) {
        // log '__searchDocument, this.path, dpath', this.path, dpath
        if (this.path === dpath) {
            return this;
        }
        else {
            var ret = null;
            var i, i_items=this.documents, i_len=this.documents.length, d;
            for (i=0; i<i_len; i++) {
                d = this.documents[i];
                ret = d.__searchDocument(dpath);
                if (ret != null) {
                    return ret;
                }
            }
            var i, i_items=this.folders, i_len=this.folders.length, f;
            for (i=0; i<i_len; i++) {
                f = this.folders[i];
                ret = f.__searchDocument(dpath);
                if (ret != null) {
                    return ret;
                }
            }
        }
        return null;
    }
    IttfFsNode.prototype.analize2 = function(callback) {
        // log 'wizzi-utils.ittfFsNode.analize2.path', this.path
        var r = this.root();
        if (r === this) {
            this.setIds();
        }
        if (this.path.indexOf('/tests/') > -1) {
            this.isTest = true;
        }
        if (this.path.indexOf('/examples/') > -1) {
            this.isExample = true;
        }
        if (this.path.indexOf('/util/') > -1 || this.path.indexOf('/utils/') > -1) {
            this.isUtil = true;
        }
        if (this.containsDocument('generate.wfjob.ittf') && this.containsFolder('ittf')) {
            if (this.isTest || this.isExample) {
                this.isJobFolder = true;
            }
            else {
                this.isPackageRoot = true;
            }
        }
        if (!this.isDirectory && !this.isFragment) {
            var schema = r.info.schemas[this.schema];
            if (!schema) {
                schema = {
                    name: this.schema, 
                    documents: []
                };
                r.info.schemas[this.schema] = schema;
                // log 'created schema', schema, r.info.schemas
            }
            else {
                // log 'found', schema, r.info.schemas
            }
            schema.documents.push(this);
            if (this.isTest) {
                r.info.test.documents.push(this);
            }
            else if (this.isExample) {
                r.info.example.documents.push(this);
            }
            else if (this.isUtil) {
                r.info.util.documents.push(this);
            }
            else {
                r.info.lib.documents.push(this);
            }
        }
        var that = this;
        if (this.isDirectory) {
            async.map(this.folders, function(folder, callback) {
                folder.analize2(callback);
            }, function(err, folderResult) {
                if (err) {
                    return callback(err);
                }
                async.map(that.documents, function(d, callback) {
                    d.analize2(callback);
                }, function(err, dResult) {
                    if (err) {
                        return callback(err);
                    }
                    return callback(null);
                });
            });
        }
        else {
            IttfMTreeEx.createFrom(path.join(r.ittfBasePath, this.parts.join('/')), {
                file: r.file
            }, function(err, mTreeEx) {
                if (err) {
                    return callback(err);
                }
                // log 'wizzi-utils.ittfFsNode.analize2.created mTreeEx'
                var ctx = {
                    fragments: {}, 
                    externalFragments: {}, 
                    ittfReferences: {}, 
                    ittfFsNode: this, 
                    ittfBasePath: r.ittfBasePath
                };
                mTreeEx.analize(ctx, function(err, notUsed) {
                    if (err) {
                        return callback(err);
                    }
                    that.mTreeEx = mTreeEx;
                    that.fragments = ctx.fragments;
                    var max_repeat = 3;
                    function repeat(count) {
                        // log 'wizzi-utils.ittfFsNode.analize2.repeat count', count
                        if (Object.keys(ctx.externalFragments).length < 1 || count > max_repeat) {
                            return callback(null);
                        }
                        async.map(Object.keys(ctx.externalFragments), function(k, callback) {
                            // log 'wizzi-utils.ittfFsNode.analize2.repeat externalFragment', ctx.externalFragments[k].uri
                            var dnode = r.addExternalDocument(ctx.externalFragments[k].uri);
                            // log 'external dnode', dnode
                            dnode.setIds();
                            dnode.analize2(function(err, notUsed) {
                                if (err) {
                                    return callback(err);
                                }
                                ctx.fragments = {};
                                ctx.externalFragments = {};
                                mTreeEx.analize(ctx);
                                this.fragments = ctx.fragments;
                                // log 'wizzi-utils.ittfFsNode.analize2.externalFragments', ctx.externalFragments
                                return callback(null);
                            });
                        }, function(err, result) {
                            if (err) {
                                return callback(err);
                            }
                            repeat(count + 1);
                        });
                    }
                    repeat(1);
                });
            });
        }
    }
    IttfFsNode.prototype.toIttfRoot2 = function(ittf) {
        var kempty = "";
        var kschema = "schema";
        var kfolder = "folder";
        var klib = "lib";
        var kutil = "util";
        var ktest = "test";
        var kexample = "example";
        var r = this;
        var comment = ittf.add('#', '`fs-base-uri` is the dirname of `package-base-uri`' + kempty);
        comment = ittf.add('#', '`rel-dirname(s)` and `rel-uri(s)` of `f` and `d` nodes are relative to `fs-base-uri`' + kempty);
        var fsBaseUri = ittf.add('fs-base-uri', r.ittfBasePath);
        var packageBaseUri = ittf.add('package-base-uri', r.ittfBasePath + '/' + this.basename);
        var gitBaseUri = ittf.add('git-base-uri', r.jsCodeBasePath);
        var inf = ittf.add('fs-info', kempty);
        var dg, t, any;
        for (var k in r.info.schemas) {
            dg = inf.add('d-group', k);
            t = dg.add('type', kschema);
            // foreach d in r.info.schemas[k].documents
            // addset(any, dg, d, d.path)
        }
        if (r.info.lib.documents.length > 0) {
            dg = inf.add('d-group', klib);
            t = dg.add('type', kfolder);
            // foreach d in r.info.lib.documents
            // addset(any, dg, d, d.path)
        }
        if (r.info.util.documents.length > 0) {
            dg = inf.add('d-group', kutil);
            t = dg.add('type', kfolder);
            // foreach d in r.info.util.documents
            // addset(any, dg, d, d.path)
        }
        if (r.info.test.documents.length > 0) {
            dg = inf.add('d-group', ktest);
            t = dg.add('type', kfolder);
            // foreach d in r.info.test.documents
            // addset(any, dg, d, d.path)
        }
        if (r.info.example.documents.length > 0) {
            dg = inf.add('d-group', kexample);
            t = dg.add('type', kfolder);
            // foreach d in r.info.example.documents
            // addset(any, dg, d, d.path)
        }
    }
    IttfFsNode.prototype.toIttf2 = function(ittf) {
        var r = this.root();
        if (r === this) {
            this.toIttfRoot2(ittf);
        }
        var n = ittf.add(this.isDirectory ? 'f' : 'd', this.basename);
        n.add('id', this.id);
        if (this.isDirectory) {
            if (this.isPackageRoot || this.root() === this.parent) {
                n.add('is-package-root');
            }
            if (this.isJobFolder) {
                n.add('is-job-folder');
            }
            if (this.isTFolder) {
                n.add('is-t-folder');
            }
            if (this.isInsideTFolder) {
                n.add('is-inside-t-folder');
            }
        }
        else {
            if (this.isFragment) {
                n.add('is-fragment');
            }
            if (this.isExternal) {
                n.add('is-external');
            }
            var usedFragments = this.mTreeEx.fragments;
            var ittfReferences = this.mTreeEx.ittfReferences;
            var pretty = mTreeHtmlPrettifier(this.mTreeEx);
            if (pretty.__is_error) {
                n.add('ittf', 'Error: not loaded');
            }
            else {
                var ittfSource = n.add('ittf', verify.makeInline(pretty.prettyLines.join('')));
                var r = this.root();
                var ittfBasePath = r.ittfBasePath;
                var i, i_items=Object.keys(usedFragments), i_len=Object.keys(usedFragments).length, item;
                for (i=0; i<i_len; i++) {
                    item = Object.keys(usedFragments)[i];
                    var ittfFragmentsNode = ittfSource.add('fragment', item);
                    ittfFragmentsNode.add('d-id', usedFragments[item].id);
                    ittfFragmentsNode.add('rel-uri', unixifyPath(path.relative(ittfBasePath, usedFragments[item].uri)));
                }
                var i, i_items=Object.keys(ittfReferences), i_len=Object.keys(ittfReferences).length, item;
                for (i=0; i<i_len; i++) {
                    item = Object.keys(ittfReferences)[i];
                    var ittfFragmentsNode = ittfSource.add('reference', item);
                    ittfFragmentsNode.add('d-id', ittfReferences[item].id);
                    ittfFragmentsNode.add('rel-uri', unixifyPath(path.relative(ittfBasePath, ittfReferences[item].uri)));
                }
            }
        }
        if (this.isTest) {
            n.add('is-test');
        }
        if (this.isExample) {
            n.add('is-example');
        }
        if (this.isUtil) {
            n.add('is-util');
        }
        n.add('rel-dirname', this.dirname);
        n.add('rel-uri', this.path);
        if (this.isDirectory) {
            var i, i_items=this.folders, i_len=this.folders.length, f;
            for (i=0; i<i_len; i++) {
                f = this.folders[i];
                f.toIttf2(n);
            }
            var i, i_items=this.documents, i_len=this.documents.length, d;
            for (i=0; i<i_len; i++) {
                d = this.documents[i];
                if (r === this && d.isExternal) {
                    d.toIttf2(ittf);
                }
                else {
                    d.toIttf2(n);
                }
            }
        }
        else {
            n.add('schema', this.schema);
        }
    }
    return IttfFsNode;
})();

function detectSchema(name) {
    var ss = name.split('.');
    if (ss.length > 1) {
        return ss[ss.length -2];
    }
    else {
        return null;
    }
}
function isTFragment(segments) {
    return segments.indexOf('t') > -1;
}
var win32 = process.platform === 'win32';
function unixifyPath(path_string) {
    if (win32) {
        return path_string.replace(/\\/g, '/');
    }
    else {
        return path_string;
    }
}
module.exports = IttfFsNode;
