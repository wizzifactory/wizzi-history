<html><body><table><thead><th>Type</th><th>Bads</th><th>Goods</th></thead><tbody><tr><td>AwaitExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>BindExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>Import</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>Decorator</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DoExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ExportDefaultSpecifier</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ExportNamespaceSpecifier</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ArrayExpression</td><td>10</td><td>12</td><td><pre>return [this];</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>AssignmentExpression</td><td>106</td><td>94</td><td><pre>nodes = this._verifyNodeList(nodes);</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>BinaryExpression</td><td>94</td><td>21</td><td><pre>to = from + i</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>Directive</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DirectiveLiteral</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>BlockStatement</td><td>186</td><td>53</td><td><pre>function _containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>BreakStatement</td><td>0</td><td>2</td><td><pre>// If listening doesn't exist, this object is not currently
// listening to obj. Break out early.
if (!listening) break;</pre></td><td></td></tr><tr><td>CallExpression</td><td>114</td><td>143</td><td><pre>this._assertUnremoved();</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>CatchClause</td><td>2</td><td>1</td><td><pre>try {
  obj.on(name, callback, context);
} catch (e) {
  return e;
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ConditionalExpression</td><td>4</td><td>2</td><td><pre>ids = obj ? [obj._listenId] : _.keys(listeningTo)</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ContinueStatement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DebuggerStatement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DoWhileStatement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>EmptyStatement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ExpressionStatement</td><td>274</td><td>66</td><td><pre>if (this.node) nodes.push(this.node);</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>File</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ForInStatement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ForStatement</td><td>22</td><td>2</td><td><pre>{
  // Handle space-separated event names by delegating them individually.
  for (names = name.split(eventSplitter); i < names.length; i++) {
    events = iteratee(events, names[i], callback, opts);
  }
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>FunctionDeclaration</td><td>20</td><td>2</td><td><pre>export function _containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>FunctionExpression</td><td>64</td><td>23</td><td><pre>Backbone.noConflict = function () {
  root.Backbone = previousBackbone;
  return this;
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>Identifier</td><td>520</td><td>1312</td><td><pre>path as pathCache</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>IfStatement</td><td>128</td><td>21</td><td><pre>{
  if (this.node) nodes.push(this.node);
  this.replaceExpressionWithStatements(nodes);
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>LabeledStatement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>StringLiteral</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>NumericLiteral</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>NullLiteral</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>BooleanLiteral</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>RegExpLiteral</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>LogicalExpression</td><td>66</td><td>24</td><td><pre>isIdentifier = t.isIdentifier(last) || t.isExpressionStatement(last) && t.isIdentifier(last.expression)</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>MemberExpression</td><td>244</td><td>397</td><td><pre>this._assertUnremoved()</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>NewExpression</td><td>6</td><td>4</td><td><pre>throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>Program</td><td>3</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ObjectExpression</td><td>68</td><td>16</td><td><pre>factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$)</pre></td><td><pre>unknown node of type "Property" with constructor "Node"</pre></td></tr><tr><td>ObjectMethod</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ObjectProperty</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>RestElement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ReturnStatement</td><td>62</td><td>38</td><td><pre>{
  return this.parentPath.insertBefore(nodes);
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>SequenceExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>SwitchCase</td><td>20</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>SwitchStatement</td><td>4</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ThisExpression</td><td>2</td><td>184</td><td><pre>this._assertUnremoved</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ThrowStatement</td><td>8</td><td>1</td><td><pre>if (error) throw error; // If the target obj is not Backbone.Events, track events manually.</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>TryStatement</td><td>2</td><td>1</td><td><pre>{
  try {
    obj.on(name, callback, context);
  } catch (e) {
    return e;
  }
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>UnaryExpression</td><td>52</td><td>19</td><td><pre>isIdentifier && !this.isCompletionRecord()</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>UpdateExpression</td><td>20</td><td>11</td><td><pre>for (names = _.keys(name); i < names.length; i++) {
  events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>VariableDeclaration</td><td>218</td><td>13</td><td><pre>{
  const path = this.context.create(this.parent, this.container, to, this.listKey); // While this path may have a context, there is currently no guarantee that the context
  // will be the active context, because `popContext` may leave a final context in place.
  // We should remove this `if` and always push once #4145 has been resolved.

  if (this.context.queue) path.pushContext(this.context);
  paths.push(path);
}</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>VariableDeclarator</td><td>134</td><td>68</td><td><pre>const paths = [];</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>WhileStatement</td><td>8</td><td>1</td><td><pre>default:
  while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);

  return;</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>WithStatement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>AssignmentPattern</td><td>0</td><td>1</td><td><pre>function hoist(scope = this.scope) {
  const hoister = new PathHoister(this, scope);
  return hoister.run();
}</pre></td><td></td></tr><tr><td>ArrayPattern</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ArrowFunctionExpression</td><td>6</td><td>2</td><td><pre>handleResize = () => {
  this.positionDialog();
};</pre></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ClassBody</td><td>6</td><td>0</td><td></td><td><pre>unknown node of type "Property" with constructor "Node"</pre></td></tr><tr><td>ClassDeclaration</td><td>6</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ClassExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ExportAllDeclaration</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ExportDefaultDeclaration</td><td>2</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ExportNamedDeclaration</td><td>22</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ExportSpecifier</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ForOfStatement</td><td>4</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ImportDeclaration</td><td>28</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ImportDefaultSpecifier</td><td>24</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ImportNamespaceSpecifier</td><td>2</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>ImportSpecifier</td><td>4</td><td>0</td><td></td><td><pre>unknown node of type "Literal" with constructor "Node"</pre></td></tr><tr><td>MetaProperty</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ClassMethod</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ObjectPattern</td><td>4</td><td>0</td><td></td><td><pre>unknown node of type "Property" with constructor "Node"</pre></td></tr><tr><td>SpreadElement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>Super</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TaggedTemplateExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TemplateElement</td><td>0</td><td>6</td><td><pre>`Node list ${msg} with the index of ${i} and type of ${type}`</pre></td><td></td></tr><tr><td>TemplateLiteral</td><td>0</td><td>2</td><td><pre>new Error(`Node list ${msg} with the index of ${i} and type of ${type}`)</pre></td><td></td></tr><tr><td>YieldExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>JSXAttribute</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>JSXClosingElement</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>JSXElement</td><td>0</td><td>1</td><td><pre>return <DialogInline {...this.props} />;</pre></td><td></td></tr><tr><td>JSXEmptyExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>JSXExpressionContainer</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>JSXSpreadChild</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>JSXIdentifier</td><td>0</td><td>1</td><td><pre><DialogInline {...this.props} /></pre></td><td></td></tr><tr><td>JSXMemberExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>JSXNamespacedName</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>JSXOpeningElement</td><td>0</td><td>1</td><td><pre><DialogInline {...this.props} /></pre></td><td></td></tr><tr><td>JSXSpreadAttribute</td><td>0</td><td>1</td><td><pre><DialogInline {...this.props} /></pre></td><td></td></tr><tr><td>JSXText</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>Noop</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ParenthesizedExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>AnyTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ArrayTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>BooleanTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>BooleanLiteralTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>NullLiteralTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ClassImplements</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ClassProperty</td><td>24</td><td>0</td><td></td><td><pre>unknown node of type "Property" with constructor "Node"</pre></td></tr><tr><td>DeclareClass</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DeclareFunction</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DeclareInterface</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DeclareModule</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DeclareModuleExports</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DeclareTypeAlias</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>DeclareVariable</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ExistsTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>FunctionTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>FunctionTypeParam</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>GenericTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>InterfaceExtends</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>InterfaceDeclaration</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>IntersectionTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>MixedTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>EmptyTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>NullableTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>NumberLiteralTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>NumberTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>StringLiteralTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>StringTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ThisTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TupleTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TypeofTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TypeAlias</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TypeCastExpression</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TypeParameter</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TypeParameterDeclaration</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>TypeParameterInstantiation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ObjectTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ObjectTypeCallProperty</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ObjectTypeIndexer</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ObjectTypeProperty</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>ObjectTypeSpreadProperty</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>QualifiedTypeIdentifier</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>UnionTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr><tr><td>VoidTypeAnnotation</td><td>0</td><td>0</td><td></td><td></td></tr></tbody></table></body></html>