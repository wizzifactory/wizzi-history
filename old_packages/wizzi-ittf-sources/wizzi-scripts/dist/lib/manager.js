/*
    artifact generator: C:\My\wizzi\v5\node_modules\wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v5\kernel\wizzi-scripts\src\ittf\lib\manager.js.ittf
*/
'use strict';
// generated by wizzi.codegen.js4.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var path = require('path');
var util = require('util');
var cp = require("child_process");
var robocopy = require('robocopy');
var powershell = require('node-powershell');
// var npm = require('npm')
var Manager = (function () {
    function Manager() {
        _classCallCheck(this, Manager);
    }
    Manager.prototype.robocopyExec = function(options, callback) {
        robocopy({
            source: options.source, 
            destination: options.destination, 
            serial: options.serial, 
            files: [
                
            ], 
            copy: {
                subdirs: true, 
                emptySubdirs: true, 
                purge: true, 
                // Mirrors a directory tree (equivalent to copy.emptySubdirs plus copy.purge). [/mir]
                mirror: true, 
                // Moves files, and deletes them from the source after they are copied. [/mov]
                moveFiles: false, 
                // Moves files and directories, and deletes them from the source after they
                // are copied. [/move]
                moveFilesAndDirs: false, 
                // Copies the symbolic link instead of the target. [/sl]
                symbolicLink: false
            }, 
            file: {
                // Excludes files that match the specified names or paths. Note that FileName
                // can include wildcard characters (* and ?). [/xf <FileName>[ ...]]
                excludeFiles: [
                    
                ], 
                // Excludes directories that match the specified names and paths.
                // [/xd <Directory>[ ...]]
                excludeDirs: [
                    
                ]
            }
        }).done(function(stdout) {
            console.log('wizzi-scripts.manager.robocopyExec.stdout', stdout);
            if (callback) {
                return callback(null, {
                        error: false, 
                        stdout: stdout.join('\n')
                    });
            }
        });
    }
    Manager.prototype.robocopyExecToEventStream = function(options, res, callback) {
        this.robocopyExec(options, function(err, result) {
            if (err) {
                return callback(err);
            }
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
            });
            if (result.error) {
                res.write('stderr: ' + result.stderr);
                res.end('data: ***___CLOSE___***\n\n');
            }
            else {
                console.log('wizzi-scripts.robocopyExecToEventStream', result.stdout);
                var str;
                var lines = result.stdout.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    else {
                        // Note: The double-newline is *required*
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
                if (str.length > 0) {
                    res.write('data: ' + str + "\n\n");
                }
                res.end('data: ***___CLOSE___***\n\n');
            }
            if (callback) {
                return callback(null, result);
            }
        });
    }
    Manager.prototype.powershellExec = function(options, callback) {
        var ps = new powershell({
            executionPolicy: 'Bypass', 
            verbose: true, 
            version: 3
        });
        console.log('wizzi-script.manager.powershellExec.options', JSON.stringify(options, null, 2));
        if (options.params) {
            ps.addCommand(options.scriptPath, options.params);
        }
        else {
            ps.addCommand(options.scriptPath);
        }
        ps.invoke().then((output) => {
            console.log(output);
            console.log('wizzi-script.manager.powershellExec.output', output);
            if (callback) {
                return callback(null, {
                        error: false, 
                        stdout: output
                    });
            }
        }).catch((err) => {
            console.log('wizzi-script.manager.powershellExec.err', err);
            ps.dispose();
            if (callback) {
                callback(null, {
                    error: true, 
                    stderr: err
                });
            }
        });
    }
    Manager.prototype.powershellExecToEventStream = function(options, res, callback) {
        this.powershellExec({
            scriptPath: options.scriptPath, 
            params: options.params
        }, function(err, result) {
            if (err) {
                return callback(err);
            }
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
            });
            if (result.error) {
                res.write('stderr: ' + result.stderr);
                res.end('data: ***___CLOSE___***\n\n');
            }
            else {
                var str;
                var lines = result.stdout.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    else {
                        // Note: The double-newline is *required*
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
                res.end('data: ***___CLOSE___***\n\n');
            }
            if (callback) {
                return callback(null, result);
            }
        });
    }
    Manager.prototype.spawnExec = function(options, callback) {
        var res = options.__res;
        if (res) {
            res.writeHead(200, {
                "Content-Type": "text/event-stream", 
                "Cache-control": "no-cache"
            });
        }
        var temp,
            str = "",
            stdout = [],
            sentCallback = false;
        var spw = cp.spawn(options.command, options.args, {
            cwd: options.cwd, 
            env: {
                
            }, 
            argv0: undefined, 
            stdio: undefined, 
            detached: false, 
            shell: options.shell || true, 
            windowsVerbatimArguments: false, 
            windowsHide: false
        });
        spw.stdout.on('data', function(data) {
            temp = data.toString();
            console.log(temp);
            stdout.push(temp);
            if (res) {
                str += temp;
                var lines = str.split("\n");
                for (var i in lines) {
                    if (i == lines.length - 1) {
                        str = lines[i];
                    }
                    else {
                        // Note: The double-newline is *required*
                        res.write('data: ' + lines[i] + "\n\n");
                    }
                }
            }
        });
        spw.on('close', function(code) {
            console.log("close", code);
            if (res) {
                res.write('data: ***___CLOSE___***\n\n');
                res.end(str);
            }
            if (callback && sentCallback == false) {
                sentCallback = true;
                return callback(null, {
                        error: false, 
                        stdout: stdout
                    });
            }
        });
        spw.stderr.on('data', function(data) {
            temp = data.toString();
            console.log("stderr:", temp);
            if (res) {
                res.write('data: ***___CLOSE___***\n\n');
                res.end('stderr: ' + temp);
            }
            if (callback && sentCallback == false) {
                sentCallback = true;
                return callback(null, {
                        error: true, 
                        stderr: temp
                    });
            }
        });
    }
    Manager.prototype.spawnExecToEventStream = function(options, res, callback) {
        options.__res = res;
        this.spawnExec(options, callback);
    }
    Manager.prototype.gitExec = function(options, callback) {
        this.powershellExec({
            scriptPath: options.scriptPath, 
            params: options.params
        }, callback);
    }
    Manager.prototype.gitExecToEventStream = function(options, res, callback) {
        this.powershellExecToEventStream({
            scriptPath: options.scriptPath, 
            params: options.params
        }, res, callback);
    }
    Manager.prototype.nodeJsExec = function(options, callback) {
        var scriptPath = options.scriptPath;
        var scriptArgs = options.args;
        var args = [path.basename(scriptPath)];
        if (scriptArgs && scriptArgs.length > 0) {
            args = args.concat(scriptArgs);
        }
        this.spawnExec({
            command: 'node', 
            cwd: path.dirname(scriptPath), 
            args: args
        }, callback);
    }
    Manager.prototype.nodeJsExecToEventStream = function(options, res, callback) {
        var scriptPath = options.scriptPath;
        var scriptArgs = options.args;
        var args = [path.basename(scriptPath)];
        if (scriptArgs && scriptArgs.length > 0) {
            args = args.concat(scriptArgs);
        }
        this.spawnExecToEventStream({
            command: 'node', 
            cwd: path.dirname(scriptPath), 
            args: args
        }, res, callback);
    }
    return Manager;
})();

module.exports = Manager;
