module
	kind jsfile

	var util = require('util')
	var path = require('path')
	var async = require('async')
	var verify = require('wizzi-utils').verify
	var errors = require('../errors')
	var log = require('../util/log')(module)

	#
		# TODO Check recursion of model contexts

	class wfjob
		#
			# param config {
			#           options: {
			#               verbose:Boolean
			#           }
			#           wfjob: {
			#               src:String
			#           }
			#       }
			#
			# An instance of wfjob prepares the required wizzi packages
			# and the artifact infos of a single wfjob WizziModel, whose source IttfDocument
			# is referenced in config.wfjob.src
			#
			# methods
			#  getArtifactInfoConfigs
			#    called by the production manager
		ctor
			param productionManager
			param config
			set this.productionManager = productionManager
			set this.config = config
			set this.options = config.options
			set this.wfjobSrc = config.wfjob.src
			_ log.setLevel(this.options.verbose || 0)
			set this.initialized = false

		m initialize
			param callback
		
			if this.initialized
				_ return callback(null, this.wfjobModel)

			if this.productionManager.options.trace
				_ log.info('Started initialize. wfjob source: ' + this.wfjobSrc)

			var wfjobFactory = this.productionManager.getLoadModel('wfjob')
			if wfjobFactory == null
				throw errors.NodeError('Factory for schema @wfjob@ not found', null)
		
			var ittfLoadContext
				_ Object.assign
					{
					{
						@ __productionManager this.productionManager
					@ this.productionManager.globalContext()
			
			var self = this
			_ wfjobFactory
				@ this.wfjobSrc
				@ ittfLoadContext
				function
					param err
					param wfjobModel
					if self.productionManager.options.trace
						_ log.info('Job model loaded. err: ' + err)
					if err
						return callback(err, null)
					set self.wfjobModel = wfjobModel
					set self.initialized = true
					if self.productionManager.options.trace
						_ log.info('Done initialize')
					_ callback(null, wfjobModel)

		m getRequiredPackages
			param callback
			var self = this

			_ this.initialize
				function
					param err
					param wfjobModel
					if err
						return callback(err, null)
					
					var result = []
					foreach r in wfjobModel.requires
						_ result.push(r.wzName)

					return callback(null, result)

		m getArtifactInfoConfigs
			param callback
			# log 'wfjob.getArtifactInfoConfigs.start'
			
			var
				decl self = this
				decl artifactInfoConfig
				decl destPath
				decl destFullPath
				decl resultRequires = []
				decl resultArtifactInfos = []
			
			_ this.initialize
				function
					param err
					param wfjobModel
					
					if err
						return callback(err, null)

					foreach require in wfjobModel.requires
						_ resultRequires.push(require.wzName)
					
					#
						# Production structure
						# wfjob
						#      production Collection
						#          attribute destFolder 
						#          lines Collection
						#              attribute cwdFolder
						#              attribute destFolder 
						#              artifacts Collection
						#                  attribute src
						#                    The path to the primary source document of the artifact.
						#                    If relative, the base path is the "cwdFolder" of the parent line.
						#                    If the artifact is a code write artifact the "src" attribute must not be declared.
						#                  attribute destPath
						#                    The artifact source file path "src" is the default relative destination path
						#                    of the generated artifact. When set, this attribute overrides the default.
						#                    It may be an absolute path.
						#                    If the artifact is a code write generation the "destPath" attribute must be declared.
					
					foreach wfjob_production in wfjobModel.productions
						# log 'WizziJob.getArtifactInfoConfigs.production', wfjob_production.wzName, util.inspect(wfjob_production, { depth: 2 })
						
						foreach wfjob_line in wfjob_production.lines
							# log 'WizziJob.getArtifactInfoConfigs.line', wfjob_line.wzName, util.inspect(wfjob_line, { depth: null })
							
							foreach wfjob_artifact in wfjob_line.artifacts
								$$ log 'WizziJob.art', util.inspect(wfjob_artifact, { depth: 1 })
								
								if verify.isEmpty(wfjob_artifact.src)
									#
										# THIS IS A CODEWRITE artifact
										# this artifact is generated by a code write generation
									set artifactInfoConfig
										{
											@ name wfjob_artifact.wzName
											@ options 
												{
											@ contexts
												[
											@ gen
												{
													@ generator wfjob_artifact.generator
											@ dest
												{
													@ baseFolder wfjobModel.destBaseFolder
													@ folder wfjob_line.destFolder || wfjob_production.destFolder
													@ path wfjob_artifact.destPath
													@ extension wfjob_artifact.extension
											@ toString
												function
													return 'Artifact info config: ' + this.name + '/' + this.gen.generator

								
									foreach modelRef in wfjob_artifact.modelRefs
										# log 'WizziJob.getArtifactInfoConfigs.modelRef', modelRef.wzName, modelRef.collName, modelRef.modelCollections.length, util.inspect(modelRef, { depth: 2 })
										var modelInfoConfig = self.createContextModelInfoConfig(modelRef)
										_ artifactInfoConfig.contexts.push(modelInfoConfig)

								else
									
									# This is a WIZZIMODEL artifact or WFJOB artifact
									set artifactInfoConfig
										{
											@ name wfjob_artifact.wzName
											@ options
												{
											@ model
												{
													@ cwd wfjob_line.cwdFolder
													@ src wfjob_artifact.src
													@ ignore wfjob_artifact.ignore
													@ schema wfjob_artifact.schema
													@ format wfjob_artifact.format
													@ isCompile wfjob_artifact.isCompile
													@ contexts
														[
													@ transformers self._getTransformerList(wfjob_artifact.transformers)
											@ isWfJob wfjob_artifact.isWfJob
											@ gen
												{
													@ generator wfjob_artifact.generator
											@ dest
												{
													@ baseFolder wfjobModel.destBaseFolder
													@ folder wfjob_line.destFolder || wfjob_production.destFolder
													@ path wfjob_artifact.destPath
													@ extension wfjob_artifact.extension
											@ toString
												function
													return 'Artifact info config: ' + this.name + '/' + this.model.src + '/' + this.model.schema

								
									# log 'WizziJob.getArtifactInfoConfigs.art', wfjob_artifact.wzName, wfjob_line.srcFolder, wfjob_artifact.src, wfjob_artifact.schema

									foreach modelRef in wfjob_artifact.modelRefs
										# log 'WizziJob.getArtifactInfoConfigs.modelRef', modelRef.wzName, modelRef.collName, modelRef.modelCollections.length, util.inspect(modelRef, { depth: 2 })
										var modelInfoConfig = self.createContextModelInfoConfig(modelRef)
										_ artifactInfoConfig.model.contexts.push(modelInfoConfig);
								
								# log 'WizziJob.artifactInfoConfig', util.inspect(artifactInfoConfig, { depth: 1 })
								_ resultArtifactInfos.push(artifactInfoConfig)
					
					_ callback(null, [resultRequires, resultArtifactInfos]);

		#
			# param modelRef:Object { wfjob:ModelRef
			#           wzName:String // is the key for the wfjob:Model
			#           collName:String
			#           collItemName:String
			#           collPathTemplateValues:Array of {
			#           }
			#       }
		m createContextModelInfoConfig
			param wfjob_modelRef
			# model existence of this.wfjobModel has already been verified loading wfjobModel
			var wfjob_model = this.wfjobModel.getModel(wfjob_modelRef.wzName)
			var modelInfoConfig
				{
					@ exportName wfjob_modelRef.exportName
					@ src this._getModelSrc(wfjob_model.src, wfjob_model)
					@ schema wfjob_model.schema
					@ format wfjob_model.format
					@ isCompile wfjob_model.isCompile
					@ contexts []
					@ transformers this._getTransformerList(wfjob_modelRef.transformers)
					@ coll null
			
			if wfjob_modelRef.collName
				# Single items of a collection contained in a WizziModelInstance may act as data contexts
				# of artifacts where each collection item generates a separate artifact.
				# The coll property specifies:
				# . name                the collection name
				# . itemName            the export name of the collection item when acting as a data context
				# . pathTemplateValues  the property names of the collection item that will be used to build 
				#                       the destination path of the artifact
				set modelInfoConfig.coll
					{
						@ name wfjob_modelRef.collName
						@ itemName wfjob_modelRef.collItemName
						@ pathTemplateValues wfjob_modelRef.collPathTemplateValues
			
			# recurse creation of context modelInfos
			foreach ctxModelRef in wfjob_model.modelRefs
				_ modelInfoConfig.contexts.push(this.createContextModelInfoConfig(ctxModelRef))

			return modelInfoConfig

		m _getModelSrc
			param src
			param node
			#
				# When 'src' is relative, the base path is the 'modelsBaseFolder'
				# declared on the 'wfjob' element.
			if verify.isAbsolutePath(src)
				return src;
			else
				if verify.isString(this.wfjobModel.modelsBaseFolder)
					return path.join(this.wfjobModel.modelsBaseFolder, src)
				else
					log 'wizzi.wfjob.node', node
					throw new errors.NodeError("The src attribute of the model element: " + src + ' is a relative path. A models-base-folder attribute is required on the wfjob element.', node)

		m _getTransformerList
			param transformers
			var ret = []
			foreach item in transformers
				_ ret.push
					{
						@ name item.wzName
						@ dumpFile item.dumpFile
			return ret

	function getPath
		param base
		param src
		return verify.isAbsolutePath(src) ? src : path.join(base, src)

	set module.exports = wfjob;



