<html><head>
<style>
table { border: 1px solid #900;  background: #fff; widht: 100%; }tr {   border: 5px solid #090; }td {   background: #ccc;   padding: 5px 0; vertical-align: top; padding: 10px; }table + table {  border-collapse: collapse;  }.k-code .k-code-ast {  display:none;  }.k-code:hover .k-code-ast {  display:block;  }</style>
</head><body><table><thead><th>Type</th><th>Bads</th><th>Goods</th></thead><tbody><tr style="border-top: 1px solid gray;"><td>AwaitExpression</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>BindExpression</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>Import</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>Decorator</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DoExpression</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ExportDefaultSpecifier</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ExportNamespaceSpecifier</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ArrayExpression</td><td>56</td><td>19</td><td><div class="k-code"><pre>return [this];</pre><div class="k-code-ast"><pre>{
  "type": "ReturnStatement",
  "argument": {
    "type": "ArrayExpression",
    "elements": [
      {
        "type": "ThisExpression"
      }
    ]
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>AssignmentExpression</td><td>148</td><td>106</td><td><div class="k-code"><pre>nodes = this._verifyNodeList(nodes);</pre><div class="k-code-ast"><pre>{
  "type": "ExpressionStatement",
  "expression": {
    "type": "AssignmentExpression",
    "operator": "=",
    "left": {
      "type": "Identifier",
      "name": "nodes"
    },
    "right": {
      "type": "CallExpression",
      "callee": {
        "type": "MemberExpression",
        "object": {
          "type": "ThisExpression"
        },
        "property": {
          "type": "Identifier",
          "name": "_verifyNodeList"
        },
        "computed": false
      },
      "arguments": [
        {
          "type": "Identifier",
          "name": "nodes"
        }
      ]
    }
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>BinaryExpression</td><td>300</td><td>32</td><td><div class="k-code"><pre>to = from + i</pre><div class="k-code-ast"><pre>{
  "type": "VariableDeclarator",
  "id": {
    "type": "Identifier",
    "name": "to"
  },
  "init": {
    "type": "BinaryExpression",
    "left": {
      "type": "Identifier",
      "name": "from"
    },
    "operator": "+",
    "right": {
      "type": "Identifier",
      "name": "i"
    }
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>Directive</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DirectiveLiteral</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>BlockStatement</td><td>252</td><td>71</td><td><div class="k-code"><pre>function _containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}</pre><div class="k-code-ast"><pre>{
  "type": "FunctionDeclaration",
  "id": {
    "type": "Identifier",
    "name": "_containerInsertBefore"
  },
  "generator": false,
  "expression": false,
  "async": false,
  "params": [
    {
      "type": "Identifier",
      "name": "nodes"
    }
  ],
  "body": {
    "type": "BlockStatement",
    "body": [
      {
        "type": "ReturnStatement",
        "argument": {
          "type": "CallExpression",
          "callee": {
            "type": "MemberExpression",
            "object": {
              "type": "ThisExpression"
            },
            "property": {
              "type": "Identifier",
              "name": "_containerInsert"
            },
            "computed": false
          },
          "arguments": [
            {
              "type": "MemberExpression",
              "object": {
                "type": "ThisExpression"
              },
              "property": {
                "type": "Identifier",
                "name": "key"
              },
              "computed": false
            },
            {
              "type": "Identifier",
              "name": "nodes"
            }
          ]
        }
      }
    ]
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>BreakStatement</td><td>4</td><td>3</td><td><div class="k-code"><pre>// If listening doesn't exist, this object is not currently
// listening to obj. Break out early.
if (!listening) break;</pre><div class="k-code-ast"><pre>{
  "type": "IfStatement",
  "test": {
    "type": "UnaryExpression",
    "operator": "!",
    "prefix": true,
    "argument": {
      "type": "Identifier",
      "name": "listening",
      "leadingComments": null
    },
    "extra": {
      "parenthesizedArgument": false
    },
    "leadingComments": null
  },
  "consequent": {
    "type": "BreakStatement",
    "label": null
  },
  "alternate": null,
  "leadingComments": [
    {
      "type": "CommentLine",
      "value": " If listening doesn't exist, this object is not currently"
    },
    {
      "type": "CommentLine",
      "value": " listening to obj. Break out early."
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>CallExpression</td><td>350</td><td>234</td><td><div class="k-code"><pre>this._assertUnremoved();</pre><div class="k-code-ast"><pre>{
  "type": "ExpressionStatement",
  "expression": {
    "type": "CallExpression",
    "callee": {
      "type": "MemberExpression",
      "object": {
        "type": "ThisExpression"
      },
      "property": {
        "type": "Identifier",
        "name": "_assertUnremoved"
      },
      "computed": false
    },
    "arguments": []
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>CatchClause</td><td>2</td><td>1</td><td><div class="k-code"><pre>try {
  obj.on(name, callback, context);
} catch (e) {
  return e;
}</pre><div class="k-code-ast"><pre>{
  "type": "TryStatement",
  "block": {
    "type": "BlockStatement",
    "body": [
      {
        "type": "ExpressionStatement",
        "expression": {
          "type": "CallExpression",
          "callee": {
            "type": "MemberExpression",
            "object": {
              "type": "Identifier",
              "name": "obj"
            },
            "property": {
              "type": "Identifier",
              "name": "on"
            },
            "computed": false
          },
          "arguments": [
            {
              "type": "Identifier",
              "name": "name"
            },
            {
              "type": "Identifier",
              "name": "callback"
            },
            {
              "type": "Identifier",
              "name": "context"
            }
          ]
        }
      }
    ]
  },
  "handler": {
    "type": "CatchClause",
    "param": {
      "type": "Identifier",
      "name": "e"
    },
    "body": {
      "type": "BlockStatement",
      "body": [
        {
          "type": "ReturnStatement",
          "argument": {
            "type": "Identifier",
            "name": "e"
          }
        }
      ]
    }
  },
  "guardedHandlers": [],
  "finalizer": null
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ConditionalExpression</td><td>4</td><td>2</td><td><div class="k-code"><pre>ids = obj ? [obj._listenId] : _.keys(listeningTo)</pre><div class="k-code-ast"><pre>{
  "type": "VariableDeclarator",
  "id": {
    "type": "Identifier",
    "name": "ids"
  },
  "init": {
    "type": "ConditionalExpression",
    "test": {
      "type": "Identifier",
      "name": "obj"
    },
    "consequent": {
      "type": "ArrayExpression",
      "elements": [
        {
          "type": "MemberExpression",
          "object": {
            "type": "Identifier",
            "name": "obj"
          },
          "property": {
            "type": "Identifier",
            "name": "_listenId"
          },
          "computed": false
        }
      ]
    },
    "alternate": {
      "type": "CallExpression",
      "callee": {
        "type": "MemberExpression",
        "object": {
          "type": "Identifier",
          "name": "_"
        },
        "property": {
          "type": "Identifier",
          "name": "keys"
        },
        "computed": false
      },
      "arguments": [
        {
          "type": "Identifier",
          "name": "listeningTo"
        }
      ]
    }
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ContinueStatement</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DebuggerStatement</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DoWhileStatement</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>EmptyStatement</td><td>6</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ExpressionStatement</td><td>654</td><td>90</td><td><div class="k-code"><pre>if (this.node) nodes.push(this.node);</pre><div class="k-code-ast"><pre>{
  "type": "IfStatement",
  "test": {
    "type": "MemberExpression",
    "object": {
      "type": "ThisExpression"
    },
    "property": {
      "type": "Identifier",
      "name": "node"
    },
    "computed": false
  },
  "consequent": {
    "type": "ExpressionStatement",
    "expression": {
      "type": "CallExpression",
      "callee": {
        "type": "MemberExpression",
        "object": {
          "type": "Identifier",
          "name": "nodes"
        },
        "property": {
          "type": "Identifier",
          "name": "push"
        },
        "computed": false
      },
      "arguments": [
        {
          "type": "MemberExpression",
          "object": {
            "type": "ThisExpression"
          },
          "property": {
            "type": "Identifier",
            "name": "node"
          },
          "computed": false
        }
      ]
    }
  },
  "alternate": null
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>File</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ForInStatement</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ForStatement</td><td>32</td><td>2</td><td><div class="k-code"><pre>{
  // Handle space-separated event names by delegating them individually.
  for (names = name.split(eventSplitter); i < names.length; i++) {
    events = iteratee(events, names[i], callback, opts);
  }
}</pre><div class="k-code-ast"><pre>{
  "type": "BlockStatement",
  "body": [
    {
      "type": "ForStatement",
      "init": {
        "type": "AssignmentExpression",
        "operator": "=",
        "left": {
          "type": "Identifier",
          "name": "names",
          "leadingComments": null
        },
        "right": {
          "type": "CallExpression",
          "callee": {
            "type": "MemberExpression",
            "object": {
              "type": "Identifier",
              "name": "name"
            },
            "property": {
              "type": "Identifier",
              "name": "split"
            },
            "computed": false
          },
          "arguments": [
            {
              "type": "Identifier",
              "name": "eventSplitter"
            }
          ]
        },
        "leadingComments": null
      },
      "test": {
        "type": "BinaryExpression",
        "left": {
          "type": "Identifier",
          "name": "i"
        },
        "operator": "<",
        "right": {
          "type": "MemberExpression",
          "object": {
            "type": "Identifier",
            "name": "names"
          },
          "property": {
            "type": "Identifier",
            "name": "length"
          },
          "computed": false
        }
      },
      "update": {
        "type": "UpdateExpression",
        "operator": "++",
        "prefix": false,
        "argument": {
          "type": "Identifier",
          "name": "i"
        }
      },
      "body": {
        "type": "BlockStatement",
        "body": [
          {
            "type": "ExpressionStatement",
            "expression": {
              "type": "AssignmentExpression",
              "operator": "=",
              "left": {
                "type": "Identifier",
                "name": "events"
              },
              "right": {
                "type": "CallExpression",
                "callee": {
                  "type": "Identifier",
                  "name": "iteratee"
                },
                "arguments": [
                  {
                    "type": "Identifier",
                    "name": "events"
                  },
                  {
                    "type": "MemberExpression",
                    "object": {
                      "type": "Identifier",
                      "name": "names"
                    },
                    "property": {
                      "type": "Identifier",
                      "name": "i"
                    },
                    "computed": true
                  },
                  {
                    "type": "Identifier",
                    "name": "callback"
                  },
                  {
                    "type": "Identifier",
                    "name": "opts"
                  }
                ]
              }
            }
          }
        ]
      },
      "leadingComments": [
        {
          "type": "CommentLine",
          "value": " Handle space-separated event names by delegating them individually."
        }
      ]
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>FunctionDeclaration</td><td>54</td><td>4</td><td><div class="k-code"><pre>export function _containerInsertBefore(nodes) {
  return this._containerInsert(this.key, nodes);
}</pre><div class="k-code-ast"><pre>{
  "type": "ExportNamedDeclaration",
  "specifiers": [],
  "source": null,
  "declaration": {
    "type": "FunctionDeclaration",
    "id": {
      "type": "Identifier",
      "name": "_containerInsertBefore"
    },
    "generator": false,
    "expression": false,
    "async": false,
    "params": [
      {
        "type": "Identifier",
        "name": "nodes"
      }
    ],
    "body": {
      "type": "BlockStatement",
      "body": [
        {
          "type": "ReturnStatement",
          "argument": {
            "type": "CallExpression",
            "callee": {
              "type": "MemberExpression",
              "object": {
                "type": "ThisExpression"
              },
              "property": {
                "type": "Identifier",
                "name": "_containerInsert"
              },
              "computed": false
            },
            "arguments": [
              {
                "type": "MemberExpression",
                "object": {
                  "type": "ThisExpression"
                },
                "property": {
                  "type": "Identifier",
                  "name": "key"
                },
                "computed": false
              },
              {
                "type": "Identifier",
                "name": "nodes"
              }
            ]
          }
        }
      ]
    }
  },
  "exportKind": "value"
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>FunctionExpression</td><td>68</td><td>24</td><td><div class="k-code"><pre>Backbone.noConflict = function () {
  root.Backbone = previousBackbone;
  return this;
}</pre><div class="k-code-ast"><pre>{
  "type": "AssignmentExpression",
  "operator": "=",
  "left": {
    "type": "MemberExpression",
    "object": {
      "type": "Identifier",
      "name": "Backbone",
      "leadingComments": null
    },
    "property": {
      "type": "Identifier",
      "name": "noConflict"
    },
    "computed": false,
    "leadingComments": null
  },
  "right": {
    "type": "FunctionExpression",
    "id": null,
    "generator": false,
    "expression": false,
    "async": false,
    "params": [],
    "body": {
      "type": "BlockStatement",
      "body": [
        {
          "type": "ExpressionStatement",
          "expression": {
            "type": "AssignmentExpression",
            "operator": "=",
            "left": {
              "type": "MemberExpression",
              "object": {
                "type": "Identifier",
                "name": "root"
              },
              "property": {
                "type": "Identifier",
                "name": "Backbone"
              },
              "computed": false
            },
            "right": {
              "type": "Identifier",
              "name": "previousBackbone"
            }
          }
        },
        {
          "type": "ReturnStatement",
          "argument": {
            "type": "ThisExpression"
          }
        }
      ]
    }
  },
  "leadingComments": null
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>Identifier</td><td>970</td><td>2057</td><td><div class="k-code"><pre>path as pathCache</pre><div class="k-code-ast"><pre>{
  "type": "ImportSpecifier",
  "imported": {
    "type": "Identifier",
    "name": "path",
    "leadingComments": null
  },
  "importKind": null,
  "local": {
    "type": "Identifier",
    "name": "pathCache"
  },
  "leadingComments": null
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>IfStatement</td><td>140</td><td>21</td><td><div class="k-code"><pre>{
  if (this.node) nodes.push(this.node);
  this.replaceExpressionWithStatements(nodes);
}</pre><div class="k-code-ast"><pre>{
  "type": "BlockStatement",
  "body": [
    {
      "type": "IfStatement",
      "test": {
        "type": "MemberExpression",
        "object": {
          "type": "ThisExpression"
        },
        "property": {
          "type": "Identifier",
          "name": "node"
        },
        "computed": false
      },
      "consequent": {
        "type": "ExpressionStatement",
        "expression": {
          "type": "CallExpression",
          "callee": {
            "type": "MemberExpression",
            "object": {
              "type": "Identifier",
              "name": "nodes"
            },
            "property": {
              "type": "Identifier",
              "name": "push"
            },
            "computed": false
          },
          "arguments": [
            {
              "type": "MemberExpression",
              "object": {
                "type": "ThisExpression"
              },
              "property": {
                "type": "Identifier",
                "name": "node"
              },
              "computed": false
            }
          ]
        }
      },
      "alternate": null
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "CallExpression",
        "callee": {
          "type": "MemberExpression",
          "object": {
            "type": "ThisExpression"
          },
          "property": {
            "type": "Identifier",
            "name": "replaceExpressionWithStatements"
          },
          "computed": false
        },
        "arguments": [
          {
            "type": "Identifier",
            "name": "nodes"
          }
        ]
      }
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>LabeledStatement</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>StringLiteral</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>NumericLiteral</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>NullLiteral</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>BooleanLiteral</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>RegExpLiteral</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>LogicalExpression</td><td>66</td><td>24</td><td><div class="k-code"><pre>isIdentifier = t.isIdentifier(last) || t.isExpressionStatement(last) && t.isIdentifier(last.expression)</pre><div class="k-code-ast"><pre>{
  "type": "VariableDeclarator",
  "id": {
    "type": "Identifier",
    "name": "isIdentifier"
  },
  "init": {
    "type": "LogicalExpression",
    "left": {
      "type": "CallExpression",
      "callee": {
        "type": "MemberExpression",
        "object": {
          "type": "Identifier",
          "name": "t"
        },
        "property": {
          "type": "Identifier",
          "name": "isIdentifier"
        },
        "computed": false
      },
      "arguments": [
        {
          "type": "Identifier",
          "name": "last"
        }
      ]
    },
    "operator": "||",
    "right": {
      "type": "LogicalExpression",
      "left": {
        "type": "CallExpression",
        "callee": {
          "type": "MemberExpression",
          "object": {
            "type": "Identifier",
            "name": "t"
          },
          "property": {
            "type": "Identifier",
            "name": "isExpressionStatement"
          },
          "computed": false
        },
        "arguments": [
          {
            "type": "Identifier",
            "name": "last"
          }
        ]
      },
      "operator": "&&",
      "right": {
        "type": "CallExpression",
        "callee": {
          "type": "MemberExpression",
          "object": {
            "type": "Identifier",
            "name": "t"
          },
          "property": {
            "type": "Identifier",
            "name": "isIdentifier"
          },
          "computed": false
        },
        "arguments": [
          {
            "type": "MemberExpression",
            "object": {
              "type": "Identifier",
              "name": "last"
            },
            "property": {
              "type": "Identifier",
              "name": "expression"
            },
            "computed": false
          }
        ]
      },
      "extra": {
        "parenthesized": true,
        "parenStart": 2724
      }
    }
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>MemberExpression</td><td>478</td><td>521</td><td><div class="k-code"><pre>this._assertUnremoved()</pre><div class="k-code-ast"><pre>{
  "type": "CallExpression",
  "callee": {
    "type": "MemberExpression",
    "object": {
      "type": "ThisExpression"
    },
    "property": {
      "type": "Identifier",
      "name": "_assertUnremoved"
    },
    "computed": false
  },
  "arguments": []
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>NewExpression</td><td>36</td><td>13</td><td><div class="k-code"><pre>throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);</pre><div class="k-code-ast"><pre>{
  "type": "ThrowStatement",
  "argument": {
    "type": "NewExpression",
    "callee": {
      "type": "Identifier",
      "name": "Error"
    },
    "arguments": [
      {
        "type": "TemplateLiteral",
        "expressions": [
          {
            "type": "Identifier",
            "name": "msg"
          },
          {
            "type": "Identifier",
            "name": "i"
          },
          {
            "type": "Identifier",
            "name": "type"
          }
        ],
        "quasis": [
          {
            "type": "TemplateElement",
            "value": {
              "raw": "Node list ",
              "cooked": "Node list "
            },
            "tail": false
          },
          {
            "type": "TemplateElement",
            "value": {
              "raw": " with the index of ",
              "cooked": " with the index of "
            },
            "tail": false
          },
          {
            "type": "TemplateElement",
            "value": {
              "raw": " and type of ",
              "cooked": " and type of "
            },
            "tail": false
          },
          {
            "type": "TemplateElement",
            "value": {
              "raw": "",
              "cooked": ""
            },
            "tail": true
          }
        ]
      }
    ]
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>Program</td><td>90</td><td>1</td><td><div class="k-code"><pre>get`http://example.com/foo?bar=${bar + baz}&quux=${quux}`;</pre><div class="k-code-ast"><pre>{
  "type": "File",
  "program": {
    "type": "Program",
    "sourceType": "module",
    "body": [
      {
        "type": "ExpressionStatement",
        "expression": {
          "type": "TaggedTemplateExpression",
          "tag": {
            "type": "Identifier",
            "name": "get"
          },
          "quasi": {
            "type": "TemplateLiteral",
            "expressions": [
              {
                "type": "BinaryExpression",
                "left": {
                  "type": "Identifier",
                  "name": "bar"
                },
                "operator": "+",
                "right": {
                  "type": "Identifier",
                  "name": "baz"
                }
              },
              {
                "type": "Identifier",
                "name": "quux"
              }
            ],
            "quasis": [
              {
                "type": "TemplateElement",
                "value": {
                  "raw": "http://example.com/foo?bar=",
                  "cooked": "http://example.com/foo?bar="
                },
                "tail": false
              },
              {
                "type": "TemplateElement",
                "value": {
                  "raw": "&quux=",
                  "cooked": "&quux="
                },
                "tail": false
              },
              {
                "type": "TemplateElement",
                "value": {
                  "raw": "",
                  "cooked": ""
                },
                "tail": true
              }
            ]
          }
        }
      }
    ]
  },
  "comments": [],
  "tokens": [
    {
      "type": {
        "label": "name",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      },
      "value": "get"
    },
    {
      "type": {
        "label": "`",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      }
    },
    {
      "type": {
        "label": "template",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "value": "http://example.com/foo?bar="
    },
    {
      "type": {
        "label": "${",
        "beforeExpr": true,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      }
    },
    {
      "type": {
        "label": "name",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      },
      "value": "bar"
    },
    {
      "type": {
        "label": "+/-",
        "beforeExpr": true,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": true,
        "postfix": false,
        "binop": 9,
        "updateContext": null
      },
      "value": "+"
    },
    {
      "type": {
        "label": "name",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      },
      "value": "baz"
    },
    {
      "type": {
        "label": "}",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      }
    },
    {
      "type": {
        "label": "template",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "value": "&quux="
    },
    {
      "type": {
        "label": "${",
        "beforeExpr": true,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      }
    },
    {
      "type": {
        "label": "name",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      },
      "value": "quux"
    },
    {
      "type": {
        "label": "}",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      }
    },
    {
      "type": {
        "label": "template",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      },
      "value": ""
    },
    {
      "type": {
        "label": "`",
        "beforeExpr": false,
        "startsExpr": true,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null
      }
    },
    {
      "type": {
        "label": ";",
        "beforeExpr": true,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      }
    },
    {
      "type": {
        "label": "eof",
        "beforeExpr": false,
        "startsExpr": false,
        "rightAssociative": false,
        "isLoop": false,
        "isAssign": false,
        "prefix": false,
        "postfix": false,
        "binop": null,
        "updateContext": null
      }
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ObjectExpression</td><td>144</td><td>18</td><td><div class="k-code"><pre>factory(root, {}, root._, root.jQuery || root.Zepto || root.ender || root.$)</pre><div class="k-code-ast"><pre>{
  "type": "CallExpression",
  "callee": {
    "type": "Identifier",
    "name": "factory"
  },
  "arguments": [
    {
      "type": "Identifier",
      "name": "root"
    },
    {
      "type": "ObjectExpression",
      "properties": []
    },
    {
      "type": "MemberExpression",
      "object": {
        "type": "Identifier",
        "name": "root"
      },
      "property": {
        "type": "Identifier",
        "name": "_"
      },
      "computed": false
    },
    {
      "type": "LogicalExpression",
      "left": {
        "type": "LogicalExpression",
        "left": {
          "type": "LogicalExpression",
          "left": {
            "type": "MemberExpression",
            "object": {
              "type": "Identifier",
              "name": "root"
            },
            "property": {
              "type": "Identifier",
              "name": "jQuery"
            },
            "computed": false
          },
          "operator": "||",
          "right": {
            "type": "MemberExpression",
            "object": {
              "type": "Identifier",
              "name": "root"
            },
            "property": {
              "type": "Identifier",
              "name": "Zepto"
            },
            "computed": false
          }
        },
        "operator": "||",
        "right": {
          "type": "MemberExpression",
          "object": {
            "type": "Identifier",
            "name": "root"
          },
          "property": {
            "type": "Identifier",
            "name": "ender"
          },
          "computed": false
        }
      },
      "operator": "||",
      "right": {
        "type": "MemberExpression",
        "object": {
          "type": "Identifier",
          "name": "root"
        },
        "property": {
          "type": "Identifier",
          "name": "$"
        },
        "computed": false
      },
      "extra": {
        "parenthesized": true,
        "parenStart": 1308
      }
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ObjectMethod</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ObjectProperty</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>RestElement</td><td>4</td><td>2</td><td><div class="k-code"><pre>function f(x, y, ...a) {
  return (x + y) * a.length;
}</pre><div class="k-code-ast"><pre>{
  "type": "FunctionDeclaration",
  "id": {
    "type": "Identifier",
    "name": "f"
  },
  "generator": false,
  "expression": false,
  "async": false,
  "params": [
    {
      "type": "Identifier",
      "name": "x"
    },
    {
      "type": "Identifier",
      "name": "y"
    },
    {
      "type": "RestElement",
      "argument": {
        "type": "Identifier",
        "name": "a"
      }
    }
  ],
  "body": {
    "type": "BlockStatement",
    "body": [
      {
        "type": "ReturnStatement",
        "argument": {
          "type": "BinaryExpression",
          "left": {
            "type": "BinaryExpression",
            "left": {
              "type": "Identifier",
              "name": "x"
            },
            "operator": "+",
            "right": {
              "type": "Identifier",
              "name": "y"
            },
            "extra": {
              "parenthesized": true,
              "parenStart": 34
            }
          },
          "operator": "*",
          "right": {
            "type": "MemberExpression",
            "object": {
              "type": "Identifier",
              "name": "a"
            },
            "property": {
              "type": "Identifier",
              "name": "length"
            },
            "computed": false
          }
        }
      }
    ]
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ReturnStatement</td><td>76</td><td>44</td><td><div class="k-code"><pre>{
  return this.parentPath.insertBefore(nodes);
}</pre><div class="k-code-ast"><pre>{
  "type": "BlockStatement",
  "body": [
    {
      "type": "ReturnStatement",
      "argument": {
        "type": "CallExpression",
        "callee": {
          "type": "MemberExpression",
          "object": {
            "type": "MemberExpression",
            "object": {
              "type": "ThisExpression"
            },
            "property": {
              "type": "Identifier",
              "name": "parentPath"
            },
            "computed": false
          },
          "property": {
            "type": "Identifier",
            "name": "insertBefore"
          },
          "computed": false
        },
        "arguments": [
          {
            "type": "Identifier",
            "name": "nodes"
          }
        ]
      }
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>SequenceExpression</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>SwitchCase</td><td>20</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>SwitchStatement</td><td>4</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ThisExpression</td><td>2</td><td>187</td><td><div class="k-code"><pre>this._assertUnremoved</pre><div class="k-code-ast"><pre>{
  "type": "MemberExpression",
  "object": {
    "type": "ThisExpression"
  },
  "property": {
    "type": "Identifier",
    "name": "_assertUnremoved"
  },
  "computed": false
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ThrowStatement</td><td>8</td><td>1</td><td><div class="k-code"><pre>if (error) throw error; // If the target obj is not Backbone.Events, track events manually.</pre><div class="k-code-ast"><pre>{
  "type": "IfStatement",
  "test": {
    "type": "Identifier",
    "name": "error"
  },
  "consequent": {
    "type": "ThrowStatement",
    "argument": {
      "type": "Identifier",
      "name": "error"
    },
    "trailingComments": null
  },
  "alternate": null,
  "trailingComments": [
    {
      "type": "CommentLine",
      "value": " If the target obj is not Backbone.Events, track events manually."
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>TryStatement</td><td>2</td><td>1</td><td><div class="k-code"><pre>{
  try {
    obj.on(name, callback, context);
  } catch (e) {
    return e;
  }
}</pre><div class="k-code-ast"><pre>{
  "type": "BlockStatement",
  "body": [
    {
      "type": "TryStatement",
      "block": {
        "type": "BlockStatement",
        "body": [
          {
            "type": "ExpressionStatement",
            "expression": {
              "type": "CallExpression",
              "callee": {
                "type": "MemberExpression",
                "object": {
                  "type": "Identifier",
                  "name": "obj"
                },
                "property": {
                  "type": "Identifier",
                  "name": "on"
                },
                "computed": false
              },
              "arguments": [
                {
                  "type": "Identifier",
                  "name": "name"
                },
                {
                  "type": "Identifier",
                  "name": "callback"
                },
                {
                  "type": "Identifier",
                  "name": "context"
                }
              ]
            }
          }
        ]
      },
      "handler": {
        "type": "CatchClause",
        "param": {
          "type": "Identifier",
          "name": "e"
        },
        "body": {
          "type": "BlockStatement",
          "body": [
            {
              "type": "ReturnStatement",
              "argument": {
                "type": "Identifier",
                "name": "e"
              }
            }
          ]
        }
      },
      "guardedHandlers": [],
      "finalizer": null
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>UnaryExpression</td><td>70</td><td>20</td><td><div class="k-code"><pre>isIdentifier && !this.isCompletionRecord()</pre><div class="k-code-ast"><pre>{
  "type": "LogicalExpression",
  "left": {
    "type": "Identifier",
    "name": "isIdentifier"
  },
  "operator": "&&",
  "right": {
    "type": "UnaryExpression",
    "operator": "!",
    "prefix": true,
    "argument": {
      "type": "CallExpression",
      "callee": {
        "type": "MemberExpression",
        "object": {
          "type": "ThisExpression"
        },
        "property": {
          "type": "Identifier",
          "name": "isCompletionRecord"
        },
        "computed": false
      },
      "arguments": []
    },
    "extra": {
      "parenthesizedArgument": false
    }
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>UpdateExpression</td><td>30</td><td>11</td><td><div class="k-code"><pre>for (names = _.keys(name); i < names.length; i++) {
  events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
}</pre><div class="k-code-ast"><pre>{
  "type": "ForStatement",
  "init": {
    "type": "AssignmentExpression",
    "operator": "=",
    "left": {
      "type": "Identifier",
      "name": "names"
    },
    "right": {
      "type": "CallExpression",
      "callee": {
        "type": "MemberExpression",
        "object": {
          "type": "Identifier",
          "name": "_"
        },
        "property": {
          "type": "Identifier",
          "name": "keys"
        },
        "computed": false
      },
      "arguments": [
        {
          "type": "Identifier",
          "name": "name"
        }
      ]
    }
  },
  "test": {
    "type": "BinaryExpression",
    "left": {
      "type": "Identifier",
      "name": "i"
    },
    "operator": "<",
    "right": {
      "type": "MemberExpression",
      "object": {
        "type": "Identifier",
        "name": "names"
      },
      "property": {
        "type": "Identifier",
        "name": "length"
      },
      "computed": false
    }
  },
  "update": {
    "type": "UpdateExpression",
    "operator": "++",
    "prefix": false,
    "argument": {
      "type": "Identifier",
      "name": "i"
    }
  },
  "body": {
    "type": "BlockStatement",
    "body": [
      {
        "type": "ExpressionStatement",
        "expression": {
          "type": "AssignmentExpression",
          "operator": "=",
          "left": {
            "type": "Identifier",
            "name": "events"
          },
          "right": {
            "type": "CallExpression",
            "callee": {
              "type": "Identifier",
              "name": "eventsApi"
            },
            "arguments": [
              {
                "type": "Identifier",
                "name": "iteratee"
              },
              {
                "type": "Identifier",
                "name": "events"
              },
              {
                "type": "MemberExpression",
                "object": {
                  "type": "Identifier",
                  "name": "names"
                },
                "property": {
                  "type": "Identifier",
                  "name": "i"
                },
                "computed": true
              },
              {
                "type": "MemberExpression",
                "object": {
                  "type": "Identifier",
                  "name": "name"
                },
                "property": {
                  "type": "MemberExpression",
                  "object": {
                    "type": "Identifier",
                    "name": "names"
                  },
                  "property": {
                    "type": "Identifier",
                    "name": "i"
                  },
                  "computed": true
                },
                "computed": true
              },
              {
                "type": "Identifier",
                "name": "opts"
              }
            ]
          }
        }
      }
    ]
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>VariableDeclaration</td><td>444</td><td>17</td><td><div class="k-code"><pre>{
  const path = this.context.create(this.parent, this.container, to, this.listKey); // While this path may have a context, there is currently no guarantee that the context
  // will be the active context, because `popContext` may leave a final context in place.
  // We should remove this `if` and always push once #4145 has been resolved.

  if (this.context.queue) path.pushContext(this.context);
  paths.push(path);
}</pre><div class="k-code-ast"><pre>{
  "type": "BlockStatement",
  "body": [
    {
      "type": "VariableDeclaration",
      "declarations": [
        {
          "type": "VariableDeclarator",
          "id": {
            "type": "Identifier",
            "name": "path"
          },
          "init": {
            "type": "CallExpression",
            "callee": {
              "type": "MemberExpression",
              "object": {
                "type": "MemberExpression",
                "object": {
                  "type": "ThisExpression"
                },
                "property": {
                  "type": "Identifier",
                  "name": "context"
                },
                "computed": false
              },
              "property": {
                "type": "Identifier",
                "name": "create"
              },
              "computed": false
            },
            "arguments": [
              {
                "type": "MemberExpression",
                "object": {
                  "type": "ThisExpression"
                },
                "property": {
                  "type": "Identifier",
                  "name": "parent"
                },
                "computed": false
              },
              {
                "type": "MemberExpression",
                "object": {
                  "type": "ThisExpression"
                },
                "property": {
                  "type": "Identifier",
                  "name": "container"
                },
                "computed": false
              },
              {
                "type": "Identifier",
                "name": "to"
              },
              {
                "type": "MemberExpression",
                "object": {
                  "type": "ThisExpression"
                },
                "property": {
                  "type": "Identifier",
                  "name": "listKey"
                },
                "computed": false
              }
            ]
          }
        }
      ],
      "kind": "const",
      "trailingComments": [
        {
          "type": "CommentLine",
          "value": " While this path may have a context, there is currently no guarantee that the context"
        },
        {
          "type": "CommentLine",
          "value": " will be the active context, because `popContext` may leave a final context in place."
        },
        {
          "type": "CommentLine",
          "value": " We should remove this `if` and always push once #4145 has been resolved."
        }
      ]
    },
    {
      "type": "IfStatement",
      "test": {
        "type": "MemberExpression",
        "object": {
          "type": "MemberExpression",
          "object": {
            "type": "ThisExpression",
            "leadingComments": null
          },
          "property": {
            "type": "Identifier",
            "name": "context"
          },
          "computed": false,
          "leadingComments": null
        },
        "property": {
          "type": "Identifier",
          "name": "queue"
        },
        "computed": false,
        "leadingComments": null
      },
      "consequent": {
        "type": "ExpressionStatement",
        "expression": {
          "type": "CallExpression",
          "callee": {
            "type": "MemberExpression",
            "object": {
              "type": "Identifier",
              "name": "path"
            },
            "property": {
              "type": "Identifier",
              "name": "pushContext"
            },
            "computed": false
          },
          "arguments": [
            {
              "type": "MemberExpression",
              "object": {
                "type": "ThisExpression"
              },
              "property": {
                "type": "Identifier",
                "name": "context"
              },
              "computed": false
            }
          ]
        }
      },
      "alternate": null,
      "leadingComments": [
        {
          "type": "CommentLine",
          "value": " While this path may have a context, there is currently no guarantee that the context"
        },
        {
          "type": "CommentLine",
          "value": " will be the active context, because `popContext` may leave a final context in place."
        },
        {
          "type": "CommentLine",
          "value": " We should remove this `if` and always push once #4145 has been resolved."
        }
      ]
    },
    {
      "type": "ExpressionStatement",
      "expression": {
        "type": "CallExpression",
        "callee": {
          "type": "MemberExpression",
          "object": {
            "type": "Identifier",
            "name": "paths"
          },
          "property": {
            "type": "Identifier",
            "name": "push"
          },
          "computed": false
        },
        "arguments": [
          {
            "type": "Identifier",
            "name": "path"
          }
        ]
      }
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>VariableDeclarator</td><td>296</td><td>110</td><td><div class="k-code"><pre>const paths = [];</pre><div class="k-code-ast"><pre>{
  "type": "VariableDeclaration",
  "declarations": [
    {
      "type": "VariableDeclarator",
      "id": {
        "type": "Identifier",
        "name": "paths"
      },
      "init": {
        "type": "ArrayExpression",
        "elements": []
      }
    }
  ],
  "kind": "const"
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>WhileStatement</td><td>10</td><td>2</td><td><div class="k-code"><pre>default:
  while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);

  return;</pre><div class="k-code-ast"><pre>{
  "type": "SwitchCase",
  "consequent": [
    {
      "type": "WhileStatement",
      "test": {
        "type": "BinaryExpression",
        "left": {
          "type": "UpdateExpression",
          "operator": "++",
          "prefix": true,
          "argument": {
            "type": "Identifier",
            "name": "i"
          },
          "extra": {
            "parenthesizedArgument": false
          }
        },
        "operator": "<",
        "right": {
          "type": "Identifier",
          "name": "l"
        }
      },
      "body": {
        "type": "ExpressionStatement",
        "expression": {
          "type": "CallExpression",
          "callee": {
            "type": "MemberExpression",
            "object": {
              "type": "MemberExpression",
              "object": {
                "type": "AssignmentExpression",
                "operator": "=",
                "left": {
                  "type": "Identifier",
                  "name": "ev"
                },
                "right": {
                  "type": "MemberExpression",
                  "object": {
                    "type": "Identifier",
                    "name": "events"
                  },
                  "property": {
                    "type": "Identifier",
                    "name": "i"
                  },
                  "computed": true
                },
                "extra": {
                  "parenthesized": true,
                  "parenStart": 12472
                }
              },
              "property": {
                "type": "Identifier",
                "name": "callback"
              },
              "computed": false
            },
            "property": {
              "type": "Identifier",
              "name": "apply"
            },
            "computed": false
          },
          "arguments": [
            {
              "type": "MemberExpression",
              "object": {
                "type": "Identifier",
                "name": "ev"
              },
              "property": {
                "type": "Identifier",
                "name": "ctx"
              },
              "computed": false
            },
            {
              "type": "Identifier",
              "name": "args"
            }
          ]
        }
      }
    },
    {
      "type": "ReturnStatement",
      "argument": null
    }
  ],
  "test": null
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>WithStatement</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>AssignmentPattern</td><td>18</td><td>1</td><td><div class="k-code"><pre>function hoist(scope = this.scope) {
  const hoister = new PathHoister(this, scope);
  return hoister.run();
}</pre><div class="k-code-ast"><pre>{
  "type": "FunctionDeclaration",
  "id": {
    "type": "Identifier",
    "name": "hoist",
    "leadingComments": null
  },
  "generator": false,
  "expression": false,
  "async": false,
  "params": [
    {
      "type": "AssignmentPattern",
      "left": {
        "type": "Identifier",
        "name": "scope"
      },
      "right": {
        "type": "MemberExpression",
        "object": {
          "type": "ThisExpression"
        },
        "property": {
          "type": "Identifier",
          "name": "scope"
        },
        "computed": false
      }
    }
  ],
  "body": {
    "type": "BlockStatement",
    "body": [
      {
        "type": "VariableDeclaration",
        "declarations": [
          {
            "type": "VariableDeclarator",
            "id": {
              "type": "Identifier",
              "name": "hoister"
            },
            "init": {
              "type": "NewExpression",
              "callee": {
                "type": "Identifier",
                "name": "PathHoister"
              },
              "arguments": [
                {
                  "type": "ThisExpression"
                },
                {
                  "type": "Identifier",
                  "name": "scope"
                }
              ]
            }
          }
        ],
        "kind": "const"
      },
      {
        "type": "ReturnStatement",
        "argument": {
          "type": "CallExpression",
          "callee": {
            "type": "MemberExpression",
            "object": {
              "type": "Identifier",
              "name": "hoister"
            },
            "property": {
              "type": "Identifier",
              "name": "run"
            },
            "computed": false
          },
          "arguments": []
        }
      }
    ]
  },
  "leadingComments": null
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ArrayPattern</td><td>10</td><td>12</td><td><div class="k-code"><pre>[one, two, three] = foo</pre><div class="k-code-ast"><pre>{
  "type": "VariableDeclarator",
  "id": {
    "type": "ArrayPattern",
    "elements": [
      {
        "type": "Identifier",
        "name": "one"
      },
      {
        "type": "Identifier",
        "name": "two"
      },
      {
        "type": "Identifier",
        "name": "three"
      }
    ]
  },
  "init": {
    "type": "Identifier",
    "name": "foo"
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ArrowFunctionExpression</td><td>36</td><td>11</td><td><div class="k-code"><pre>handleResize = () => {
  this.positionDialog();
};</pre><div class="k-code-ast"><pre>{
  "type": "ClassProperty",
  "static": false,
  "computed": false,
  "key": {
    "type": "Identifier",
    "name": "handleResize"
  },
  "variance": null,
  "value": {
    "type": "ArrowFunctionExpression",
    "id": null,
    "generator": false,
    "expression": false,
    "async": false,
    "params": [],
    "body": {
      "type": "BlockStatement",
      "body": [
        {
          "type": "ExpressionStatement",
          "expression": {
            "type": "CallExpression",
            "callee": {
              "type": "MemberExpression",
              "object": {
                "type": "ThisExpression"
              },
              "property": {
                "type": "Identifier",
                "name": "positionDialog"
              },
              "computed": false
            },
            "arguments": []
          }
        }
      ]
    }
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ClassBody</td><td>38</td><td>1</td><td><div class="k-code"><pre>class Rectangle extends aggregation(Shape, Colored, ZCoord) {}</pre><div class="k-code-ast"><pre>{
  "type": "ClassDeclaration",
  "id": {
    "type": "Identifier",
    "name": "Rectangle"
  },
  "superClass": {
    "type": "CallExpression",
    "callee": {
      "type": "Identifier",
      "name": "aggregation"
    },
    "arguments": [
      {
        "type": "Identifier",
        "name": "Shape"
      },
      {
        "type": "Identifier",
        "name": "Colored"
      },
      {
        "type": "Identifier",
        "name": "ZCoord"
      }
    ]
  },
  "body": {
    "type": "ClassBody",
    "body": []
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>ClassDeclaration</td><td>38</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ClassExpression</td><td>2</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ExportAllDeclaration</td><td>2</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ExportDefaultDeclaration</td><td>4</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ExportNamedDeclaration</td><td>32</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ExportSpecifier</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ForOfStatement</td><td>20</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ImportDeclaration</td><td>50</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ImportDefaultSpecifier</td><td>28</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ImportNamespaceSpecifier</td><td>6</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ImportSpecifier</td><td>26</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>MetaProperty</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ClassMethod</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ObjectPattern</td><td>36</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>SpreadElement</td><td>6</td><td>6</td><td><div class="k-code"><pre>new Date(...dateFields)</pre><div class="k-code-ast"><pre>{
  "type": "NewExpression",
  "callee": {
    "type": "Identifier",
    "name": "Date"
  },
  "arguments": [
    {
      "type": "SpreadElement",
      "argument": {
        "type": "Identifier",
        "name": "dateFields"
      }
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>Super</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>TaggedTemplateExpression</td><td>4</td><td>1</td><td><div class="k-code"><pre>get`http://example.com/foo?bar=${bar + baz}&quux=${quux}`;</pre><div class="k-code-ast"><pre>{
  "type": "ExpressionStatement",
  "expression": {
    "type": "TaggedTemplateExpression",
    "tag": {
      "type": "Identifier",
      "name": "get"
    },
    "quasi": {
      "type": "TemplateLiteral",
      "expressions": [
        {
          "type": "BinaryExpression",
          "left": {
            "type": "Identifier",
            "name": "bar"
          },
          "operator": "+",
          "right": {
            "type": "Identifier",
            "name": "baz"
          }
        },
        {
          "type": "Identifier",
          "name": "quux"
        }
      ],
      "quasis": [
        {
          "type": "TemplateElement",
          "value": {
            "raw": "http://example.com/foo?bar=",
            "cooked": "http://example.com/foo?bar="
          },
          "tail": false
        },
        {
          "type": "TemplateElement",
          "value": {
            "raw": "&quux=",
            "cooked": "&quux="
          },
          "tail": false
        },
        {
          "type": "TemplateElement",
          "value": {
            "raw": "",
            "cooked": ""
          },
          "tail": true
        }
      ]
    }
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>TemplateElement</td><td>8</td><td>25</td><td><div class="k-code"><pre>`Node list ${msg} with the index of ${i} and type of ${type}`</pre><div class="k-code-ast"><pre>{
  "type": "TemplateLiteral",
  "expressions": [
    {
      "type": "Identifier",
      "name": "msg"
    },
    {
      "type": "Identifier",
      "name": "i"
    },
    {
      "type": "Identifier",
      "name": "type"
    }
  ],
  "quasis": [
    {
      "type": "TemplateElement",
      "value": {
        "raw": "Node list ",
        "cooked": "Node list "
      },
      "tail": false
    },
    {
      "type": "TemplateElement",
      "value": {
        "raw": " with the index of ",
        "cooked": " with the index of "
      },
      "tail": false
    },
    {
      "type": "TemplateElement",
      "value": {
        "raw": " and type of ",
        "cooked": " and type of "
      },
      "tail": false
    },
    {
      "type": "TemplateElement",
      "value": {
        "raw": "",
        "cooked": ""
      },
      "tail": true
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>TemplateLiteral</td><td>4</td><td>8</td><td><div class="k-code"><pre>new Error(`Node list ${msg} with the index of ${i} and type of ${type}`)</pre><div class="k-code-ast"><pre>{
  "type": "NewExpression",
  "callee": {
    "type": "Identifier",
    "name": "Error"
  },
  "arguments": [
    {
      "type": "TemplateLiteral",
      "expressions": [
        {
          "type": "Identifier",
          "name": "msg"
        },
        {
          "type": "Identifier",
          "name": "i"
        },
        {
          "type": "Identifier",
          "name": "type"
        }
      ],
      "quasis": [
        {
          "type": "TemplateElement",
          "value": {
            "raw": "Node list ",
            "cooked": "Node list "
          },
          "tail": false
        },
        {
          "type": "TemplateElement",
          "value": {
            "raw": " with the index of ",
            "cooked": " with the index of "
          },
          "tail": false
        },
        {
          "type": "TemplateElement",
          "value": {
            "raw": " and type of ",
            "cooked": " and type of "
          },
          "tail": false
        },
        {
          "type": "TemplateElement",
          "value": {
            "raw": "",
            "cooked": ""
          },
          "tail": true
        }
      ]
    }
  ]
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>YieldExpression</td><td>0</td><td>2</td><td><div class="k-code"><pre>yield start;</pre><div class="k-code-ast"><pre>{
  "type": "ExpressionStatement",
  "expression": {
    "type": "YieldExpression",
    "delegate": false,
    "argument": {
      "type": "Identifier",
      "name": "start"
    }
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>JSXAttribute</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>JSXClosingElement</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>JSXElement</td><td>0</td><td>1</td><td><div class="k-code"><pre>return <DialogInline {...this.props} />;</pre><div class="k-code-ast"><pre>{
  "type": "ReturnStatement",
  "argument": {
    "type": "JSXElement",
    "openingElement": {
      "type": "JSXOpeningElement",
      "attributes": [
        {
          "type": "JSXSpreadAttribute",
          "argument": {
            "type": "MemberExpression",
            "object": {
              "type": "ThisExpression"
            },
            "property": {
              "type": "Identifier",
              "name": "props"
            },
            "computed": false
          }
        }
      ],
      "name": {
        "type": "JSXIdentifier",
        "name": "DialogInline"
      },
      "selfClosing": true
    },
    "closingElement": null,
    "children": [],
    "extra": {
      "parenthesized": true,
      "parenStart": 13247
    }
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>JSXEmptyExpression</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>JSXExpressionContainer</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>JSXSpreadChild</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>JSXIdentifier</td><td>0</td><td>1</td><td><div class="k-code"><pre><DialogInline {...this.props} /></pre><div class="k-code-ast"><pre>{
  "type": "JSXOpeningElement",
  "attributes": [
    {
      "type": "JSXSpreadAttribute",
      "argument": {
        "type": "MemberExpression",
        "object": {
          "type": "ThisExpression"
        },
        "property": {
          "type": "Identifier",
          "name": "props"
        },
        "computed": false
      }
    }
  ],
  "name": {
    "type": "JSXIdentifier",
    "name": "DialogInline"
  },
  "selfClosing": true
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>JSXMemberExpression</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>JSXNamespacedName</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>JSXOpeningElement</td><td>0</td><td>1</td><td><div class="k-code"><pre><DialogInline {...this.props} /></pre><div class="k-code-ast"><pre>{
  "type": "JSXElement",
  "openingElement": {
    "type": "JSXOpeningElement",
    "attributes": [
      {
        "type": "JSXSpreadAttribute",
        "argument": {
          "type": "MemberExpression",
          "object": {
            "type": "ThisExpression"
          },
          "property": {
            "type": "Identifier",
            "name": "props"
          },
          "computed": false
        }
      }
    ],
    "name": {
      "type": "JSXIdentifier",
      "name": "DialogInline"
    },
    "selfClosing": true
  },
  "closingElement": null,
  "children": [],
  "extra": {
    "parenthesized": true,
    "parenStart": 13247
  }
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>JSXSpreadAttribute</td><td>0</td><td>1</td><td><div class="k-code"><pre><DialogInline {...this.props} /></pre><div class="k-code-ast"><pre>{
  "type": "JSXOpeningElement",
  "attributes": [
    {
      "type": "JSXSpreadAttribute",
      "argument": {
        "type": "MemberExpression",
        "object": {
          "type": "ThisExpression"
        },
        "property": {
          "type": "Identifier",
          "name": "props"
        },
        "computed": false
      }
    }
  ],
  "name": {
    "type": "JSXIdentifier",
    "name": "DialogInline"
  },
  "selfClosing": true
}</pre></div></div></td></tr><tr style="border-top: 1px solid gray;"><td>JSXText</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>Noop</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ParenthesizedExpression</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>AnyTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ArrayTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>BooleanTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>BooleanLiteralTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>NullLiteralTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ClassImplements</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ClassProperty</td><td>24</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DeclareClass</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DeclareFunction</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DeclareInterface</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DeclareModule</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DeclareModuleExports</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DeclareTypeAlias</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>DeclareVariable</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ExistsTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>FunctionTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>FunctionTypeParam</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>GenericTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>InterfaceExtends</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>InterfaceDeclaration</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>IntersectionTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>MixedTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>EmptyTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>NullableTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>NumberLiteralTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>NumberTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>StringLiteralTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>StringTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ThisTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>TupleTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>TypeofTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>TypeAlias</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>TypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>TypeCastExpression</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>TypeParameter</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>TypeParameterDeclaration</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>TypeParameterInstantiation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ObjectTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ObjectTypeCallProperty</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ObjectTypeIndexer</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ObjectTypeProperty</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>ObjectTypeSpreadProperty</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>QualifiedTypeIdentifier</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>UnionTypeAnnotation</td><td>0</td><td>0</td><td></td></tr><tr style="border-top: 1px solid gray;"><td>VoidTypeAnnotation</td><td>0</td><td>0</td><td></td></tr></tbody></table></body></html>