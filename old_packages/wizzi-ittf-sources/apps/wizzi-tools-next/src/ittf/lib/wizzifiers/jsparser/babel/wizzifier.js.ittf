container()

	f( File, skip
		f_p( program
		f_a( comments

	f( Program, skip
		# s( sourceType, "script" | "module"
		f_a( directives, true, Directive
		f_a( body

	f( Identifier, ident;is-text
		name( name
		# An identifier. Note that an identifier may be an expression or a destructuring pattern.
		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if node.extra && node.extra.parenthesized == true
				set ret.tag = '('
			else
				set ret.tag = '+'

	f( PrivateName
		f_p_name( Identifier
		# A Private Name Identifier.

	f( RegExpLiteral, literal;is-text
		set ret.name = '/' + node.pattern + '/'
		if node.flags && node.flags.length > 0
			set ret.name += node.flags
			log '*************** RegExpLiteral.ret.name', ret.name
		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if node.extra && node.extra.parenthesized == true
				set ret.tag = '('
			else
				set ret.tag = '+'

	f( NullLiteral, literal;is-text
		set ret.name = 'null'
		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if node.extra && node.extra.parenthesized == true
				set ret.tag = '('
			else
				set ret.tag = '+'

	f( StringLiteral, literal;is-text
		set ret.name = node.extra.raw
		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if node.extra && node.extra.parenthesized == true
				set ret.tag = '('
			else
				set ret.tag = '+'
		
	f( BooleanLiteral, literal;is-text
		name( value, boolean
		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if node.extra && node.extra.parenthesized == true
				set ret.tag = '('
			else
				set ret.tag = '+'

	f( NumericLiteral, literal;is-text
		name( value, numeric
		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if node.extra && node.extra.parenthesized == true
				set ret.tag = '('
			else
				set ret.tag = '+'

	f( Function, function
		# A function [declaration](#functiondeclaration) or [expression](#functionexpression).
		f_p_name(id, Identifier | null
		f_a_in_tag( params, params
		_ processParams(ret)
		# [ Pattern ]
		f_p( body )
		# b( generator
		# b( async
		# VIA
			_ replaceChildrenOfChildWhenText
				@ ret
				@ getChildPosByTag(ret, 'params')
				@ 'param'
		if node.generator
			set ret.tag = 'function*'
		if node.async
			set ret.tag = 'async-function'
		
	f( ExpressionStatement, stm
		# An expression statement, i.e., a statement consisting of a single expression.
		f_p( expression )
		if replaceWithSingleChild(ret, 'set')
		else
			_ replaceWithSingleChild(ret, '_')

	f( BlockStatement, block;skip
		f_a( body
		f_a( directives
		# A block statement, i.e., a sequence of statements surrounded by braces.

    f( EmptyStatement, ;
		# An empty statement, i.e., a solitary semicolon.

    f( DebuggerStatement, debugger
		# A `debugger` statement.

    f( WithStatement, with
		f_p( object, true, Expression
		f_p( body
		# A `with` statement.

	f( ReturnStatement, return
		f_p( argument, false, Expression | null
		get_text_from_1_children(  )
		log 'ReturnStatement', ret

    f( LabeledStatement, label
		f_p_temp( label, true, Identifier
		set ret.name = getNodeText(p_label)
		f_p( body

    f( BreakStatement, break
		f_p_name( label, Identifier | null

    f( ContinueStatement, continue
		f_p_name( label, Identifier | null

	f( IfStatement, if;ret-is-array
		f_p_tag( test, test
		_ setNameFromChildByTag(ret, 'test', true)
		if node.consequent
			f_p_temp( consequent
			log 'IfStatement', p_consequent
			if p_consequent.tag && p_consequent.tag.length > 0
				_ ret.children.push(p_consequent)
			else
				foreach item in p_consequent.children
					_ ret.children.push(item)
		if node.alternate
			f_p_temp( alternate
			var p_else
				{
					@ tag 'else'
					[ children
			log 'IfStatement', p_consequent
			if p_alternate.tag && p_alternate.tag.length > 0
				_ p_else.children.push(p_alternate)
			else
				foreach item in p_alternate.children
					_ p_else.children.push(item)
			set ret = [ret, p_else]
		else
			set ret = [ret]

    f( SwitchStatement, switch
		f_p_temp( discriminant, true, Expression
		f_a( cases, true, SwitchCase
		# A `switch` statement.

		if p_discriminant.textified || p_discriminant.isText
			set ret.name = p_discriminant.textified || p_discriminant.name
			set ret.textified = ret.name
		else
			throw new Error('SwitchStatement.discriminant must be textual:' + JSON.stringify(node))

    f( SwitchCase, case
		f_p_temp( test, false, Expression | null
		f_a( consequent, true, Statement
		# A `case` (if `test` is an `Expression`) or `default` (if `test === null`) clause in the body of a `switch` statement.
		#
		if node.test == null
			set ret.tag = 'default'
		else
			if p_test.textified || p_test.isText
				set ret.name = p_test.textified || p_test.name
				set ret.textified = ret.name
			else
				throw new Error('SwitchCase.test must be textual:' + JSON.stringify(node))

    f( ThrowStatement, throw
		f_p( argument
		# A `throw` statement.

    f( TryStatement, try
		f_p( block, true, BlockStatement
		f_p( handler, false, CatchClause, optional
		f_p( finalizer, false, BlockStatement | null
		# A `try` statement. If `handler` is `null` then `finalizer` must be a `BlockStatement`.

    f( CatchClause, catch
		# A `catch` clause following a `try` block.
		f_p_tag( param, Pattern | null
		get_text_from_1_children( )
		f_p( body, true, BlockStatement

    f( WhileStatement, while
		f_p_tag( test, test, Expression
		get_text_from_1_children( )
		f_p( body, true, Statement

    f( DoWhileStatement, do
		f_p_tag( test, test, Expression
		get_text_from_1_children( )
		f_p( body, true, Statement

    f( ForStatement, for
		f_p_tag( init, init, VariableDeclaration | Expression | null
		f_p_tag( test, test, Expression | null
		f_p_tag( update, update, Expression | null
		log 'p_init.textified', p_init.textified
		var c1 = p_init.isText ? p_init.name : (p_init.textified ? p_init.textified : '')
		var c2 = p_test.isText ? p_test.name : (p_test.textified ? p_test.textified : '')
		var c3 = p_update.isText ? p_update.name : (p_update.textified ? p_update.textified : '')
		set ret.name = c1 + '; ' + c2 + '; ' + c3
		_ removeChildByTag(ret, 'init')
		_ removeChildByTag(ret, 'test')
		_ removeChildByTag(ret, 'update')
		f_p( body, true, Statement

    f( ForInStatement, for
		f_p_tag( left, left, VariableDeclaration |  Expression
		f_p_tag( right, right, Expression
		get_text_from_2_children( c1 + ' in ' + c2 )
		f_p( body, true, Statement
    
	f( ForOfStatement, for;must-be-text
		f_p_tag( left, left, VariableDeclaration |  Expression
		f_p_tag( right, right, Expression
		get_text_from_2_children( c1 + ' of ' + c2 )
		if !got_text_2
			
		set ret.children = []
		b( await
		f_p( body, true, Statement
    
	f( FunctionDeclaration, function
		# A function [declaration](#functiondeclaration) or [expression](#functionexpression).
		f_p_name(id, Identifier | null
		f_a_in_tag( params, params
		_ processParams(ret)
		# VIA
			_ replaceChildrenOfChildWhenText
				@ ret
				@ getChildPosByTag(ret, 'params')
				@ 'param'
		# b( generator
		# b( async
		f_p( body, true, Statement
		if node.generator
			set ret.tag = 'function*'
		if node.async
			set ret.tag = 'async-function'

    f( VariableDeclaration, node.kind;tag-is-var
		# enum "var" | "let" | "const"
		f_a( declarations, true, VariableDeclarator
		
		# log '=== VariableDeclaration ittf result 1', ret
		
		get_text_from_1_children(  )
		
		# log '=== VariableDeclaration ittf result 2', ret, 'got_text_1', got_text_1
		
		if got_text_1
			set ret.textified = node.kind + ' ' + ret.textified
		elif ret.children.length == 1
			if ret.children[0].children.length == 1
				set ret.name = ret.children[0].name
				set ret.children[0] = ret.children[0].children[0]
				set ret.textified = node.kind + ' ' + ret.name
		elif ret.children.length > 1
			var sb = []
			foreach item in ret.children
				if item.textified
					_ sb.push(item.textified)
				else
					set sb = null
					break
			if sb
				set ret.textified = node.kind + ' ' + sb.join(', ')

		# log 'VariableDeclaration.exit.ret', ret

    f( VariableDeclarator, decl
		const save = options.mustBeText
		set options.mustBeText = true
		f_p_temp(id, true)
		set ret.name = getNodeText(p_id)
		set options.mustBeText = save

		f_p_temp( init, false, Expression | null
		if p_init == null
			set ret.textified = ret.name
		else
			# log 'VariableDeclarator p_id', p_id, 'p_init', p_init
			if p_init != null
				if isTextualNode(p_init)
					set ret.name += ' = ' + getNodeText(p_init)
					set ret.textified = ret.name
				else
					_ ret.children.push
						@ p_init

    f( Decorator, @decorator
		f_p_temp( expression, true, Expression
		if isTextualNode(p_expression)
			set ret.name = getNodeText(p_expression)
		else
			_ ret.children.push
				@ p_expression

    f( Directive, directive
		if node.value && node.value.value === 'use strict'
			set ret = null
		else
			f_p_temp( value, true, DirectiveLiteral
			if isTextualNode(p_value)
				set ret.name = getNodeText(p_value)

    f( DirectiveLiteral

	f( Expression, expr
		# Any expression node. Since the left-hand side of an assignment may be any expression in general, an expression can also be a pattern.

    f( Super, super;is-text
		# A `super` pseudo-expression.
		set ret.name = 'super'

    f( Import, import
		# A `import` pseudo-expression.

    f( ThisExpression, this;is-text
		# A `this` expression.
		set ret.name = 'this'

    f( ArrowFunctionExpression, =>
		if verify.isArray(node.body) == false
			set node.body = [node.body]
		f_a_in_tag( params, params
		_ processParams(ret)
		f_a( body, true, BlockStatement | Expression
		b( expression
		log '*** ArrowFunctionExpression.ret.params', getChildByTag(ret, 'params')
		# A fat arrow function expression, e.g., `let foo = (bar) => { /* body */ }`.
		if node.async
			set ret.tag = 'async=>'
 
    f( YieldExpression, yield
		f_p_tag( argument, argument, Expression | null
		get_text_from_1_children(  )
		b( delegate
		# A `yield` expression.

    f( AwaitExpression, await
		f_p( argument, false, Expression | null
		# A `await` expression.

    f( ArrayExpression, [
		f_a( elements, true, Expression | SpreadElement | null 
		# An array expression.
		if options.mustBeText
			if setTextList(ret, ', ')
				set ret.textified = '[' + ret.textified + ']'
				log '### ArrayExpression', 'name:', ret.name, 'textified', ret.textified, ret.isText
			else
				throw new Error("ArrayExpression. Cannot textify node as requested: " + JSON.stringify(node))
		elif options.couldBeText
			var tlist = getTextList(ret, ', ')
			if tlist && tlist.length < 15
				set ret.textified = '[' + ret.textified + ']'
				# TODO??? set ret.children = []
			else
				set ret.textified = null
				foreach item in ret.children
					if isTextualNode(item)
						set item.tag = '@'
						set item.name = getNodeText(item)
					elif ['member-expr', 'ident', 'literal'].indexOf(item.tag) > -1
						set item.tag = '@'
		else
			foreach item in ret.children
				if isTextualNode(item)
					set item.tag = '@'
					set item.name = getNodeText(item)
				elif ['member-expr', 'ident', 'literal'].indexOf(item.tag) > -1
					set item.tag = '@'
		if ret.children.length == 0
			set ret.name = ret.textified = '[]'

    f( ObjectExpression, {
		f_a( properties, true, ObjectProperty | ObjectMethod | SpreadElement
		if options.mustBeText
			if setTextList(ret, ', ')
				set ret.textified = '{' + ret.textified + '}'
				if node.extra && node.extra.parenthesized == true
					set ret.textified = '(' + ret.textified + ')'
			else
				throw new Error("ObjectExpression. Cannot textify node as requested: " + JSON.stringify(node))
		else
			foreach item in ret.children
				if item.tag === '...'
					set item.name = item.textified
					set item.tag = '@'
			if !ret.textified && ret.children.length == 0
				if node.extra && node.extra.parenthesized == true
					set ret.name = ret.textified = '({})'
				else
					set ret.name = ret.textified = '{}'
			else
				if node.extra && node.extra.parenthesized == true
					var temp
						{
							@ tag '('
							[ children
								@ ret
					set ret = temp

    $* interface
	f( ObjectMember, @
		f_p( key, true, Expression
		# b( computed
		f_a( decorators, false, Decorator 
	*$

    f( ObjectProperty, @
		const save = options.mustBeText
		set options.mustBeText = true
		f_p_temp(key, true)
		set ret.name = getNodeText(p_key)
		set options.mustBeText = save
		if node.computed
			set ret.name = '[' + ret.name + ']'
		f_a( decorators, false, Decorator
		f_p_temp( value, true, Expression
		if isTextualNode(p_value)
			if options.mustBeText
				set ret.textified = ret.name += ': ' + getNodeText(p_value)
			else
				set ret.name += ' ' + getNodeText(p_value)
		else
			_ ret.children.push
				@ p_value
		
		# TODO b( computed
		# TODO b( shorthand
		

		if ret.children.length == 1 && ret.children[0].tag === '{'
			set ret.tag = '{' + ret.tag.substr(1)
			set ret.children = ret.children[0].children
		elif ret.children.length == 1 && ret.children[0].tag === '['
			set ret.tag = '[' + ret.tag.substr(1)
			set ret.children = ret.children[0].children

    f( ObjectMethod, node.kind;tag-is-var
		# s( kind
		# enum "get" | "set" | "method"
		const save = options.mustBeText
		set options.mustBeText = true
		f_p_temp(key, true)
		set ret.name = getNodeText(p_key)
		set options.mustBeText = save
		f_a_in_tag( params, params
		_ processParams(ret)
		f_p( body, true, Statement
		set ret.tag = ret.tag == 'constructor' ? 'ctor' : (ret.tag == 'method' ? 'm' : ret.tag)
		if node.async
			set ret.tag = 'async-' + ret.tag
		_ setNameFromChildByTag(ret, 'key', true)
		if ret.tag === 'ctor'
			set ret.name = ''
		elif node.computed
			set ret.name = '[' + ret.name + ']'

    f( FunctionExpression, function
		f_p_name(id, Identifier | null
		f_a_in_tag( params, params
		# [ Pattern ]
		f_p( body )
		# b( generator
		# b( async
		_ processParams(ret)
		# VIA
			_ replaceChildrenOfChildWhenText
				@ ret
				@ getChildPosByTag(ret, 'params')
				@ 'param'
		if node.generator
			set ret.tag = 'function*'
		if node.async
			set ret.tag = 'async-function'

    f( UnaryExpression, 'op' + node.operator;tag-is-var
		# A unary operator expression.
		# s( operator, UnaryOperator enum "-" | "+" | "!" | "~" | "typeof" | "void" | "delete" | "throw"
		# b( prefix
		
		f_p_temp( argument, true, Expression
		if isTextualNode(p_argument)
			set ret.name = getNodeText(p_argument)
			const space = ['-','+','!','{'].indexOf(node.operator) > -1 ? '' : ' '
			set ret.textified = node.operator + space + ret.name
		else
			_ ret.children.push
				@ p_argument

		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			if node.extra && node.extra.parenthesized == true
				# is the return value of an ArrowExpression
				# TODO ...
				if isTextualNode(p_argument)
					set ret.tag = '('
					set ret.name = node.operator + getNodeText(p_argument)
					set ret.textified = '(' + node.operator + getNodeText(p_argument) + ')'
				else
					var temp
						{
							@ tag '('
							[ children
								@ ret
					set ret = temp
			else
				# TODO ...
				if isTextualNode(p_argument)
					set ret.tag = '+'
					set ret.name = node.operator + getNodeText(p_argument)
				else
					var temp
						{
							@ tag '+'
							[ children
								@ ret
					set ret = temp
		
    f( UpdateExpression, 'op' + node.operator;tag-is-var
		# An update (increment or decrement) operator expression.
		# s( operator, UpdateOperator enum "++" | "--"
		f_p( argument, true, Expression
		# b( prefix
		
		get_text_from_1_children(  )
		if got_text_1
			set ret.tag = 'set'
			if node.prefix
				set ret.name = node.operator + ret.name
			else
				set ret.name = ret.name + node.operator
			set ret.textified = ret.name
		
		if node.prefix
			set ret.tag = node.operator + 'op'

		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if got_text_1
				if node.extra && node.extra.parenthesized == true
					set ret.tag = '('
				else
					set ret.tag = '+'
			else
				# TODO
				# is the return value of an ArrowExpression
				if got_text_1
					set ret.tag = '('
				else
					set ret.tag = '(' + ret.tag

    f( BinaryExpression, 'op' + node.operator;tag-is-var
		# A binary operator token.
		# s( operator, BinaryOperator
		# enum "==" | "!=" | "===" | "!==" 
			\b "<" | "<=" | ">" | ">="
			\b | "<<" | ">>" | ">>>"
			\b | "+" | "-" | "*" | "/" | "%"
			\b | "|" | "^" | "&" | "in"
			\b | "instanceof"
			\b | "|>"

		if node.operator.length > 1
			set ret.tag = node.operator
		
		f_p_temp( left, true, Expression
		log 'BinaryExpression.p_left', p_left
		f_p_temp( right, true, Expression
		log 'BinaryExpression.p_right', p_right

		if isTextualNode(p_left) && isTextualNode(p_right)
			set ret.tag = 'set'
			set ret.name = getNodeText(p_left) + ' ' + node.operator + ' ' + getNodeText(p_right)
			set ret.textified = ret.name
			if node.extra && node.extra.parenthesized == true
				set ret.textified = '(' + ret.textified + ')'
		else
			if isTextualNode(p_left) || ['member-expr', 'ident', 'literal'].indexOf(p_left.tag) > -1
				set p_left.tag = '+'
				if isTextualNode(p_left)
					set p_left.name = getNodeText(p_left)
					set p_left.children = []
			_ ret.children.push
				@ p_left
			
			if isTextualNode(p_right) || ['member-expr', 'ident', 'literal'].indexOf(p_right.tag) > -1
				set p_right.tag = '+'
				if isTextualNode(p_right)
					set p_right.name = getNodeText(p_right)
					set p_right.children = []
			_ ret.children.push
				@ p_right
			

			# TODO VIA
				var test = isTextualNode(p_right)
				if isTextualNode(p_left)
					set ret.name = getNodeText(p_left)
					_ ret.children.splice(0, 1)
					if node.extra && node.extra.parenthesized == true
						set ret.tag = ret.tag + '('
					if test
						set p_left.tag = '@'
				else
					if test
						set p_right.tag = '@'
						set p_right.name = getNodeText(p_right)

			if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
				# is the return value of an ArrowExpression
				if node.extra && node.extra.parenthesized == true
					set ret.tag = '('
				else
					set ret.tag = '+'

    f( AssignmentExpression, set
		# An assignment operator expression.
		# s( operator, AssignmentOperator
		# enum AssignmentOperator {
			\b "=" | "+=" | "-=" | "*=" | "/=" | "%="
			\b | "<<=" | ">>=" | ">>>="
			\b | "|=" | "^=" | "&="
		set options.mustBeText = true
		f_p_temp( left, true, Pattern | Expression
		set options.mustBeText = false
		f_p_temp( right, true, Expression
		set ret.name = getNodeText(p_left) + ' ' + node.operator + ' '
		if isTextualNode(p_right)
			set ret.name += getNodeText(p_right)
		else
			_ ret.children.push
				@ p_right

    f( LogicalExpression, 'op' + node.operator;tag-is-var;must-be-text
		# A logical operator expression.
		# s( operator, LogicalOperator enum "||" | "&&" | "??"
		
		f_p_temp( left, true, Expression
		f_p_temp( right, true, Expression

		if isTextualNode(p_left) && isTextualNode(p_right)
			set ret.tag = 'set'
			set ret.name = getNodeText(p_left) + ' ' + node.operator + ' ' + getNodeText(p_right)
			set ret.textified = ret.name
		else
			set ret.tag = node.operator
			if isTextualNode(p_left) || ['member-expr', 'ident', 'literal'].indexOf(p_left.tag) > -1
				set p_left.tag = '+'
				if isTextualNode(p_left)
					set p_left.name = getNodeText(p_left)
					set p_left.children = []
			_ ret.children.push
				@ p_left
			log 'LogicalExpression.p_left', p_left
			if isTextualNode(p_right) || ['member-expr', 'ident', 'literal'].indexOf(p_right.tag) > -1
				set p_right.tag = '+'
				if isTextualNode(p_right)
					set p_right.name = getNodeText(p_right)
					set p_right.children = []
			_ ret.children.push
				@ p_right
			log 'LogicalExpression.p_right', p_right

		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if node.extra && node.extra.parenthesized == true
				if ret.tag === 'set'
					set ret.tag = '('
				else
					set ret.tag = '(' + ret.tag
			else
				if ret.tag === 'set'
					set ret.tag = '+'
				else
					# TODO Do nothing is OK?

    f( SpreadElement, ...
		f_p_temp( argument, true, Expression
		if isTextualNode(p_argument)
			set ret.name = getNodeText(p_argument)
			set ret.textified = '...' + ret.name
		else
			throw new Error('SpreadElement must be textual:' + p_callee.children[0].tag)

    f( MemberExpression, member-expr
		f_p_temp( object
		f_p_temp( property
		
		# b( computed
		# b( optional, optional
		# If `computed` is `true`, the node corresponds to a computed (`a[b]`) member expression and `property` is an `Expression`. 
		# If `computed` is `false`, the node corresponds to a static (`a.b`) member expression and `property` is an `Identifier`. 
		# The `optional` flags indicates that the member expression can be called even if the object is null or undefined. 
		# If this is the object value (null/undefined) should be returned.
		
		if isTextualNode(p_object)
			var obj = getNodeText(p_object)
			if isTextualNode(p_property)
				var prop = getNodeText(p_property)
				set ret.name = node.computed ? obj + '[' + prop + ']' : obj + '.' + prop
				set ret.textified = ret.name
				set ret.children = []
				log 'MemberExpression.textified', ret.textified
			else
				set ret.name = obj
				var link
					{
						@ tag node.computed ? '.[' : '.'
						[ children
				_ link.children.push
					@ p_property
				_ ret.children.push
					@ link
		else
			if node.computed
				set p_property.tag = '.['
			else
				set p_property.tag = '.'
			set ret.tag = p_object.tag
			set ret.name = p_object.name
			set ret.source = p_object.source
			set ret.children = p_object.children
			_ ret.children.push
				@ p_property

			log 'MemberExpression.tag.name', ret.tag, ret.name
			foreach item in ret.children
				log 'MemberExpression.child', i, ret.children[i].tag, ret.children[i].name

		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if node.extra && node.extra.parenthesized == true
				set ret.tag = '('
			else
				set ret.tag = '+'

    f( BindExpression, bind-expr
		f_p( object, false, Expression | null
		f_p( callee, true, Expression
		# if `object` is `null`, then `callee` should be a `MemberExpression`.

    f( ConditionalExpression, iif
		# A conditional expression, i.e., a ternary `?`/`,` expression.
		f_p_tag( test, test
		f_p_temp( consequent, true, Expression
		f_p_temp( alternate, true, Expression
		
		_ setNameFromChildByTag(ret, 'test', true)

		if isTextualNode(p_consequent)
			_ ret.children.push
				{
					@ tag 'then'
					@ name getNodeText(p_consequent)
					[ children
		else
			_ ret.children.push
				{
					@ tag 'then'
					[ children
						@ p_consequent

		if isTextualNode(p_alternate)
			_ ret.children.push
				{
					@ tag 'else'
					@ name getNodeText(p_alternate)
					[ children
		else
			_ ret.children.push
				{
					@ tag 'else'
					[ children
						@ p_alternate

		if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1
			# is the return value of an ArrowExpression
			if node.extra && node.extra.parenthesized == true
				var temp
					{
						@ tag '('
						[ children
							@ ret
				set ret = temp
			else
				# TODO do nothing

    f( CallExpression, _
		# A function or method call expression.

		f_p_temp( callee, true, | Super | Import
		f_a_in_tag( arguments, arguments

		var lastCallee = ret
		var argumentsNode = getChildByTag(ret, 'arguments')
		set ret.children = []

		# log 'p_callee', p_callee
		
		# first of all try to set ret.textified
		
		if isTextualNode(p_callee)

			set ret.name = getNodeText(p_callee)

			if argumentsNode
				var tlist = getTextList(argumentsNode, ', ')
				if tlist
					set ret.name += '(' + tlist + ')'
					set ret.textified = ret.name
				else
					foreach item in argumentsNode.children
						if ['member-expr', 'ident', 'literal'].indexOf(item.tag) > -1
							set item.tag = '@'
						_ lastCallee.children.push
							@ item
			else
				set ret.textified = ret.name + '()'

			if ret.textified && node.extra && node.extra.parenthesized == true
				set ret.textified = '(' + ret.textified + ')'

			log 'CallExpression', 'ret.name,textified', ret.name, ret.textified
		
		else

			log 'CallExpression', 'p_callee.tag.name', p_callee.tag, p_callee.name
			foreach item in p_callee.children
				log 'CallExpression', 'p_callee.children', i, p_callee.children[i].tag, p_callee.children[i].name
			if argumentsNode
				foreach item in argumentsNode.children
					log 'CallExpression', 'argumentsNode.children', i, argumentsNode.children[i].tag, argumentsNode.children[i].name
			
			if ['[', '{'].indexOf(p_callee.tag) > -1
				set ret.tag = p_callee.tag
			set ret.name = p_callee.name
			set ret.children = p_callee.children
			
			set lastCallee = p_callee.children[p_callee.children.length-1]
			if argumentsNode && argumentsNode.children.length > 0
				if lastCallee.tag === '.'
					set lastCallee.tag = '._'
					foreach item in argumentsNode.children
						if ['member-expr', 'ident', 'literal'].indexOf(item.tag) > -1
							set item.tag = '@'
						_ lastCallee.children.push
							@ item
				else
					var call
						{
							@ tag '('
							[ children
					foreach item in argumentsNode.children
						if ['member-expr', 'ident', 'literal'].indexOf(item.tag) > -1
							set item.tag = '@'
						_ call.children.push
							@ item
					_ ret.children.push(call)
			else
				if lastCallee.tag === '.'
					set lastCallee.tag = '._'

		if node.extra && node.extra.parenthesized == true
			var temp
				{
					@ tag '('
					[ children
						@ ret
			set ret = temp

		# log 'CallExpression.exit.ret', ret

    f( NewExpression, new;could-be-text
		f_a_in_tag( arguments, arguments
		f_p_temp( callee

		if p_callee.isText || p_callee.textified
			set ret.name = p_callee.textified || p_callee.name
		else
			throw new Error('NewExpression.callee must be textual:' + p_callee.children[0].tag)

		var argumentsNode = getChildByTag(ret, 'arguments')
		set ret.children = []

		if argumentsNode
			var tlist = getTextList(argumentsNode, ', ')
			log 'NewExpression.tlist', tlist
			# if tlist && tlist.length < 15
			if tlist 
				set ret.name += '(' + tlist + ')'
				set ret.textified = 'new ' + ret.name
			else
				foreach item in argumentsNode.children
					if ['member-expr', 'ident', 'literal'].indexOf(item.tag) > -1
						set item.tag = '@'
					_ ret.children.push
						@ item
		else
			set ret.textified = ret.name + '()'

    f( SequenceExpression, sequence
		f_a( expressions, true, Expression 
		# A sequence expression, i.e., a comma-separated sequence of expressions.
		foreach item in ret.children
			if ['member-expr', 'ident', 'literal'].indexOf(item.tag) > -1
				set item.tag = 'set'

    f( DoExpression, do
		f_p( body, true, BlockStatement

    f( TemplateLiteral, `lit
		f_a_temp( quasis, true, TemplateElement
		f_a_temp( expressions, true, Expression 
		var i = 0
		for i = 0; i < p_expressions.children.length; i++
			var q = p_quasis.children[i]
			if q.name.length > 0
				_ ret.children.push(q)
			var e = p_expressions.children[i]
			if ['member-expr', 'ident', 'literal'].indexOf(e.tag) > -1
				set e.tag = '@'
			log 'TemplateLiteral.e', e
			_ ret.children.push(e)
		if p_quasis.children[i] && p_quasis.children[i].name.length > 0
			_ ret.children.push(p_quasis.children[i])

    f( TaggedTemplateExpression, `tag
		f_p_temp( tag, true, Expression
		if isTextualNode(p_tag)
			set ret.name = getNodeText(p_tag)
		else
			throw new Error('TaggedTemplateExpression.tag must be textual:' + JSON.stringify(node))
		f_p_temp( quasi, true, TemplateLiteral
		foreach item in p_quasi.children
			_ ret.children.push(item)

    f( TemplateElement, +
		# b( tail
		set ret.name = verify.replaceAll(verify.replaceAll(node.value.raw, '\n', '\\n'), ' ', '\\b')
		# f_p( value
		# f_p_p( value, cooked, optional
		# f_p_p( value, raw

    f( ObjectPattern, {
		f_a( properties, true, AssignmentProperty | RestElement 
		if options.mustBeText
			if setTextList(ret, ', ')
				set ret.textified = '{' + ret.textified + '}'
				if node.extra && node.extra.parenthesized == true
					set ret.textified = '(' + ret.textified + ')'
			else
				throw new Error("ObjectPattern. Cannot textify node as requested: " + JSON.stringify(node))
		else
			if ret.children.length == 0
				if node.extra && node.extra.parenthesized == true
					set ret.name = ret.textified = '({})'
				else
					set ret.name = ret.textified = '{}'
			else
				if node.extra && node.extra.parenthesized == true
					var temp
						{
							@ tag '('
							[ children
								@ ret
					set ret = temp

    f( ArrayPattern
		f_a( elements, false, Pattern | null
		if setTextList(ret, ', ')
			set ret.textified = '[' + ret.textified + ']'
			log '*** ArrayPattern len, textified: ', ret.children.length, ret.textified
		else
			throw new Error('ArrayPattern must be textual: ' + JSON.stringify(node))

    f( RestElement, ...;is-text
		f_p(argument, true , Pattern
		get_text_from_1_children(  )
		set ret.name = '...' + ret.name

    f( AssignmentPattern

		f_p_temp( left, true, Pattern | Expression
		f_p_temp( right, true, Expression
		if isTextualNode(p_left)
			set ret.name = getNodeText(p_left) + ' ' + node.operator + ' '
		if isTextualNode(p_right)
			set ret.name += getNodeText(p_right)
		else
			_ ret.children.push
				@ p_right

	f( Class, class
		f_p_name(id, Identifier | null
		f_p_temp(superClass, false, Expression | null
		if p_superClass
			if isTextualNode(p_superClass)
				_ ret.children.push
					{
						@ tag 'super'
						@ name getNodeText(p_superClass)
			else
				throw new Error('Class. superClass must be textual: ' + JSON.stringify(node))
		f_a( decorators, false, Decorator 
		f_p(body, true, ClassBody

	f( ClassBody, skip
		f_a( body, true, ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty 

    f( ClassMethod, node.kind;tag-is-var
		f_p_tag(key, key, Expression
		# s( kind
		# enum "constructor" | "method" | "get" | "set"
		# b( computed
		b( static
		# b( generator
		# b( async
		f_a( decorators, false, Decorator 
		f_a_in_tag( params, params
		_ processParams(ret)
		f_p( body, true, Statement
		set ret.tag = ret.tag == 'constructor' ? 'ctor' : (ret.tag == 'method' ? 'm' : ret.tag)
		if node.async
			set ret.tag = 'async-' + ret.tag
		_ setNameFromChildByTag(ret, 'key', true)
		if ret.tag === 'ctor'
			set ret.name = ''
		elif node.computed
			set ret.name = '[' + ret.name + ']'
		
		# VIA
			_ replaceChildrenOfChildWhenText
				@ ret
				@ getChildPosByTag(ret, 'params')
				@ 'param'

    f( ClassPrivateMethod, node.kind;tag-is-var
		f_p( key, true, PrivateName
		# s( kind, "method" | "get" | "set"
		b( static
		f_a( decorators, false, Decorator 
		f_a_in_tag( params, params
		f_p( body, true, Statement
		set ret.tag = ret.tag == 'method' ? 'm' : ret.tag
		_ processParams(ret)
		# VIA
			_ replaceChildrenOfChildWhenText
				@ ret
				@ getChildPosByTag(ret, 'params')
				@ 'param'

    f( ClassProperty, p
		f_p_name(key, Expression
		f_p_temp( value, true, Expression
		if p_value.tag === '=>'
			set ret.tag = p_value.tag
			set ret.children = p_value.children
		else
			if node.computed
				set ret.name = '[' + ret.name + ']'
			if isTextualNode(p_value)
				set ret.name += ' = ' + getNodeText(p_value)
			else
				_ ret.children.push
					@ p_value
		b( static

    f( ClassPrivateProperty, p
		f_p( key, true, PrivateName
		f_p( value, true, Expression
		b( static

    f( ClassDeclaration, class
		f_p_name( id, Identifier
		f_p_temp(superClass, false, Expression | null
		if p_superClass
			if isTextualNode(p_superClass)
				_ ret.children.push
					{
						@ tag 'super'
						@ name getNodeText(p_superClass)
						[ children
			else
				throw new Error('Class. superClass must be textual: ' + JSON.stringify(node))
		f_a( decorators, false, Decorator 
		f_p( body )

    f( ClassExpression, class
		f_p_temp(superClass, false, Expression | null
		if p_superClass
			if isTextualNode(p_superClass)
				_ ret.children.push
					{
						@ tag 'super'
						@ name getNodeText(p_superClass)
						[ children
			else
				throw new Error('Class. superClass must be textual: ' + JSON.stringify(node))
		f_p( body )

    f( MetaProperty, meta
		f_p( meta, true, Identifier
		f_p( property, true, Identifier
		get_text_from_2_children( c1 + '.' + c2 )

    f( ModuleDeclaration, module
		# A module `import` or `export` declaration.

    $* interface
	f( ModuleSpecifier
		f_p( local, true, Identifier
		# A specifier in an import or export declaration.
	*$

    f( ImportDeclaration, import
		f_a( specifiers, true, ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier
		f_p_tag( source, from
		# An import declaration, e.g., `import foo from "mod"`.
		#
		var xdefault = getChildByTag(ret, 'default')
		if xdefault
			set ret.name = xdefault.name
			_ removeChildByTag(ret, 'default')
		if ret.children.length == 1 && ret.children[0].tag === 'from'
			if ret.name && ret.name.length > 0
				set ret.name += ' from'
			set ret.name += ' '	+ ret.children[0].name
			_ removeChildByTag(ret, 'from')

    f( ImportSpecifier, @
		f_p_name( imported, Identifier
		# f_p( local, true, Identifier
		# An imported variable binding, e.g., `{foo}` in `import {foo} from "mod"` or `{foo as bar}` in `import {foo as bar} from "mod"`. The `imported` field refers to the name of the export imported from the module. The `local` field refers to the binding imported into the local module scope. If it is a basic named import, such as in `import {foo} from "mod"`, both `imported` and `local` are equivalent `Identifier` nodes in this case an `Identifier` node representing `foo`. If it is an aliased import, such as in `import {foo as bar} from "mod"`, the `imported` field is an `Identifier` node representing `foo`, and the `local` field is an `Identifier` node representing `bar`.

    f( ImportDefaultSpecifier, default
		f_p_name( local, Identifier
		# A default import specifier, e.g., `foo` in `import foo from "mod.js"`.

    f( ImportNamespaceSpecifier, as 
		f_p( local, true, Identifier
		# A namespace import specifier, e.g., `* as foo` in `import * as foo from "mod.js"`.
		get_text_from_1_children()

    f( ExportNamedDeclaration, export
		f_p( declaration, false, Declaration | null
		f_a( specifiers, true, ExportSpecifier
		f_p_tag( source, from
		# An export named declaration, e.g., `export {foo, bar}`, `export {foo} from "mod"`, `export var foo = 1` or `export * as foo from "bar"`.
		# _Note, Having `declaration` populated with non-empty `specifiers` or non-null `source` results in an invalid state._

    f( ExportSpecifier, @
		f_p( exported, true, Identifier
		f_p_name( local, true, Identifier
		# An exported variable binding, e.g., `{foo}` in `export {foo}` or `{bar as foo}` in `export {bar as foo}`. The `exported` field refers to the name exported in the module. The `local` field refers to the binding into the local module scope. If it is a basic named export, such as in `export {foo}`, both `exported` and `local` are equivalent `Identifier` nodes in this case an `Identifier` node representing `foo`. If it is an aliased export, such as in `export {bar as foo}`, the `exported` field is an `Identifier` node representing `foo`, and the `local` field is an `Identifier` node representing `bar`.
		if ret.children[0].name !== ret.name
			set ret.children[0].tag = 'as'
		else
			set ret.children = []

	f( ExportDefaultSpecifier, export-default
		f_p_temp( exported, true, OptFunctionDeclaration | OptClassDeclaration | Expression
		if isTextualNode(p_exported)
			set ret.name = getNodeText(p_exported)
		else
			_ ret.children.push
				@ p_exported

	f( ExportDefaultDeclaration, export-default
		# An export default declaration, e.g., `export default function () {}` or `export default 1`.
		#
			f_p_temp( id, true, Identifier | null
			set ret.name = getNodeText(p_id)
		f_p_temp( declaration, true, OptFunctionDeclaration | OptClassDeclaration | Expression
		if isTextualNode(p_declaration)
			set ret.name = getNodeText(p_declaration)
		else
			_ ret.children.push
				@ p_declaration

    f( ExportNamespaceSpecifier, as
		f_p_temp( exported, true, OptFunctionDeclaration | OptClassDeclaration | Expression
		if isTextualNode(p_exported)
			set ret.name = getNodeText(p_exported)
		else
			_ ret.children.push
				@ p_exported
	
	f( ExportAllDeclaration, export-all
		f_p_tag( source, from

	f( CommentBlock, ignore
	
	f( CommentLine, ignore

	f( JSXAttribute, @
		f_p_temp( name, true, JSXnamespacedName
		f_p_temp( value, false, JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer

		if isTextualNode(p_name)
			set ret.name = getNodeText(p_name)
		else
			throw new Error('JSXAttribute.name must be textual:' + JSON.stringify(node))

		if p_value
			if isTextualNode(p_value)
				set ret.name += ' ' + getNodeText(p_value)
			else
				_ ret.children.push
					@ p_value

	f( JSXClosingElement, jsx-close
		# name JSXIdentifier | JSXMemberExpression

	f( JSXElement, jsx-element
		f_p_temp( openingElement, true, JSXOpeningElement
		# f_p( closingElement, true, JSXClosingElement
		f_a_temp( children, true, JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment
		var char = p_openingElement.name[0]
		if char == char.toUpperCase()
			set ret.tag = '< ' + p_openingElement.name
		else
			set ret.tag = p_openingElement.name
		set ret.children = p_openingElement.children
		foreach item in p_children.children
			if !(item.tag === '+' && item.name.trim().length == 0)
				_ ret.children.push
					@ item

	f( JSXEmptyExpression
		set ret.tag = '+'
		set ret.name = '{}'

	f( JSXExpressionContainer
		f_p_temp( expression
		if isTextualNode(p_expression)
			set ret.tag = '+'
			set ret.name = '{' + getNodeText(p_expression) + '}'
			set ret.textified = ret.name
		else
			set ret.tag = '{'
			_ ret.children.push
				@ p_expression

	f( JSXSpreadChild
		f_p_temp( expression, true, Expression
		set ret.tag = p_expression.tag
		set ret.name = '...' + p_expression.name
		set ret.children = p_expression.children
 
	f( JSXIdentifier, jsx-ident;is-text
		name( name

	f( JSXMemberExpression
		f_p(object, true, JSXMemberExpression | JSXIdentifier
		f_p(property, true, JSXIdentifier
		get_text_from_2_children( c1 + '.' + c2 )

	f( JSXNamespacedName
		# namespace JSXIdentifier
		# name JSXIdentifier

	f( JSXOpeningElement, jsx-open
		f_p_temp( name, true, JSXIdentifier | JSXMemberExpression
		# selfClosing boolean
		f_a_temp( attributes, attributes, JSXAttribute | JSXSpreadAttribute
		f_a_temp( parameters, parameters, TypeParameterInstantiation | TSTypeParameterInstantiation

		if isTextualNode(p_name)
			set ret.name = getNodeText(p_name)
		else
			throw new Error('JSXOpeningElement.name must be textual:' + JSON.stringify(node))
		foreach item in p_attributes.children
			_ ret.children.push
				@ item

	f( JSXSpreadAttribute, @
		f_p( argument, true, Expression
		get_text_from_1_children( '{...' + c1 + "}" )

	f( JSXText, +
		if node.value.trim().length == 0 || node.value === '\n'
			set ret = null
		else
			set ret.name = verify.replaceAll(node.value, '\n', '\\n')

	f( JSXFragment, fragment
		# openingFragment JSXOpeningFragment
		# closingFragment JSXClosingFragment
		# children JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment

	f( JSXOpeningFragment, fragment-open
		# aliases: ["JSX", "Immutable"],

	f( JSXClosingFragment, fragment-close
		# aliases: ["JSX", "Immutable"]
