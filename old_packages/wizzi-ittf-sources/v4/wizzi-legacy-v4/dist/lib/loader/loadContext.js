/*
    artifact generator: C:\My\wizzi\v4\node_modules\v4-wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v4\kernel\wizzi-mtree\src\ittf\lib\loader\loadcontext.js.ittf
    utc time: Tue, 10 Oct 2017 15:44:11 GMT
*/
'use strict';
// generated by wizzi.codegen.js.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var util = require('util');
var MTreeBrickProvider = null;
/**
     One mTree loading uses 1 mTreeBrickProvider and 1 loadContext.
    
     The loadContext keeps tracks of the ittf documents loaded
     for building one mTree. Once loaded, ittf documents become mTreeBricks,
     that may be reused many times for the same mTree and always are cloned.
     Every cloned mTreeBrick has its own evalContext and
     the load context assigns source keys to ittf documents, loaded once, and
     mTreeBrick keys to every cloned mTreeBricks.
     It also checks the mix and include call chain to prevent recursion.
    
     ittfDocumentDatas: Map
     key: sourceKey
     item object:
     string ittfDocumentUri
     string content
     string sourceKey
    
     mTreeBrickDatas: Map
     key: brickKey
     item object:
     string ittfDocumentUri
     string schema
     { mTreeBrick (cloned)      // mTreeBrick is created by the mTreeBrickProvider
     $mixerBrickKey:String    // key of the mixer mTreeBrickData
     // set by the lib/loader/mixer
     $args:String             // args of the mixin call
     // set by the lib/loader/mixer
     $params:String           // params received by the mixed mTreeBrick
     byRefParams:Array        // params passed by reference
     calcParamValues:Function  // calculates the values
     { evalContext
     string sourceKey
     string brickKey
    
     [ callChain
     {
     string mixerUri
     string mixedUri
    
*/
var LoadContext = (function () {
    function LoadContext() {
        _classCallCheck(this, LoadContext);
        this.__type = 'LoadContext';
        this.ittfDocumentDatas = {};
        this.mTreeBrickDatas = {};
        this.sourceCount = 0;
        this.modelCount = 0;
        this.nodeCount = 0;
        this.callChain = [];
    }
    LoadContext.prototype.addIttfDocument = function(ittfDocumentUri, textContent) {
        var sourceKey = 'f' + ++this.sourceCount;
        var ittfDocumentData = {
            ittfDocumentUri: ittfDocumentUri, 
            sourceKey: sourceKey, 
            content: textContent
        };
        this.ittfDocumentDatas[sourceKey] = ittfDocumentData;
        return ittfDocumentData;
    }
    LoadContext.prototype.addMTreeBrick = function(ittfDocumentUri, schema, mTreeBrickCloned, options) {
        var sourceKey = this.getSourceKey(ittfDocumentUri);
        if (options.include) {
            return {
                    sourceKey: sourceKey, 
                    brickKey: options.includerBrickKey
                };
        }
        var brickKey = 'f' + ++this.modelCount;
        var mTreeBrickData = {
            ittfDocumentUri: ittfDocumentUri, 
            schema: schema, 
            sourceKey: sourceKey, 
            brickKey: brickKey, 
            mTreeBrick: mTreeBrickCloned, 
            evalContext: null
        };
        this.mTreeBrickDatas[brickKey] = mTreeBrickData;
        return mTreeBrickData;
    }
    LoadContext.prototype.getMTreeBrickData = function(brickKey) {
        return this.mTreeBrickDatas[brickKey];
    }
    LoadContext.prototype.getIttfDocumentUri = function(sourceKey) {
        var ittfDocumentData = this.ittfDocumentDatas[sourceKey];
        return ittfDocumentData ? ittfDocumentData.ittfDocumentUri : 'Source ittfDocumentUri unknown';
    }
    LoadContext.prototype.getSourceKey = function(ittfDocumentUri) {
        for (var k in this.ittfDocumentDatas) {
            if (this.ittfDocumentDatas[k].ittfDocumentUri === ittfDocumentUri) {
                return k;
            }
        }
        return null;
    }
    LoadContext.prototype.getIttfDocuments = function() {
        var ret = {};
        for (var k in this.ittfDocumentDatas) {
            var ittfDocumentData = this.ittfDocumentDatas[k];
            ret[this.getIttfDocumentUri(ittfDocumentData.sourceKey)] = {
                sourceKey: ittfDocumentData.sourceKey
            };
        }
        return ret;
    }
    LoadContext.prototype.getNewNodeId = function() {
        return ++this.nodeCount;
    }
    LoadContext.prototype.enterFragmentCall = function(mixerUri, mixedUri) {
        this.callChain.push({
            mixerUri: mixerUri, 
            mixedUri: mixedUri
        });
    }
    LoadContext.prototype.exitFragmentCall = function() {
        this.callChain.pop();
    }
    LoadContext.prototype.checkForRecursion = function() {
        for (var i = 0; i < this.callChain.length; i++) {
            if (this.callChain[i].mixerUri == this.callChain[i].mixedUri) {
                return true;
            }
            for (var j = 0; j < this.callChain.length; j++) {
                if ((this.callChain[j].mixerUri == this.callChain[i].mixedUri) && (this.callChain[j].mixedUri == this.callChain[i].mixerUri)) {
                    return true;
                }
            }
        }
        return false;
    }
    LoadContext.getLoadStateAsync = function(ittfDocumentUri, requestContext, callback) {
        if (!MTreeBrickProvider) {
            MTreeBrickProvider = require('./mTreeBrickProvider');
        }
        MTreeBrickProvider.createFromUri(ittfDocumentUri, requestContext, function(err, createdProvider) {
            if (err) {
                return callback(err);
            }
            callback(null, {
                requestContext: requestContext, 
                provider: createdProvider, 
                getPrimaryMTreeBrick: function() {
                    return createdProvider.getPrimaryMTreeBrick();
                }, 
                callChain: [], 
                checkForLoops: function() {
                    for (var i = 0; i < this.callChain.length; i++) {
                        if (this.callChain[i].mixer == this.callChain[i].mixed) {
                            return true;
                        }
                        for (var j = 0; j < this.callChain.length; j++) {
                            if ((this.callChain[j].mixer == this.callChain[i].mixed) && (this.callChain[j].mixed == this.callChain[i].mixer)) {
                                return true;
                            }
                        }
                    }
                    return false;
                }
            });
        });
    }
    return LoadContext;
})();


module.exports = {
    LoadContext: LoadContext
};
