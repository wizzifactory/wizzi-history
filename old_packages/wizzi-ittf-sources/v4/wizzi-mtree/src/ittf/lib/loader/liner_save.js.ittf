module wizzi-mtree.loader.liner
    kind jsfile
    var util = require('util')

	#
		# Reads an IttfDocument and extract an array of line descriptions
    #
		# params
		#   string textContent
		#     # The text content of the IttfDocument
		#   { ittfDocumentData
        #     string sourceKey
		#     # The IttfDocument key generated by the loadHistory

	#
		# Output
		# lines:Array of
		#  line : {
		#      indent: Number,
		#      name: String,
		#      value: String, // always trimmed
		#      row: Number,
		#      col: Number,
		#      sourceKey: String,
		#      tagSuffix: undefined || '(',
		#      hasMacro: Boolean
		#  }
	#
		# Ittf commands for comments
		#  $ and $ ... singleline comment
		#  $ and * ... * and $ multiline comment
		# Comment states
		#   0 = no comment seen
		#   1 = seen char $ could be first char of comment
		#   2 = seen chars $ and * we are inside multiline comments
		#   3 = seen chars $ and * ... and *  could be first char of end of multiline comments
		#  21 = seen chars $ and $ we are inside singleline comment
		# Es6 macro states
		#   0 = no macro seen
		#   1 = seen char ` we are inside template
		#   2 = seen escape char inside a template, the next ` char does not close the macro string
		#  10 = seen char $ inside a template could be start of macro

	var COMMENT
		{
			@ NONE 0
			@ NONE_SEEN_DOLLAR 1
			@ MULTI_LINE 2
			@ MULTI_LINE_SEEN_ASTER 3
			@ SINGLE_LINE 21
    
	var MACRO
		{
			@ NONE 0
			@ INSIDE_TEMPLATE 1
			@ INSIDE_TEMPLATE_SEEN_ESCAPE 2
			@ INSIDE_TEMPLATE_SEEN_DOLLAR 10

	var CP
		{
			@ DOLLAR 36
			@ ASTER 42
			@ SLASH 92
			@ SINGLE_QUOTE 39
			@ DOUBLE_QUOTE 34
			@ TAB 9
			@ LF 10
			@ CR 13
			@ SPACE 32

	set module.exports
        function 
            param textContent
            param ittfDocumentData
            var 
                decl sourceKey = ittfDocumentData.sourceKey
                decl lines
                    [ 
                decl leadingWhiteSpaces = 0
                decl line = null
                decl linepos = 1
				decl lineHasMacro = false
                decl colpos = 0
                decl commentState = COMMENT.NONE
				decl macroState = MACRO.NONE
                decl quote = null
                # TODO ensure textContent is red as utf-8 and avoid this
				decl chunk = textContent.toString('utf-8')
                decl ch
				decl chUni
                decl i
                decl l = chunk.length
            
			# TODO replace ch with chUni 
			for i = 0; i < l; i++
                
				set ch = chunk[i]
				set chUni = chunk.charCodeAt(i)
				var cp = (chunk.charAt(index) + chunk.charAt(index + 1)).codePointAt(0)
				if cp > 0xffff
					log 'wizzi-mtree.loader.liner.cp > 0xffff'
					set index += 1

                set colpos++

				if ch == '\\'
					# log '+++++ wizzi-mtree.liner', chunk[i+1], chunk[i+2], chunk[i+3]
                
				if quote != null
                    if quote == ch
                        set quote = null
                    _ processMacro(ch)
                
				else 
                    if commentState == COMMENT.MULTI_LINE $$ 2
                        if ch == '*'
							# could be start of end of comment
                            set commentState = COMMENT.MULTI_LINE_SEEN_ASTER $$ 3
						else
							# skip comment char
							if ch == '\n'
								set linepos++
								set colpos = 0
                    
					elif commentState == COMMENT.SINGLE_LINE $$ 21
                        if ch == '\n'
							# end of line comment
							# delegate end of comment to processMacro 
                            _ processMacro(ch)
                    
					elif commentState == COMMENT.MULTI_LINE_SEEN_ASTER $$ 3
                        if ch == '$'
							# ok, really is end of comment
                            set commentState = COMMENT.NONE $$ 0
                        else
							# no, multi line comments continue 
                            set commentState = COMMENT.MULTI_LINE $$ 2
							# check if it is eol
							if ch == '\n'
								set linepos++
								set colpos = 0
                    
					elif commentState == COMMENT.NONE_SEEN_DOLLAR && ch == '*'
						# ok, really is start of multi line comment
                        set commentState = COMMENT.MULTI_LINE $$ 2
                    
					elif commentState == COMMENT.NONE_SEEN_DOLLAR && ch == '$'
						# ok, is a single line comment
                        set commentState = COMMENT.SINGLE_LINE $$ 21
                    
					elif commentState == COMMENT.NONE_SEEN_DOLLAR && ch != '*'
						# no, it was not a comment, reset
                        set commentState = COMMENT.NONE $$ 0
                        _ processMacro('$')
                        _ processMacro(ch)
                    
					elif commentState == COMMENT.NONE && ( ch == '"' || ch == "'" )
						# start of literal
                        set quote = ch
                        _ processMacro(ch)
                    
					elif commentState == COMMENT.NONE && ch == '$'
						# could be start of comment
                        set commentState = COMMENT.NONE_SEEN_DOLLAR $$ 1

					elif ch == '\\' && 
						\b i+3 < l && 
						\b chunk[i+1] == '$' &&
						\b chunk[i+2] == '\\' &&
						\b chunk[i+3] == '{'
						_ processChar('$')
						_ processChar('{')
						set i = i +3
                    
					else 
                        _ processMacro(ch)
            
			if line
                if typeof (line.value) !== 'undefined'
                    set line.value = line.value.trim()
				set line.hasMacro = lineHasMacro
				# log 'last push line', line
                _ lines.push(line)
				set lineHasMacro = false
            
			return lines
            
			function processMacro
				param ch

				if macroState == MACRO.INSIDE_TEMPLATE_SEEN_ESCAPE $$ 2
					# remove escape state
					set macroState = MACRO.INSIDE_TEMPLATE $$ 1
					_ processChar(ch)
					# log 'macroState', macroState, ch
				elif macroState == MACRO.INSIDE_TEMPLATE_SEEN_DOLLAR $$ 10
					if ch == '{'
						# ok - really it was a start of macro
						# Alt+146 = Æ
						_ processChar('Æ')
						_ processChar('{')
						set lineHasMacro = true
					else
						# no - it was not a start of macro
						_ processChar('$')
						_ processChar(ch)
					set macroState = MACRO.INSIDE_TEMPLATE $$ 1
					# log 'macroState', macroState, ch
				else
					if chUni == 96
						if macroState > MACRO.NONE $$ 0 
							set macroState = MACRO.NONE $$ 0
							_ processChar(ch)
							# log 'macroState', macroState, ch
						else
							set macroState = MACRO.INSIDE_TEMPLATE $$ 1
							_ processChar(ch)
							# log 'macroState', macroState, ch
					else
						if macroState == MACRO.INSIDE_TEMPLATE $$ 1
							if ch == '$'
								# could be start of macro
								set macroState = MACRO.INSIDE_TEMPLATE_SEEN_DOLLAR $$ 10
								# log 'macroState', macroState, ch
							elif ch == '\\'
								# could be an escape of a template start inside a template
								set macroState = MACRO.INSIDE_TEMPLATE_SEEN_ESCAPE $$ 2
								_ processChar(ch)
								# log 'macroState', macroState, ch
							else
								# log 'process char macroState', macroState, ch
								_ processChar(ch)
						else
							_ processChar(ch)

			function processChar
                param ch

				if ch == '\n'
                    if line
                        if typeof (line.value) !== 'undefined'
                            set line.value = line.value.trim()
						set line.hasMacro = lineHasMacro
                        _ lines.push(line)
                        set line = null
						set lineHasMacro = false
                    else 
						# Allow blank line. Do nothing
                    set leadingWhiteSpaces = 0
                    set colpos = 0
                    set linepos++
					set macroState = MACRO.NONE
					if commentState != COMMENT.MULTI_LINE $$ 2
                        set commentState = COMMENT.NONE $$ 0
                
				elif ch == '\r'

				elif [' ', '\t'].indexOf(ch) !== -1
                    if ch == '\t'
                        set colpos += 3
                    if line
                        if typeof (line.value) == 'undefined'
                            set line.value = ''
                        else 
                            set line.value += ch
                    else 
                        set leadingWhiteSpaces += ch == ' ' ? 1 : 4
                
				elif ['('].indexOf(ch) !== -1
                    if line
                        if typeof (line.value) == 'undefined'
                            set line.tagSuffix = ch
                            set line.value = ''
                        else 
                            set line.value += ch
                    else 
                        set line =
                            { 
                                @ indent leadingWhiteSpaces / 4
                                @ name ch
                                @ row linepos
                                @ col colpos
                                @ sourceKey sourceKey
                
				else 
                    if line
                        if typeof(line.value) == 'undefined'
                            set line.name += ch
                        else 
                            set line.value += ch
                    else 
                        set line =
                            { 
                                @ indent leadingWhiteSpaces / 4
                                @ name ch
                                @ row linepos
                                @ col colpos
                                @ sourceKey sourceKey
				if line
					# log 'line.name, value', line.name, line.value
