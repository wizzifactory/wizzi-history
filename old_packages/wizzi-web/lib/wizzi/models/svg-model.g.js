/*
    artifact generator: C:\My\wizzi\v5\node_modules\wizzi-legacy-v4\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v5\node_modules\wizzi-core\lib\artifacts\wfschema\model\gen\ittf\wfschema-model.js.ittf
    utc time: Mon, 11 Jun 2018 07:52:08 GMT
*/
'use strict';
// generated by wizzi.codegen.js.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var util = require('util');
var path = require('path');
var _ = require('lodash');
var wzutils = require('wizzi-utils');
var verify = wzutils.verify;

/**
     Schema wide declarations
*/
var styles = [
    {
        name: 'alignmentBaseline', 
        tag: 'alignment-baseline'
    }, 
    {
        name: 'baselineShift', 
        tag: 'baseline-shift'
    }, 
    {
        name: 'clip', 
        tag: 'clip'
    }, 
    {
        name: 'clipPath', 
        tag: 'clip-path'
    }, 
    {
        name: 'clipRule', 
        tag: 'clip-rule'
    }, 
    {
        name: 'color', 
        tag: 'color'
    }, 
    {
        name: 'colorInterpolation', 
        tag: 'color-interpolation'
    }, 
    {
        name: 'colorInterpolationFilters', 
        tag: 'color-interpolation-filters'
    }, 
    {
        name: 'colorProfile', 
        tag: 'color-profile'
    }, 
    {
        name: 'colorRendering', 
        tag: 'color-rendering'
    }, 
    {
        name: 'cursor', 
        tag: 'cursor'
    }, 
    {
        name: 'direction', 
        tag: 'direction'
    }, 
    {
        name: 'display', 
        tag: 'display'
    }, 
    {
        name: 'dominantBaseline', 
        tag: 'dominant-baseline'
    }, 
    {
        name: 'enableBackground', 
        tag: 'enable-background'
    }, 
    {
        name: 'fill', 
        tag: 'fill'
    }, 
    {
        name: 'fillOpacity', 
        tag: 'fill-opacity'
    }, 
    {
        name: 'fillRule', 
        tag: 'fill-rule'
    }, 
    {
        name: 'filter', 
        tag: 'filter'
    }, 
    {
        name: 'floodColor', 
        tag: 'flood-color'
    }, 
    {
        name: 'floodOpacity', 
        tag: 'flood-opacity'
    }, 
    {
        name: 'fontFamily', 
        tag: 'font-family'
    }, 
    {
        name: 'fontSize', 
        tag: 'font-size'
    }, 
    {
        name: 'fontSizeAdjust', 
        tag: 'font-size-adjust'
    }, 
    {
        name: 'fontStretch', 
        tag: 'font-stretch'
    }, 
    {
        name: 'fontStyle', 
        tag: 'font-style'
    }, 
    {
        name: 'fontVariant', 
        tag: 'font-variant'
    }, 
    {
        name: 'fontWeight', 
        tag: 'font-weight'
    }, 
    {
        name: 'glyphOrientationHorizontal', 
        tag: 'glyph-orientation-horizontal'
    }, 
    {
        name: 'glyphOrientationVertical', 
        tag: 'glyph-orientation-vertical'
    }, 
    {
        name: 'imageRendering', 
        tag: 'image-rendering'
    }, 
    {
        name: 'kerning', 
        tag: 'kerning'
    }, 
    {
        name: 'letterSpacing', 
        tag: 'letter-spacing'
    }, 
    {
        name: 'lightingColor', 
        tag: 'lighting-color'
    }, 
    {
        name: 'markerEnd', 
        tag: 'marker-end'
    }, 
    {
        name: 'markerMid', 
        tag: 'marker-mid'
    }, 
    {
        name: 'markerStart', 
        tag: 'marker-start'
    }, 
    {
        name: 'mask', 
        tag: 'mask'
    }, 
    {
        name: 'opacity', 
        tag: 'opacity'
    }, 
    {
        name: 'overflow', 
        tag: 'overflow'
    }, 
    {
        name: 'pointerEvents', 
        tag: 'pointer-events'
    }, 
    {
        name: 'shapeRendering', 
        tag: 'shape-rendering'
    }, 
    {
        name: 'stopColor', 
        tag: 'stop-color'
    }, 
    {
        name: 'stopOpacity', 
        tag: 'stop-opacity'
    }, 
    {
        name: 'stroke', 
        tag: 'stroke'
    }, 
    {
        name: 'strokeDasharray', 
        tag: 'stroke-dasharray'
    }, 
    {
        name: 'strokeDashoffset', 
        tag: 'stroke-dashoffset'
    }, 
    {
        name: 'strokeLinecap', 
        tag: 'stroke-linecap'
    }, 
    {
        name: 'strokeLinejoin', 
        tag: 'stroke-linejoin'
    }, 
    {
        name: 'strokeMiterlimit', 
        tag: 'stroke-miterlimit'
    }, 
    {
        name: 'strokeOpacity', 
        tag: 'stroke-opacity'
    }, 
    {
        name: 'strokeWidth', 
        tag: 'stroke-width'
    }, 
    {
        name: 'textAnchor', 
        tag: 'text-anchor'
    }, 
    {
        name: 'textDecoration', 
        tag: 'text-decoration'
    }, 
    {
        name: 'textRendering', 
        tag: 'text-rendering'
    }, 
    {
        name: 'unicodeBidi', 
        tag: 'unicode-bidi'
    }, 
    {
        name: 'visibility', 
        tag: 'visibility'
    }, 
    {
        name: 'wordSpacing', 
        tag: 'word-spacing'
    }, 
    {
        name: 'writingMode', 
        tag: 'writing-mode'
    }
];

var _md = module.exports = {};

var wzSourceLineInfo = (function () {
    function wzSourceLineInfo(row, col, sourceKey) {
        _classCallCheck(this, wzSourceLineInfo);
        this.row = row;
        this.col = col;
        this.sourceKey = sourceKey;
    }
    wzSourceLineInfo.prototype.toString = function(instance) {
        if (instance) {
            return 'row: ' + this.row + ', col: ' + this.col + ', file: ' + instance.wzSourceFilepath(this.sourceKey);
        }
        else {
            return 'row: ' + this.row + ', col: ' + this.col + ', sourceKey: ' + this.sourceKey;
        }
    }
    return wzSourceLineInfo;
})();

_md.wzSourceLineInfo = wzSourceLineInfo;
var svgBase = (function () {
    function svgBase(name, sourceLineInfo) {
        _classCallCheck(this, svgBase);
        this.wzName = name || '';
        this.wzParent = null;
        this.wzSourceLineInfo = sourceLineInfo;
        this.wzChildren = [];
    }
    svgBase.prototype.wzRoot = function() {
        return this.wzParent == null ? this : this.wzParent.wzRoot();
    }
    svgBase.prototype.wzSourceFilepath = function(sourceKey) {
        return this.wzRoot().loadHistory.getIttfDocumentUri(sourceKey);
    }
    svgBase.prototype.wzVerify = function() {
    }
    svgBase.prototype.wzInitialize = function() {
    }
    svgBase.prototype.wzInitializeAsync = function(ctx, callback) {
        callback(null);
    }
    svgBase.prototype.wzAddChild = function(node) {
        node.wzParent = this;
        this.wzChildren.push(node);
    }
    svgBase.prototype.wzAddChildToColl = function(node, coll) {
        node.wzParent = this;
        node.wzMoved = true;
        coll.push(node);
    }
    svgBase.prototype.wzMoveChildToColl = function(node, coll, fromColl) {
        var index = fromColl.indexOf(node);
        if (index < 0) {
            this.error('wzMoveChildToColl error. The from collection does not contain the node.', node);
        }
        fromColl.splice(index, 1);
        this.wzAddChildToColl(node, coll);
    }
    svgBase.prototype.wzLoadToChildColl = function(child, type, coll) {
        var item = new type(child.v, new wzSourceLineInfo(child.r, child.c, child.u));
        item.wzTag = child.n;
        item.wzParent = this;
        coll.push(item);
        if (item.loadFromNode) {
            item.loadFromNode(child);
        }
        return true;
    }
    svgBase.prototype.wzCreateChildColl = function(tag, name, type, coll) {
        var item = new type(name, this.wzSourceLineInfo);
        item.wzTag = tag;
        item.wzParent = this;
        item.wzCreated = true;
        coll.push(item);
        return item;
    }
    svgBase.prototype.wzLoadToChildren = function(child, type) {
        var item = new type(child.v, new wzSourceLineInfo(child.r, child.c, child.u));
        item.wzTag = child.n;
        item.wzParent = this;
        this.wzChildren.push(item);
        if (item.loadFromNode) {
            item.loadFromNode(child);
        }
        return true;
    }
    svgBase.prototype.wzLoadOneToOne = function(child, type, fieldName) {
        var item = new type(child.v, new wzSourceLineInfo(child.r, child.c, child.u));
        item.wzParent = this;
        this[fieldName] = item;
        if (item.loadFromNode) {
            item.loadFromNode(child);
        }
        return true;
    }
    svgBase.prototype.wzRemove = function(fromColl) {
        var index = fromColl.indexOf(this);
        if (index < 0) {
            this.error('wzRemove error. The from collection does not contain the node.', this);
        }
        fromColl.splice(index, 1);
    }
    svgBase.prototype.error = function(message, node) {
        throw new _md.svgModelException(message, node, this);
    }
    svgBase.prototype.toJsonProperties = function(result) {
        result.wzElement = this.wzElement;
        result.wzTag = this.wzTag;
        result.wzName = this.wzName;
    }
    svgBase.prototype.toJsonChildren = function(result) {
        if (this.wzChildren.length > 0) {
            var children = [];
            var i, i_len=this.wzChildren.length, item;
            for (i=0; i<i_len; i++) {
                item = this.wzChildren[i];
                children.push(item.toJson());
            }
            result.wzChildren = children;
        }
    }
    return svgBase;
})();

_md.svgBase = svgBase;

// element comment
var comment = (function (svgBase) {
    _inherits(comment, svgBase);
    function comment(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(comment.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, comment);
        this.wzElement = "comment";
        // relation comment
        this.comments = [];
    }
    comment.prototype.addComment = function(name, sourceLineInfo) {
        var retval = new _md.comment(name, sourceLineInfo);
        retval.wzParent = this;
        this.comments.push(retval);
        return retval;
    }
    comment.prototype.getComment = function(name) {
        var found = null;
        this.comments.forEach(function(item) {
            found = found || (item.wzName === name ? item : null);
        });
        return found;
    }
    comment.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    comment.prototype.toJsonProperties = function(result) {
        _md.svgBase.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
    }
    comment.prototype.toJsonChildren = function(result) {
        _md.svgBase.prototype.toJsonChildren.call(this, result);
        var items, item;
        items = [];
        var i, i_len=this.comments.length, item;
        for (i=0; i<i_len; i++) {
            item = this.comments[i];
            items.push(item.toJson());
        }
        result['comments'] = items;
    }
    comment.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 1 && _ch == '#') {
            if (name === '#') {
                return this.wzLoadToChildColl(child, _md.comment, this.comments);
            }
        }
        return ok;
    }
    comment.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    comment.prototype.wzVerify = function(ctx) {
        var i, i_len=this.comments.length, item;
        for (i=0; i<i_len; i++) {
            item = this.comments[i];
            item.wzVerify(ctx);
        }
        _md.svgBase.prototype.wzVerify.call(this, ctx);
    }
    comment.prototype.wzInitialize = function(ctx) {
        var i, i_len=this.comments.length, item;
        for (i=0; i<i_len; i++) {
            item = this.comments[i];
            item.wzInitialize(ctx);
        }
        _md.svgBase.prototype.wzInitialize.call(this, ctx);
    }
    return comment;
})(svgBase);

_md.comment = comment;
/**
    element item
     attributes common to all svg items
*/
var item = (function (svgBase) {
    _inherits(item, svgBase);
    function item(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(item.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, item);
        this.wzElement = "item";
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.id = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.href = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.rotate = null
        /**
             This attribute lets specify the total length for the path, in user units.
             Value type: <number> ; Default value: none; Animatable: yes
        */
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.pathLength = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.alignmentBaseline = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.baselineShift = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.clip = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.clipPath = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.clipRule = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.color = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.colorInterpolation = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.colorInterpolationFilters = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.colorProfile = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.colorRendering = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.cursor = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.direction = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.display = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.dominantBaseline = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.enableBackground = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fill = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fillOpacity = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fillRule = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.filter = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.floodColor = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.floodOpacity = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fontFamily = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fontSize = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fontSizeAdjust = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fontStretch = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fontStyle = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fontVariant = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fontWeight = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.glyphOrientationHorizontal = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.glyphOrientationVertical = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.imageRendering = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.kerning = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.letterSpacing = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.lightingColor = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.markerEnd = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.markerMid = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.markerStart = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.mask = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.opacity = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.overflow = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.pointerEvents = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.shapeRendering = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.stopColor = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.stopOpacity = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.stroke = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.strokeDasharray = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.strokeDashoffset = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.strokeLinecap = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.strokeLinejoin = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.strokeMiterlimit = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.strokeOpacity = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.strokeWidth = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.textAnchor = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.textDecoration = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.textRendering = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.unicodeBidi = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.visibility = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.wordSpacing = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.writingMode = null
        // relation comment
        this.comments = [];
        // relation item
        this.items = [];
    }
    item.prototype.addComment = function(name, sourceLineInfo) {
        var retval = new _md.comment(name, sourceLineInfo);
        retval.wzParent = this;
        this.comments.push(retval);
        return retval;
    }
    item.prototype.getComment = function(name) {
        var found = null;
        this.comments.forEach(function(item) {
            found = found || (item.wzName === name ? item : null);
        });
        return found;
    }
    item.prototype.addItem = function(name, sourceLineInfo) {
        var retval = new _md.item(name, sourceLineInfo);
        retval.wzParent = this;
        this.items.push(retval);
        return retval;
    }
    item.prototype.getItem = function(name) {
        var found = null;
        this.items.forEach(function(item) {
            found = found || (item.wzName === name ? item : null);
        });
        return found;
    }
    item.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    item.prototype.toJsonProperties = function(result) {
        _md.svgBase.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.id)) {
            result["id"] = this.id;
        }
        if (!isEmpty(this.href)) {
            result["href"] = this.href;
        }
        if (!isEmpty(this.rotate)) {
            result["rotate"] = this.rotate;
        }
        if (!isEmpty(this.pathLength)) {
            result["pathLength"] = this.pathLength;
        }
        if (!isEmpty(this.alignmentBaseline)) {
            result["alignmentBaseline"] = this.alignmentBaseline;
        }
        if (!isEmpty(this.baselineShift)) {
            result["baselineShift"] = this.baselineShift;
        }
        if (!isEmpty(this.clip)) {
            result["clip"] = this.clip;
        }
        if (!isEmpty(this.clipPath)) {
            result["clipPath"] = this.clipPath;
        }
        if (!isEmpty(this.clipRule)) {
            result["clipRule"] = this.clipRule;
        }
        if (!isEmpty(this.color)) {
            result["color"] = this.color;
        }
        if (!isEmpty(this.colorInterpolation)) {
            result["colorInterpolation"] = this.colorInterpolation;
        }
        if (!isEmpty(this.colorInterpolationFilters)) {
            result["colorInterpolationFilters"] = this.colorInterpolationFilters;
        }
        if (!isEmpty(this.colorProfile)) {
            result["colorProfile"] = this.colorProfile;
        }
        if (!isEmpty(this.colorRendering)) {
            result["colorRendering"] = this.colorRendering;
        }
        if (!isEmpty(this.cursor)) {
            result["cursor"] = this.cursor;
        }
        if (!isEmpty(this.direction)) {
            result["direction"] = this.direction;
        }
        if (!isEmpty(this.display)) {
            result["display"] = this.display;
        }
        if (!isEmpty(this.dominantBaseline)) {
            result["dominantBaseline"] = this.dominantBaseline;
        }
        if (!isEmpty(this.enableBackground)) {
            result["enableBackground"] = this.enableBackground;
        }
        if (!isEmpty(this.fill)) {
            result["fill"] = this.fill;
        }
        if (!isEmpty(this.fillOpacity)) {
            result["fillOpacity"] = this.fillOpacity;
        }
        if (!isEmpty(this.fillRule)) {
            result["fillRule"] = this.fillRule;
        }
        if (!isEmpty(this.filter)) {
            result["filter"] = this.filter;
        }
        if (!isEmpty(this.floodColor)) {
            result["floodColor"] = this.floodColor;
        }
        if (!isEmpty(this.floodOpacity)) {
            result["floodOpacity"] = this.floodOpacity;
        }
        if (!isEmpty(this.fontFamily)) {
            result["fontFamily"] = this.fontFamily;
        }
        if (!isEmpty(this.fontSize)) {
            result["fontSize"] = this.fontSize;
        }
        if (!isEmpty(this.fontSizeAdjust)) {
            result["fontSizeAdjust"] = this.fontSizeAdjust;
        }
        if (!isEmpty(this.fontStretch)) {
            result["fontStretch"] = this.fontStretch;
        }
        if (!isEmpty(this.fontStyle)) {
            result["fontStyle"] = this.fontStyle;
        }
        if (!isEmpty(this.fontVariant)) {
            result["fontVariant"] = this.fontVariant;
        }
        if (!isEmpty(this.fontWeight)) {
            result["fontWeight"] = this.fontWeight;
        }
        if (!isEmpty(this.glyphOrientationHorizontal)) {
            result["glyphOrientationHorizontal"] = this.glyphOrientationHorizontal;
        }
        if (!isEmpty(this.glyphOrientationVertical)) {
            result["glyphOrientationVertical"] = this.glyphOrientationVertical;
        }
        if (!isEmpty(this.imageRendering)) {
            result["imageRendering"] = this.imageRendering;
        }
        if (!isEmpty(this.kerning)) {
            result["kerning"] = this.kerning;
        }
        if (!isEmpty(this.letterSpacing)) {
            result["letterSpacing"] = this.letterSpacing;
        }
        if (!isEmpty(this.lightingColor)) {
            result["lightingColor"] = this.lightingColor;
        }
        if (!isEmpty(this.markerEnd)) {
            result["markerEnd"] = this.markerEnd;
        }
        if (!isEmpty(this.markerMid)) {
            result["markerMid"] = this.markerMid;
        }
        if (!isEmpty(this.markerStart)) {
            result["markerStart"] = this.markerStart;
        }
        if (!isEmpty(this.mask)) {
            result["mask"] = this.mask;
        }
        if (!isEmpty(this.opacity)) {
            result["opacity"] = this.opacity;
        }
        if (!isEmpty(this.overflow)) {
            result["overflow"] = this.overflow;
        }
        if (!isEmpty(this.pointerEvents)) {
            result["pointerEvents"] = this.pointerEvents;
        }
        if (!isEmpty(this.shapeRendering)) {
            result["shapeRendering"] = this.shapeRendering;
        }
        if (!isEmpty(this.stopColor)) {
            result["stopColor"] = this.stopColor;
        }
        if (!isEmpty(this.stopOpacity)) {
            result["stopOpacity"] = this.stopOpacity;
        }
        if (!isEmpty(this.stroke)) {
            result["stroke"] = this.stroke;
        }
        if (!isEmpty(this.strokeDasharray)) {
            result["strokeDasharray"] = this.strokeDasharray;
        }
        if (!isEmpty(this.strokeDashoffset)) {
            result["strokeDashoffset"] = this.strokeDashoffset;
        }
        if (!isEmpty(this.strokeLinecap)) {
            result["strokeLinecap"] = this.strokeLinecap;
        }
        if (!isEmpty(this.strokeLinejoin)) {
            result["strokeLinejoin"] = this.strokeLinejoin;
        }
        if (!isEmpty(this.strokeMiterlimit)) {
            result["strokeMiterlimit"] = this.strokeMiterlimit;
        }
        if (!isEmpty(this.strokeOpacity)) {
            result["strokeOpacity"] = this.strokeOpacity;
        }
        if (!isEmpty(this.strokeWidth)) {
            result["strokeWidth"] = this.strokeWidth;
        }
        if (!isEmpty(this.textAnchor)) {
            result["textAnchor"] = this.textAnchor;
        }
        if (!isEmpty(this.textDecoration)) {
            result["textDecoration"] = this.textDecoration;
        }
        if (!isEmpty(this.textRendering)) {
            result["textRendering"] = this.textRendering;
        }
        if (!isEmpty(this.unicodeBidi)) {
            result["unicodeBidi"] = this.unicodeBidi;
        }
        if (!isEmpty(this.visibility)) {
            result["visibility"] = this.visibility;
        }
        if (!isEmpty(this.wordSpacing)) {
            result["wordSpacing"] = this.wordSpacing;
        }
        if (!isEmpty(this.writingMode)) {
            result["writingMode"] = this.writingMode;
        }
    }
    item.prototype.toJsonChildren = function(result) {
        _md.svgBase.prototype.toJsonChildren.call(this, result);
        var items, item;
        items = [];
        var i, i_len=this.comments.length, item;
        for (i=0; i<i_len; i++) {
            item = this.comments[i];
            items.push(item.toJson());
        }
        result['comments'] = items;
        items = [];
        var i, i_len=this.items.length, item;
        for (i=0; i<i_len; i++) {
            item = this.items[i];
            items.push(item.toJson());
        }
        result['items'] = items;
    }
    item.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 1 && _ch == '#') {
            if (name === '#') {
                return this.wzLoadToChildColl(child, _md.comment, this.comments);
            }
        }
        if (_l == 1 && _ch == 'a') {
            if (name === 'a') {
                return this.wzLoadToChildColl(child, _md.a, this.items);
            }
        }
        if (_l == 1 && _ch == 'g') {
            if (name === 'g') {
                return this.wzLoadToChildColl(child, _md.g, this.items);
            }
        }
        if (_l == 2 && _ch == 'i') {
            if (name === 'id') {
                this.id = child.v; return true;
            }
        }
        if (_l == 3 && _ch == 's') {
            if (name === 'svg') {
                return this.wzLoadToChildColl(child, _md.svg, this.items);
            }
        }
        if (_l == 4 && _ch == 'c') {
            if (name === 'clip') {
                this.clip = child.v; return true;
            }
        }
        if (_l == 4 && _ch == 'f') {
            if (name === 'fill') {
                this.fill = child.v; return true;
            }
        }
        if (_l == 4 && _ch == 'h') {
            if (name === 'href') {
                this.href = child.v; return true;
            }
        }
        if (_l == 4 && _ch == 'i') {
            if (name === 'item') {
                return this.wzLoadToChildColl(child, _md.item, this.items);
            }
        }
        if (_l == 4 && _ch == 'l') {
            if (name === 'line') {
                return this.wzLoadToChildColl(child, _md.line, this.items);
            }
        }
        if (_l == 4 && _ch == 'm') {
            if (name === 'mask') {
                this.mask = child.v; return true;
            }
        }
        if (_l == 4 && _ch == 'p') {
            if (name === 'path') {
                return this.wzLoadToChildColl(child, _md.path, this.items);
            }
        }
        if (_l == 4 && _ch == 'r') {
            if (name === 'rect') {
                return this.wzLoadToChildColl(child, _md.rect, this.items);
            }
        }
        if (_l == 4 && _ch == 't') {
            if (name === 'text') {
                return this.wzLoadToChildColl(child, _md.text, this.items);
            }
        }
        if (_l == 5 && _ch == 'c') {
            if (name === 'color') {
                this.color = child.v; return true;
            }
        }
        if (_l == 5 && _ch == 'i') {
            if (name === 'image') {
                return this.wzLoadToChildColl(child, _md.image, this.items);
            }
        }
        if (_l == 5 && _ch == 't') {
            if (name === 'tspan') {
                return this.wzLoadToChildColl(child, _md.tspan, this.items);
            }
            else if (name === 'title') {
                return this.wzLoadToChildColl(child, _md.title, this.items);
            }
        }
        if (_l == 6 && _ch == 'c') {
            if (name === 'cursor') {
                this.cursor = child.v; return true;
            }
            else if (name === 'circle') {
                return this.wzLoadToChildColl(child, _md.circle, this.items);
            }
        }
        if (_l == 6 && _ch == 'f') {
            if (name === 'filter') {
                this.filter = child.v; return true;
            }
        }
        if (_l == 6 && _ch == 'r') {
            if (name === 'rotate') {
                this.rotate = child.v; return true;
            }
        }
        if (_l == 6 && _ch == 's') {
            if (name === 'stroke') {
                this.stroke = child.v; return true;
            }
        }
        if (_l == 7 && _ch == 'd') {
            if (name === 'display') {
                this.display = child.v; return true;
            }
        }
        if (_l == 7 && _ch == 'e') {
            if (name === 'ellipse') {
                return this.wzLoadToChildColl(child, _md.ellipse, this.items);
            }
        }
        if (_l == 7 && _ch == 'k') {
            if (name === 'kerning') {
                this.kerning = child.v; return true;
            }
        }
        if (_l == 7 && _ch == 'o') {
            if (name === 'opacity') {
                this.opacity = child.v; return true;
            }
        }
        if (_l == 7 && _ch == 'p') {
            if (name === 'polygon') {
                return this.wzLoadToChildColl(child, _md.polygon, this.items);
            }
        }
        if (_l == 8 && _ch == 'o') {
            if (name === 'overflow') {
                this.overflow = child.v; return true;
            }
        }
        if (_l == 8 && _ch == 'p') {
            if (name === 'polyline') {
                return this.wzLoadToChildColl(child, _md.polyline, this.items);
            }
        }
        if (_l == 8 && _ch == 't') {
            if (name === 'textPath') {
                return this.wzLoadToChildColl(child, _md.textPath, this.items);
            }
        }
        if (_l == 9 && _ch == 'c') {
            if (name === 'clip-path') {
                this.clipPath = child.v; return true;
            }
            else if (name === 'clip_path') {
                this.clipPath = child.v; return true;
            }
            else if (name === 'clip-rule') {
                this.clipRule = child.v; return true;
            }
            else if (name === 'clip_rule') {
                this.clipRule = child.v; return true;
            }
        }
        if (_l == 9 && _ch == 'd') {
            if (name === 'direction') {
                this.direction = child.v; return true;
            }
        }
        if (_l == 9 && _ch == 'f') {
            if (name === 'fill-rule') {
                this.fillRule = child.v; return true;
            }
            else if (name === 'fill_rule') {
                this.fillRule = child.v; return true;
            }
            else if (name === 'font-size') {
                this.fontSize = child.v; return true;
            }
            else if (name === 'font_size') {
                this.fontSize = child.v; return true;
            }
        }
        if (_l == 10 && _ch == 'f') {
            if (name === 'font-style') {
                this.fontStyle = child.v; return true;
            }
            else if (name === 'font_style') {
                this.fontStyle = child.v; return true;
            }
        }
        if (_l == 10 && _ch == 'm') {
            if (name === 'marker-end') {
                this.markerEnd = child.v; return true;
            }
            else if (name === 'marker_end') {
                this.markerEnd = child.v; return true;
            }
            else if (name === 'marker-mid') {
                this.markerMid = child.v; return true;
            }
            else if (name === 'marker_mid') {
                this.markerMid = child.v; return true;
            }
        }
        if (_l == 10 && _ch == 's') {
            if (name === 'stop-color') {
                this.stopColor = child.v; return true;
            }
            else if (name === 'stop_color') {
                this.stopColor = child.v; return true;
            }
        }
        if (_l == 10 && _ch == 'v') {
            if (name === 'visibility') {
                this.visibility = child.v; return true;
            }
        }
        if (_l == 11 && _ch == 'f') {
            if (name === 'flood-color') {
                this.floodColor = child.v; return true;
            }
            else if (name === 'flood_color') {
                this.floodColor = child.v; return true;
            }
            else if (name === 'font-family') {
                this.fontFamily = child.v; return true;
            }
            else if (name === 'font_family') {
                this.fontFamily = child.v; return true;
            }
            else if (name === 'font-weight') {
                this.fontWeight = child.v; return true;
            }
            else if (name === 'font_weight') {
                this.fontWeight = child.v; return true;
            }
        }
        if (_l == 11 && _ch == 'p') {
            if (name === 'path-length') {
                this.pathLength = child.v; return true;
            }
            else if (name === 'path_length') {
                this.pathLength = child.v; return true;
            }
        }
        if (_l == 11 && _ch == 't') {
            if (name === 'text-anchor') {
                this.textAnchor = child.v; return true;
            }
            else if (name === 'text_anchor') {
                this.textAnchor = child.v; return true;
            }
        }
        if (_l == 12 && _ch == 'f') {
            if (name === 'fill-opacity') {
                this.fillOpacity = child.v; return true;
            }
            else if (name === 'fill_opacity') {
                this.fillOpacity = child.v; return true;
            }
            else if (name === 'font-stretch') {
                this.fontStretch = child.v; return true;
            }
            else if (name === 'font_stretch') {
                this.fontStretch = child.v; return true;
            }
            else if (name === 'font-variant') {
                this.fontVariant = child.v; return true;
            }
            else if (name === 'font_variant') {
                this.fontVariant = child.v; return true;
            }
        }
        if (_l == 12 && _ch == 'm') {
            if (name === 'marker-start') {
                this.markerStart = child.v; return true;
            }
            else if (name === 'marker_start') {
                this.markerStart = child.v; return true;
            }
        }
        if (_l == 12 && _ch == 's') {
            if (name === 'stop-opacity') {
                this.stopOpacity = child.v; return true;
            }
            else if (name === 'stop_opacity') {
                this.stopOpacity = child.v; return true;
            }
            else if (name === 'stroke-width') {
                this.strokeWidth = child.v; return true;
            }
            else if (name === 'stroke_width') {
                this.strokeWidth = child.v; return true;
            }
        }
        if (_l == 12 && _ch == 'u') {
            if (name === 'unicode-bidi') {
                this.unicodeBidi = child.v; return true;
            }
            else if (name === 'unicode_bidi') {
                this.unicodeBidi = child.v; return true;
            }
        }
        if (_l == 12 && _ch == 'w') {
            if (name === 'word-spacing') {
                this.wordSpacing = child.v; return true;
            }
            else if (name === 'word_spacing') {
                this.wordSpacing = child.v; return true;
            }
            else if (name === 'writing-mode') {
                this.writingMode = child.v; return true;
            }
            else if (name === 'writing_mode') {
                this.writingMode = child.v; return true;
            }
        }
        if (_l == 13 && _ch == 'c') {
            if (name === 'color-profile') {
                this.colorProfile = child.v; return true;
            }
            else if (name === 'color_profile') {
                this.colorProfile = child.v; return true;
            }
        }
        if (_l == 13 && _ch == 'f') {
            if (name === 'flood-opacity') {
                this.floodOpacity = child.v; return true;
            }
            else if (name === 'flood_opacity') {
                this.floodOpacity = child.v; return true;
            }
        }
        if (_l == 14 && _ch == 'b') {
            if (name === 'baseline-shift') {
                this.baselineShift = child.v; return true;
            }
            else if (name === 'baseline_shift') {
                this.baselineShift = child.v; return true;
            }
        }
        if (_l == 14 && _ch == 'l') {
            if (name === 'letter-spacing') {
                this.letterSpacing = child.v; return true;
            }
            else if (name === 'letter_spacing') {
                this.letterSpacing = child.v; return true;
            }
            else if (name === 'lighting-color') {
                this.lightingColor = child.v; return true;
            }
            else if (name === 'lighting_color') {
                this.lightingColor = child.v; return true;
            }
        }
        if (_l == 14 && _ch == 'p') {
            if (name === 'pointer-events') {
                this.pointerEvents = child.v; return true;
            }
            else if (name === 'pointer_events') {
                this.pointerEvents = child.v; return true;
            }
        }
        if (_l == 14 && _ch == 's') {
            if (name === 'stroke-linecap') {
                this.strokeLinecap = child.v; return true;
            }
            else if (name === 'stroke_linecap') {
                this.strokeLinecap = child.v; return true;
            }
            else if (name === 'stroke-opacity') {
                this.strokeOpacity = child.v; return true;
            }
            else if (name === 'stroke_opacity') {
                this.strokeOpacity = child.v; return true;
            }
        }
        if (_l == 14 && _ch == 't') {
            if (name === 'text-rendering') {
                this.textRendering = child.v; return true;
            }
            else if (name === 'text_rendering') {
                this.textRendering = child.v; return true;
            }
        }
        if (_l == 15 && _ch == 'c') {
            if (name === 'color-rendering') {
                this.colorRendering = child.v; return true;
            }
            else if (name === 'color_rendering') {
                this.colorRendering = child.v; return true;
            }
        }
        if (_l == 15 && _ch == 'i') {
            if (name === 'image-rendering') {
                this.imageRendering = child.v; return true;
            }
            else if (name === 'image_rendering') {
                this.imageRendering = child.v; return true;
            }
        }
        if (_l == 15 && _ch == 's') {
            if (name === 'shape-rendering') {
                this.shapeRendering = child.v; return true;
            }
            else if (name === 'shape_rendering') {
                this.shapeRendering = child.v; return true;
            }
            else if (name === 'stroke-linejoin') {
                this.strokeLinejoin = child.v; return true;
            }
            else if (name === 'stroke_linejoin') {
                this.strokeLinejoin = child.v; return true;
            }
        }
        if (_l == 15 && _ch == 't') {
            if (name === 'text-decoration') {
                this.textDecoration = child.v; return true;
            }
            else if (name === 'text_decoration') {
                this.textDecoration = child.v; return true;
            }
        }
        if (_l == 16 && _ch == 'f') {
            if (name === 'font-size-adjust') {
                this.fontSizeAdjust = child.v; return true;
            }
            else if (name === 'font_size_adjust') {
                this.fontSizeAdjust = child.v; return true;
            }
        }
        if (_l == 16 && _ch == 's') {
            if (name === 'stroke-dasharray') {
                this.strokeDasharray = child.v; return true;
            }
            else if (name === 'stroke_dasharray') {
                this.strokeDasharray = child.v; return true;
            }
        }
        if (_l == 17 && _ch == 'd') {
            if (name === 'dominant-baseline') {
                this.dominantBaseline = child.v; return true;
            }
            else if (name === 'dominant_baseline') {
                this.dominantBaseline = child.v; return true;
            }
        }
        if (_l == 17 && _ch == 'e') {
            if (name === 'enable-background') {
                this.enableBackground = child.v; return true;
            }
            else if (name === 'enable_background') {
                this.enableBackground = child.v; return true;
            }
        }
        if (_l == 17 && _ch == 's') {
            if (name === 'stroke-dashoffset') {
                this.strokeDashoffset = child.v; return true;
            }
            else if (name === 'stroke_dashoffset') {
                this.strokeDashoffset = child.v; return true;
            }
            else if (name === 'stroke-miterlimit') {
                this.strokeMiterlimit = child.v; return true;
            }
            else if (name === 'stroke_miterlimit') {
                this.strokeMiterlimit = child.v; return true;
            }
        }
        if (_l == 18 && _ch == 'a') {
            if (name === 'alignment-baseline') {
                this.alignmentBaseline = child.v; return true;
            }
            else if (name === 'alignment_baseline') {
                this.alignmentBaseline = child.v; return true;
            }
        }
        if (_l == 19 && _ch == 'c') {
            if (name === 'color-interpolation') {
                this.colorInterpolation = child.v; return true;
            }
            else if (name === 'color_interpolation') {
                this.colorInterpolation = child.v; return true;
            }
        }
        if (_l == 26 && _ch == 'g') {
            if (name === 'glyph-orientation-vertical') {
                this.glyphOrientationVertical = child.v; return true;
            }
            else if (name === 'glyph_orientation_vertical') {
                this.glyphOrientationVertical = child.v; return true;
            }
        }
        if (_l == 27 && _ch == 'c') {
            if (name === 'color-interpolation-filters') {
                this.colorInterpolationFilters = child.v; return true;
            }
            else if (name === 'color_interpolation_filters') {
                this.colorInterpolationFilters = child.v; return true;
            }
        }
        if (_l == 28 && _ch == 'g') {
            if (name === 'glyph-orientation-horizontal') {
                this.glyphOrientationHorizontal = child.v; return true;
            }
            else if (name === 'glyph_orientation_horizontal') {
                this.glyphOrientationHorizontal = child.v; return true;
            }
        }
        return ok;
    }
    item.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    item.prototype.wzVerify = function(ctx) {
        var i, i_len=this.comments.length, item;
        for (i=0; i<i_len; i++) {
            item = this.comments[i];
            item.wzVerify(ctx);
        }
        var i, i_len=this.items.length, item;
        for (i=0; i<i_len; i++) {
            item = this.items[i];
            item.wzVerify(ctx);
        }
        _md.svgBase.prototype.wzVerify.call(this, ctx);
    }
    item.prototype.wzInitialize = function(ctx) {
        var i, i_len=this.comments.length, item;
        for (i=0; i<i_len; i++) {
            item = this.comments[i];
            item.wzInitialize(ctx);
        }
        var i, i_len=this.items.length, item;
        for (i=0; i<i_len; i++) {
            item = this.items[i];
            item.wzInitialize(ctx);
        }
        _md.svgBase.prototype.wzInitialize.call(this, ctx);
    }
    item.prototype.getAttributes = function(attrs) {
        return extractAttributes(this, 'id;href;rotate;pathLength', attrs)
        ;
    }
    item.prototype.getStyleAttributes = function() {
        var ret = [];
        var i, i_len=styles.length, style;
        for (i=0; i<i_len; i++) {
            style = styles[i];
            if (typeof(this[style.name]) !== 'undefined' && this[style.name] != null) {
                ret.push({
                    name: style.name, 
                    tag: style.tag, 
                    value: this[style.name]
                });
            }
        }
        return ret;
    }
    return item;
})(svgBase);

_md.item = item;
// element rect
var rect = (function (item) {
    _inherits(rect, item);
    function rect(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(rect.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, rect);
        this.wzElement = "rect";
        /**
             This attribute determines the x coordinate of the rect.
             Value type: <length>|<percentage> ; Default value: 0; Animatable: yes
        */
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.x = null
        /**
             This attribute determines the y coordinate of the rect.
             Value type: <length>|<percentage> ; Default value: 0; Animatable: yes
        */
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.y = null
        /**
             This attribute determines the width of the rect.
             Value type: auto|<length>|<percentage> ; Default value: auto; Animatable: yes
        */
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.width = null
        /**
             This attribute determines the height of the rect.
             Value type: auto|<length>|<percentage> ; Default value: auto; Animatable: yes
        */
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.height = null
        /**
             This attribute determines the horizontal corner radius of the rect.
             Value type: auto|<length>|<percentage> ; Default value: auto; Animatable: yes
        */
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.rx = null
        /**
             This attribute determines the vertical corner radius of the rect.
             Value type: auto|<length>|<percentage> ; Default value: auto; Animatable: yes
        */
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.ry = null
    }
    rect.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    rect.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.x)) {
            result["x"] = this.x;
        }
        if (!isEmpty(this.y)) {
            result["y"] = this.y;
        }
        if (!isEmpty(this.width)) {
            result["width"] = this.width;
        }
        if (!isEmpty(this.height)) {
            result["height"] = this.height;
        }
        if (!isEmpty(this.rx)) {
            result["rx"] = this.rx;
        }
        if (!isEmpty(this.ry)) {
            result["ry"] = this.ry;
        }
    }
    rect.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    rect.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 1 && _ch == 'x') {
            if (name === 'x') {
                this.x = child.v; return true;
            }
        }
        if (_l == 1 && _ch == 'y') {
            if (name === 'y') {
                this.y = child.v; return true;
            }
        }
        if (_l == 2 && _ch == 'r') {
            if (name === 'rx') {
                this.rx = child.v; return true;
            }
            else if (name === 'ry') {
                this.ry = child.v; return true;
            }
        }
        if (_l == 5 && _ch == 'w') {
            if (name === 'width') {
                this.width = child.v; return true;
            }
        }
        if (_l == 6 && _ch == 'h') {
            if (name === 'height') {
                this.height = child.v; return true;
            }
        }
        ok = _md.item.prototype.loadChild.call(this, child);
        return ok;
    }
    rect.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    rect.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'x;y;width;height;rx;ry', attrs)
        ;
    }
    return rect;
})(item);

_md.rect = rect;
// element svg
var svg = (function (rect) {
    _inherits(svg, rect);
    function svg(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(svg.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, svg);
        this.wzElement = "svg";
        /**
             This attribute defines the bound of the SVG viewport for the current SVG fragment.
             Value type: <list-of-numbers> ; Default value: none; Animatable: yes
        */
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.viewBox = null
        /**
             This attribute defines how the svg fragment must be deformed if it is embedded in a container with a different aspect ratio.
             Value type: (none| xMinYMin| xMidYMin| xMaxYMin| xMinYMid| xMidYMid| xMaxYMid| xMinYMax| xMidYMax| xMaxYMax) (meet|slice)? ; Default value: xMidYMid meet; Animatable: yes
        */
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.preserveAspectRatio = null
    }
    svg.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    svg.prototype.toJsonProperties = function(result) {
        _md.rect.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.viewBox)) {
            result["viewBox"] = this.viewBox;
        }
        if (!isEmpty(this.preserveAspectRatio)) {
            result["preserveAspectRatio"] = this.preserveAspectRatio;
        }
    }
    svg.prototype.toJsonChildren = function(result) {
        _md.rect.prototype.toJsonChildren.call(this, result);
    }
    svg.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 8 && _ch == 'v') {
            if (name === 'view-box') {
                this.viewBox = child.v; return true;
            }
            else if (name === 'view_box') {
                this.viewBox = child.v; return true;
            }
        }
        if (_l == 21 && _ch == 'p') {
            if (name === 'preserve-aspect-ratio') {
                this.preserveAspectRatio = child.v; return true;
            }
            else if (name === 'preserve_aspect_ratio') {
                this.preserveAspectRatio = child.v; return true;
            }
        }
        ok = _md.rect.prototype.loadChild.call(this, child);
        return ok;
    }
    svg.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    svg.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'width;height;viewBox;preserveAspectRatio', attrs)
        ;
    }
    return svg;
})(rect);

_md.svg = svg;
// element line
var line = (function (item) {
    _inherits(line, item);
    function line(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(line.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, line);
        this.wzElement = "line";
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.x1 = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.y1 = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.x2 = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.y2 = null
    }
    line.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    line.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.x1)) {
            result["x1"] = this.x1;
        }
        if (!isEmpty(this.y1)) {
            result["y1"] = this.y1;
        }
        if (!isEmpty(this.x2)) {
            result["x2"] = this.x2;
        }
        if (!isEmpty(this.y2)) {
            result["y2"] = this.y2;
        }
    }
    line.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    line.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 2 && _ch == 'x') {
            if (name === 'x1') {
                this.x1 = child.v; return true;
            }
            else if (name === 'x2') {
                this.x2 = child.v; return true;
            }
        }
        if (_l == 2 && _ch == 'y') {
            if (name === 'y1') {
                this.y1 = child.v; return true;
            }
            else if (name === 'y2') {
                this.y2 = child.v; return true;
            }
        }
        ok = _md.item.prototype.loadChild.call(this, child);
        return ok;
    }
    line.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    line.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'x1;y1;x2;y2', attrs)
        ;
    }
    return line;
})(item);

_md.line = line;
// element polyline
var polyline = (function (item) {
    _inherits(polyline, item);
    function polyline(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(polyline.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, polyline);
        this.wzElement = "polyline";
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.points = null
    }
    polyline.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    polyline.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.points)) {
            result["points"] = this.points;
        }
    }
    polyline.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    polyline.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 6 && _ch == 'p') {
            if (name === 'points') {
                this.points = child.v; return true;
            }
        }
        ok = _md.item.prototype.loadChild.call(this, child);
        return ok;
    }
    polyline.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    polyline.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'points', attrs)
        ;
    }
    return polyline;
})(item);

_md.polyline = polyline;
// element polygon
var polygon = (function (item) {
    _inherits(polygon, item);
    function polygon(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(polygon.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, polygon);
        this.wzElement = "polygon";
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.points = null
    }
    polygon.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    polygon.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.points)) {
            result["points"] = this.points;
        }
    }
    polygon.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    polygon.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 6 && _ch == 'p') {
            if (name === 'points') {
                this.points = child.v; return true;
            }
        }
        ok = _md.item.prototype.loadChild.call(this, child);
        return ok;
    }
    polygon.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    polygon.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'points:pathLength', attrs)
        ;
    }
    return polygon;
})(item);

_md.polygon = polygon;
// element circle
var circle = (function (item) {
    _inherits(circle, item);
    function circle(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(circle.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, circle);
        this.wzElement = "circle";
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.cx = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.cy = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.r = null
    }
    circle.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    circle.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.cx)) {
            result["cx"] = this.cx;
        }
        if (!isEmpty(this.cy)) {
            result["cy"] = this.cy;
        }
        if (!isEmpty(this.r)) {
            result["r"] = this.r;
        }
    }
    circle.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    circle.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 1 && _ch == 'r') {
            if (name === 'r') {
                this.r = child.v; return true;
            }
        }
        if (_l == 2 && _ch == 'c') {
            if (name === 'cx') {
                this.cx = child.v; return true;
            }
            else if (name === 'cy') {
                this.cy = child.v; return true;
            }
        }
        ok = _md.item.prototype.loadChild.call(this, child);
        return ok;
    }
    circle.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    circle.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'cx;cy;r', attrs)
        ;
    }
    return circle;
})(item);

_md.circle = circle;
// element ellipse
var ellipse = (function (item) {
    _inherits(ellipse, item);
    function ellipse(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(ellipse.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, ellipse);
        this.wzElement = "ellipse";
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.cx = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.cy = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.rx = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.ry = null
    }
    ellipse.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    ellipse.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.cx)) {
            result["cx"] = this.cx;
        }
        if (!isEmpty(this.cy)) {
            result["cy"] = this.cy;
        }
        if (!isEmpty(this.rx)) {
            result["rx"] = this.rx;
        }
        if (!isEmpty(this.ry)) {
            result["ry"] = this.ry;
        }
    }
    ellipse.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    ellipse.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 2 && _ch == 'c') {
            if (name === 'cx') {
                this.cx = child.v; return true;
            }
            else if (name === 'cy') {
                this.cy = child.v; return true;
            }
        }
        if (_l == 2 && _ch == 'r') {
            if (name === 'rx') {
                this.rx = child.v; return true;
            }
            else if (name === 'ry') {
                this.ry = child.v; return true;
            }
        }
        ok = _md.item.prototype.loadChild.call(this, child);
        return ok;
    }
    ellipse.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    ellipse.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'cx;cy;rx;ry', attrs)
        ;
    }
    return ellipse;
})(item);

_md.ellipse = ellipse;
// element path
var path = (function (item) {
    _inherits(path, item);
    function path(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(path.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, path);
        this.wzElement = "path";
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.d = null
    }
    path.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    path.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.d)) {
            result["d"] = this.d;
        }
    }
    path.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    path.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 1 && _ch == 'd') {
            if (name === 'd') {
                this.d = child.v; return true;
            }
        }
        ok = _md.item.prototype.loadChild.call(this, child);
        return ok;
    }
    path.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    path.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'd', attrs)
        ;
    }
    return path;
})(item);

_md.path = path;
// element text
var text = (function (item) {
    _inherits(text, item);
    function text(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(text.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, text);
        this.wzElement = "text";
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.x = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.y = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fontFamily = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.fontSize = null
    }
    text.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    text.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.x)) {
            result["x"] = this.x;
        }
        if (!isEmpty(this.y)) {
            result["y"] = this.y;
        }
        if (!isEmpty(this.fontFamily)) {
            result["fontFamily"] = this.fontFamily;
        }
        if (!isEmpty(this.fontSize)) {
            result["fontSize"] = this.fontSize;
        }
    }
    text.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    text.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 1 && _ch == 'x') {
            if (name === 'x') {
                this.x = child.v; return true;
            }
        }
        if (_l == 1 && _ch == 'y') {
            if (name === 'y') {
                this.y = child.v; return true;
            }
        }
        if (_l == 9 && _ch == 'f') {
            if (name === 'font-size') {
                this.fontSize = child.v; return true;
            }
            else if (name === 'font_size') {
                this.fontSize = child.v; return true;
            }
        }
        if (_l == 11 && _ch == 'f') {
            if (name === 'font-family') {
                this.fontFamily = child.v; return true;
            }
            else if (name === 'font_family') {
                this.fontFamily = child.v; return true;
            }
        }
        ok = _md.item.prototype.loadChild.call(this, child);
        return ok;
    }
    text.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    text.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'x;y;fontFamily;fontSize', attrs)
        ;
    }
    return text;
})(item);

_md.text = text;
// element textPath
var textPath = (function (item) {
    _inherits(textPath, item);
    function textPath(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(textPath.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, textPath);
        this.wzElement = "textPath";
    }
    textPath.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    textPath.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
    }
    textPath.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    return textPath;
})(item);

_md.textPath = textPath;
// element tspan
var tspan = (function (item) {
    _inherits(tspan, item);
    function tspan(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(tspan.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, tspan);
        this.wzElement = "tspan";
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.x = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.y = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.dx = null
        // TODO avoid this declaration, attributes should be tested for undefined not null
        // set this.dy = null
    }
    tspan.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    tspan.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
        if (!isEmpty(this.x)) {
            result["x"] = this.x;
        }
        if (!isEmpty(this.y)) {
            result["y"] = this.y;
        }
        if (!isEmpty(this.dx)) {
            result["dx"] = this.dx;
        }
        if (!isEmpty(this.dy)) {
            result["dy"] = this.dy;
        }
    }
    tspan.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    tspan.prototype.loadChild = function(child) {
        // Make test case insensitive
        var item,
            ok = false,
            name = child.n.toLowerCase(),
            _l = name.length,
            _ch = name[0];
        if (_l == 1 && _ch == 'x') {
            if (name === 'x') {
                this.x = child.v; return true;
            }
        }
        if (_l == 1 && _ch == 'y') {
            if (name === 'y') {
                this.y = child.v; return true;
            }
        }
        if (_l == 2 && _ch == 'd') {
            if (name === 'dx') {
                this.dx = child.v; return true;
            }
            else if (name === 'dy') {
                this.dy = child.v; return true;
            }
        }
        ok = _md.item.prototype.loadChild.call(this, child);
        return ok;
    }
    tspan.prototype.loadFromNode = function(node) {
        var loaded = false;
        // TODO VIA after transition to node.children
        var children = node.children;
        var i, i_len=children.length, item;
        for (i=0; i<i_len; i++) {
            item = children[i];
            loaded = this.loadChild(item);
            if (!loaded) {
                throw new _md.svgModelException("Tag not recognized: " + item.n, item, this);
            }
        }
    }
    tspan.prototype.getAttributes = function(attrs) {
        attrs = _md.item.prototype.getAttributes.call(this, attrs);
        return extractAttributes(this, 'x;y;dx;dy', attrs)
        ;
    }
    return tspan;
})(item);

_md.tspan = tspan;
/**
    element a
     link
     a
        href http://tecfa.unige.ch
        rect
            fill #00FF00
            stroke #00FF00
            width 300
            height 40
            ry 5
            rx 5
            y 80
            x 50
        text TECFA POWER 1 click away
            x 100
            y 110
            stroke #000099
            fill #000099
            font-size 24
*/
var a = (function (item) {
    _inherits(a, item);
    function a(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(a.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, a);
        this.wzElement = "a";
    }
    a.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    a.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
    }
    a.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    return a;
})(item);

_md.a = a;
/**
    element g
     grouping
*/
var g = (function (item) {
    _inherits(g, item);
    function g(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(g.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, g);
        this.wzElement = "g";
    }
    g.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    g.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
    }
    g.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    return g;
})(item);

_md.g = g;
// element image
var image = (function (rect) {
    _inherits(image, rect);
    function image(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(image.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, image);
        this.wzElement = "image";
    }
    image.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    image.prototype.toJsonProperties = function(result) {
        _md.rect.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
    }
    image.prototype.toJsonChildren = function(result) {
        _md.rect.prototype.toJsonChildren.call(this, result);
    }
    return image;
})(rect);

_md.image = image;
// element title
var title = (function (item) {
    _inherits(title, item);
    function title(name, sourceLineInfo) {
        _get(Object.getPrototypeOf(title.prototype), 'constructor', this).call(this, name,sourceLineInfo);
        _classCallCheck(this, title);
        this.wzElement = "title";
    }
    title.prototype.toJson = function() {
        var result = {};
        this.toJsonProperties(result);
        this.toJsonChildren(result);
        return result;
    }
    title.prototype.toJsonProperties = function(result) {
        _md.item.prototype.toJsonProperties.call(this, result);
        if (this.__jsonProps) {
            for (var k in this.__jsonProps) {
                result[k] = this.__jsonProps[k];
            }
        }
    }
    title.prototype.toJsonChildren = function(result) {
        _md.item.prototype.toJsonChildren.call(this, result);
    }
    return title;
})(item);

_md.title = title;
_md.__tagElementMapping = { '#': 'comment' };
// model/replaceUnknownElement( )
var svgModelException = (function () {
    function svgModelException(message, node, instance) {
        _classCallCheck(this, svgModelException);
        // TODO node seems superflous
        if (node && instance) {
            this.message = message + ', wzElement: ' + node.wzElement + ', wzName:' + (node.wzName || '') + ', row:' + node.r + ', col:' + node.c + ', source:' + instance.wzSourceFilepath(node.u);
        }
        else if (instance) {
            this.message = message + instance.wzSourceLineInfo.toString(instance);
        }
        else {
            this.message = message;
        }
        console.log('message', this.message);
        this.stack = (new Error()).stack;
        this.node = node;
    }
    return svgModelException;
})();

_md.svgModelException = svgModelException;
var svgContext = (function () {
    function svgContext() {
        _classCallCheck(this, svgContext);
        this.validationErrors = [];
    }
    svgContext.prototype.schemaIsValid = function() {
        return this.validationErrors.length == 0;
    }
    svgContext.prototype.addError = function(message, node) {
        var at = node ? ' At ' + node.wzSourceLineInfo.toString(node) : '';
        this.validationErrors.push(message + at);
    }
    return svgContext;
})();

_md.svgContext = svgContext;
function parsestring(value, defaultValue, node) {
    if (isEmpty( value )) {
        return defaultValue;
    }
    return value;
}
function isString(value) {
    return (typeof value === 'string' || value instanceof String);
}
function isEmpty(value) {
    return !isString( value ) || value.length === 0;
}
function isBoolean(value) {
    return value === 'true' || value === 'false';
}
function extractAttributes(item, names_string, attrs) {
    if (!attrs) {
        attrs = [];
    }
    if (verify.isNotEmpty(names_string)) {
        var names = names_string.split(';');
        var i, i_len=names.length, name;
        for (i=0; i<i_len; i++) {
            name = names[i];
            if (typeof(item[name]) !== 'undefined' && item != null) {
                attrs.push({
                    name: name, 
                    value: item[name]
                });
            }
        }
    }
    return attrs;
}

