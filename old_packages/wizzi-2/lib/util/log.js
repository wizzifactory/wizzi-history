/*
    artifact generator: /wizzi/lib/artifacts/js/module/gen/main.js
    primary source IttfDocument: C:\My\wizzi\v2\sources\wizzi-2-boot\ittf\lib\util\log.js.ittf
    utc time: Tue, 11 Jul 2017 17:02:26 GMT
*/
'use strict';
// generated by js.module.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var util = require('util');
var path = require('path');
var fs = require('fs');
var chalk = require('chalk');
var fileLoggingEnabled = false;
function buildMessage(color,args) {
    if (typeof (args) !== 'object') {
        return '';
    }
    var msg = '';
    for (var i = 0; i < args.length; i++) {
        if (args[i]) {
            msg += (' ' + util.inspect(args[i]));
        }
    }
    return color(msg);
}

var MyLogger = (function () {
    function MyLogger(level,stream) {
        _classCallCheck(this, MyLogger);
        this.level = level;
        this.stream = (stream || process.stdout);
    }
    MyLogger.prototype.info = function(id,level,text) {
        var date = new Date();
        var seconds = date.getSeconds();
        var minutes = date.getMinutes();
        var hour = date.getHours();
        this.stream.write(hour + ':' + minutes + ':' + seconds + ' ' + id + ' ' + level + ' ' + text + '\n');
    }
    return MyLogger;
})();


var Log = (function () {
    function Log(id,logger) {
        _classCallCheck(this, Log);
        this.id = id;
        this.logger = logger;
        this.level = 2;
    }
    Log.prototype.setLevel = function(level) {
        this.level = level;
    }
    Log.prototype.info = function() {
        if (this.level > 1) {
            this.logger.info(this.id, "INFO", buildMessage(chalk.white, arguments)
            );
        }
    }
    Log.prototype.warn = function() {
        if (this.level > 0) {
            this.logger.info(this.id, "WARNING", buildMessage(chalk.yellow, arguments)
            );
        }
    }
    Log.prototype.error = function() {
        this.logger.info(this.id, "ERROR", buildMessage(chalk.red, arguments)
        );
    }
    Log.prototype.success = function() {
        if (this.level > 1) {
            this.logger.info(this.id, "SUCCESS", buildMessage(chalk.green, arguments)
            );
        }
    }
    return Log;
})();


var consoleLogger = new MyLogger('debug');
var fileLoggers = {};
function getFileLogger(filename) {
    var dirname = path.dirname(filename);
    if (fileLoggers[dirname]) {
        return fileLoggers[dirname].logger;
    }
    var logfile = path.join(dirname, 'debug.log');
    console.log('creating debug.log for: ', filename.substr((filename.length - 50)));
    var stream = fs.createWriteStream(logfile);
    var logger = new MyLogger('debug', stream);
    fileLoggers[dirname] = {
        logger: logger, 
        stream: stream
    };
    logFlushSetup();
    return logger;
}

var logFlush_setup = false;
function logFlushSetup(stream) {
    if (logFlush_setup) {
        return ;
    }
    logFlush_setup = true;
    var logFlush_flushed = false;
    function exitHandler() {
        if (!logFlush_flushed) {
            for (var k in fileLoggers) {
                fileLoggers[k].stream.end();
                console.log("log. flushed : " + k.substr(k.length - 50));
            }
            logFlush_flushed = true;
        }
        process.exit();
    }
    process.on('exit', function(err) {
        console.log('util.log. Process.exit', err);
        exitHandler();
    });
    process.on('SIGINT', function(err) {
        console.log('util.log. Received Signal', err);
        exitHandler();
    });
    process.on('uncaughtException', function(err) {
        console.error("util.log. " + new Date().toUTCString() + ' uncaughtException:', err.message);
        console.error(err.stack);
        exitHandler();
    });
}

module.exports = function(module,options) {
    options = (options || {});
    var logger;
    if (fileLoggingEnabled && options.tofile) {
        logger = getFileLogger(module.filename);
    }
    else {
        logger = consoleLogger;
    }
    return new Log(path.basename(module.filename)
        , logger);
};
