/*
    artifact generator: /wizzi/lib/artifacts/js/module/gen/main.js
    primary source IttfDocument: C:\My\wizzi\v2\sources\wizzi-2-boot\ittf\lib\ittf\ittfModel.js.ittf
    utc time: Tue, 11 Jul 2017 17:02:26 GMT
*/
'use strict';
// generated by js.module.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var util = require('util');
var errors = require('../errors');
var types = require('../util/types');
var lexer = require('./lexer');
var parser = require('./parser');
var IttfModel = (function () {
    function IttfModel(uri,loadContext) {
        _classCallCheck(this, IttfModel);
        this.uri = uri;
        this.loadContext = loadContext;
    }
    IttfModel.prototype.load = function(ittfSourceTextContent,ittfDocumentData) {
        if (typeof(ittfSourceTextContent) !== 'string') {
            throw new TypeError('ittfSourceTextContent must be a string');
        }
        if (!ittfDocumentData && typeof(ittfDocumentData.sourceKey) === 'string') {
            throw new TypeError('ittfDocumentData.sourceKey must be a string');
        }
        var lines = lexer(ittfSourceTextContent, ittfDocumentData);
        if (lines && lines.__is_error) {
            return lines;
        }
        var nodes = parser(lines, this);
        if (nodes && nodes.__is_error) {
            return nodes;
        }
        this.nodes = nodes;
    }
    IttfModel.prototype.setKeys = function(sourceKey,modelKey) {
        this.sourceKey = sourceKey;
        this.modelKey = modelKey;
    }
    IttfModel.prototype.clone = function() {
        var clonedModel = new IttfModel(this.uri, this.loadContext);
        if (this.$params) {
            clonedModel.$params = this.$params;
        }
        clonedModel.nodes = this._cloneNodes(this.nodes, null, clonedModel);
        return clonedModel;
    }
    IttfModel.prototype._cloneNodes = function(nodes,parent,clonedModel) {
        var self = this;
        var clnode,
            clnodes = [];
        var i, i_len=nodes.length, node;
        for (i=0; i<i_len; i++) {
            node = nodes[i];
            clnode = {
                id: self.loadContext.getNewNodeId(), 
                parsedId: node.id, 
                name: node.name, 
                value: node.value, 
                tagSuffix: node.tagSuffix, 
                row: node.row, 
                col: node.col, 
                sourceKey: node.sourceKey, 
                hasMacro: node.hasMacro, 
                parent: parent, 
                model: clonedModel
            };
            clnode.childs = self._cloneNodes(node.childs, clnode, clonedModel);
            clnodes.push(clnode);
        }
        return clnodes;
    }
    IttfModel.prototype.getParamValues = function(args) {
        var params = this.$params;
        var ittfModelRootNode = this.nodes[0];
        var _paramArray = [],
            _argsArray = [];
        if (params !== null && typeof(params) === 'string' && params.length > 0) {
            _paramArray = params.trim().split(',');
        }
        if (args !== null && typeof(args) === 'string' && args.length > 0) {
            _argsArray = args.trim().split(',');
        }
        var result = [];
        for (var i = 0; i < _paramArray.length; i++) {
            var name,
                type = 'string',
                defaultValue = null,
                value = null,
                hasparamvalue = false,
                hasdefaultvalue = false;
            // a param may have the format
            // 1) name
            // 2) name|default
            // 3) name:type|default
            // valid types: string(default), integer, float, boolean, date
            var param_parts = _paramArray[i].trim().split(/[|]/)
            ;
            if (param_parts.length > 2) {
                return this.error('Error evaluating: $params ' + params + ' , Argument ' + i + ' is malformed. Expected name[:type[|default]]', ittfModelRootNode, 'getParamValues')
                ;
            }
            if (param_parts.length == 2) {
                defaultValue = param_parts[1].trim();
                hasdefaultvalue = true;
            }
            param_parts = param_parts[0].trim().split(/[:]/)
            ;
            if (param_parts.length > 2) {
                return this.error('Error evaluating: $params ' + params + ', argument ' + i + ' is malformed. Expected name[:type[|default]]', ittfModelRootNode, 'getParamValues')
                ;
            }
            if (param_parts.length == 2) {
                type = param_parts[1];
            }
            name = param_parts[0];
            if (name.substr(0, 1) === '&') {
                name = name.substr(1);
                type = 'object';
            }
            if (_argsArray.length > i) {
                value = _argsArray[i].trim();
                if (type === 'object') {
                    if (value.substr(0, 1) !== '&') {
                        return this.error('Error evaluating: $params ' + params + ', argument (' + i + ') must be an object reference. Found ' + value, ittfModelRootNode, 'getParamValues')
                        ;
                    }
                    else {
                        value = value.substr(1);
                    }
                }
                else {
                    value = types.objectify(value, type, ittfModelRootNode, true);
                    if (value && value.__is_error) {
                        var error = this.error('Error evaluating: $params ' + params + ', objectifying parameter: ' + i + '/' + name, ittfModelRootNode, 'getParamValues')
                        ;
                        error.inner = value;
                        return error;
                    }
                }
                hasparamvalue = true;
            }
            else if (hasdefaultvalue) {
                value = types.objectify(defaultValue, type, ittfModelRootNode, true);
                if (value && value.__is_error) {
                    var error = this.error('Error evaluating: $params ' + params + ', objectifying parameter: ' + i + '/' + name, ittfModelRootNode, 'getParamValues')
                    ;
                    error.inner = value;
                    return error;
                }
            }
            else {
                return this.error('Error evaluating: $params ' + params + ', missing value for not optional argument ' + i + ' = ' + name, ittfModelRootNode, 'getParamValues')
                ;
            }
            var isTemplate = type === 'object' ? false : types.isTemplate(value);
            result.push({
                name: name.substr(0, 1) === '&' ? name.substr(1) : name, 
                value: value, 
                type: type, 
                isTemplate: isTemplate, 
                isByRef: type === 'object'
            });
        }
        return result;
    }
    IttfModel.prototype.dump = function(evaluated) {
        var buffer = [],
            ctx = {
                evaluated: evaluated
            };
        this.nodes.forEach(function(node) {
            _dumpNodeDeep(node, 1, buffer, ctx);
        });
        return buffer.join('\n');
    }
    IttfModel.prototype.toIttf = function() {
        var buffer = [];
        this.nodes.forEach(function(node) {
            _toIttfNodeDeep(node, 0, buffer);
        });
        return buffer.join('\n');
    }
    IttfModel.prototype._toIttfNodeDeep = function(node,indent,buffer) {
        buffer.push(spaces(indent * 4) + node.n + ' ' + (node.v || ''));
        indent++;
        var i, i_len=node.childs.length, child;
        for (i=0; i<i_len; i++) {
            child = node.childs[i];
            _toIttfNodeDeep(child, indent, buffer);
        }
    }
    IttfModel.prototype.toText = function() {
        var buffer = [];
        if (this.nodes.length == 1) {
            var root = this.nodes[0];
            var i, i_len=root.childs.length, child;
            for (i=0; i<i_len; i++) {
                child = root.childs[i];
                _toTextNodeDeep(child, 0, buffer);
            }
        }
        return buffer.join('\n');
    }
    IttfModel.prototype.error = function(message,node,method) {
        var err = {
            __is_error: true, 
            message: message, 
            source: "wizzi/lib/ittf/ittfModel/" + method
        };
        return err;
    }
    return IttfModel;
})();

function _dumpNodeDeep(node,indent,buffer,ctx) {
    if (ctx.evaluated) {
        buffer.push(spaces(indent * 2) + node.n + ' ' + (node.v || '') + ' ids: ' + node.parsedId + ' ' + node.id);
    }
    else {
        buffer.push(spaces(indent * 2) + node.name + ' ' + (node.value || '') + ' ids: ' + node.parsedId + ' ' + node.id);
    }
    if (node.model) {
        if (node.model.$args || node.model.$params) {
            if (!ctx[node.model.modelKey]) {
                ctx[node.model.modelKey] = node.model;
                buffer.push(spaces(indent * 2) + '  $args: ' + node.model.$args + ' $params: ' + node.model.$params);
            }
        }
    }
    indent++;
    node.childs.forEach(function(n) {
        _dumpNodeDeep(n, indent, buffer, ctx);
    });
}

function _toTextNodeDeep(node,indent,buffer) {
    buffer.push(spaces(indent * 4) + node.n + ' ' + node.v || '');
    indent++;
    var i, i_len=node.childs.length, child;
    for (i=0; i<i_len; i++) {
        child = node.childs[i];
        _toTextNodeDeep(child, indent, buffer);
    }
}

function spaces(num) {
    return Array(num + 1).join(" ")
    ;
}

module.exports = {
    IttfModel: IttfModel
};
