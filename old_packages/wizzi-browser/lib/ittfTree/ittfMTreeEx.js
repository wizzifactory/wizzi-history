/*
    artifact generator: C:\My\wizzi\v5\node_modules\wizzi-js\lib\artifacts\js\module\gen\main.js
    primary source IttfDocument: c:\my\wizzi\v5\kernel\wizzi-utils\src\ittf\lib\ittftree\ittfmtreeex.js.ittf
*/
'use strict';
// generated by wizzi.codegen.js4.es2015.module
function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

var path = require('path');
var async = require('async');
var vfile = require('../fs/vfile');
var verify = require('../verify');
var asIsLoader = require('./asIsLoader');
var IttfFinder = require('./ittfFinder');
/** -àà
    
     Simple mTreeBrick structure
     { mTreeNode
     string name
     string value
     integer id?
     [ children
     { mTreeNode
    
     That can be used to build or analize an mTreeBrick.
     Usefull for
     - analizing raw ittf documents, before composition and evaluation, for
     documentation purposes;
     - building mTreeBricks by code.
    
     can be loaded
     - from a source ittf document (loaded as is, no composition and evaluation)
     - from a loaded mTree (less usefull)
     - calling the 'add' and 'insertAt' methods
    
     can be analized to detect
     - path of called mixins and includes
     - ittf node commands
     - nodes with jswizzi statements
     - nodes commented out
    
     can be exported to
     - a new mTreeBrick
     - appended to an existing mTreeNode
    
     Is Used by ittfHtmlPrettifier to analize and prettify
    
     The default store kind is 'filesystem' or 'browser'.
     Otherwise a vfile instance must be passed in the property 'file' of
     the 'options' param of the 'loadFrom' method.
*/
var IttfMTreeEx = (function () {
    function IttfMTreeEx(name, value, parent) {
        _classCallCheck(this, IttfMTreeEx);
        this.name = name;
        this.value = value || '';
        this.parent = parent || null;
        this.children = [];
        if (this.parent == null) {
            this.fragments = {};
            this.ittfReferences = {};
            this.errorFragments = [];
        }
    }
    IttfMTreeEx.prototype.root = function() {
        return this.parent == null ? this : this.parent.root();
    }
    IttfMTreeEx.prototype.preAdd = function(name, value) {
        if ({}.toString.call(name) === '[object Object]' && name.name) {
            name.parent = this;
            return name;
        }
        else {
            return new IttfMTreeEx(name, value, this);
        }
    }
    IttfMTreeEx.prototype.insertAt = function(name, value, pos) {
        var node = this.preAdd(name, value);
        if (pos > this.children.length) {
            this.children.push(node);
        }
        else {
            this.children.splice(pos, 0, node);
        }
        return node;
    }
    IttfMTreeEx.prototype.add = function(name, value) {
        var node = this.preAdd(name, value);
        this.children.push(node);
        return node;
    }
    IttfMTreeEx.prototype.append = function(sb, indent) {
        // log 'sb',sb
        sb.push(indentTabs(indent) + this.name + (this.value && this.value.length > 0 ? ' ' + this.value : ''));
        var i, i_items=this.children, i_len=this.children.length, node;
        for (i=0; i<i_len; i++) {
            node = this.children[i];
            node.append(sb, indent + 1);
        }
    }
    IttfMTreeEx.prototype.writeFile = function(string_path, callback) {
        var sb = [];
        this.append(sb, 0);
        this.file.write(string_path, sb.join('\n'));
        callback(null);
    }
    IttfMTreeEx.prototype.toString = function() {
        var sb = [];
        this.append(sb, 0);
        return sb.join('\n');
    }
    IttfMTreeEx.prototype.loadFromNode = function(node, $params) {
        this.name = (node.name || node.n) + (node.tagSuffix || '');
        this.value = node.value || node.v || '';
        this.row = node.row || node.r || '';
        this.col = node.col || node.c || '';
        if (node.id) {
            this.id = node.id;
        }
        if ($params && $params.length > 0) {
            this.add('$params', $params, this);
        }
        this.__importChilds(node.children);
    }
    IttfMTreeEx.prototype.__importChilds = function(children) {
        var added;
        if (children && children.length) {
            var i, i_items=children, i_len=children.length, node;
            for (i=0; i<i_len; i++) {
                node = children[i];
                added = this.add((node.name || node.n) + (node.tagSuffix || ''), node.value || node.v || '');
                added.row = node.row || node.r || '';
                added.col = node.col || node.c || '';
                if (node.id) {
                    added.id = node.id;
                }
                added.commentState = node.commentState;
                added.__importChilds(node.children);
            }
        }
    }
    IttfMTreeEx.prototype.__getVFile = function(options, callback) {
        if (options.file) {
            this.file = options.file;
            return callback(null, options.file);
        }
        else {
            // load the default vfile (filesystem or browser)
            var that = this;
            return vfile(function(err, file) {
                    if (err) {
                        return callback(err);
                    }
                    that.file = file;
                    return callback(null, file);
                });
        }
    }
    IttfMTreeEx.prototype.__loadMTree = function(objFrom, options, callback) {
        var that = this;
        this.__getVFile(options, function(err, file) {
            if (err) {
                return callback(err);
            }
            options.file = file;
            if (verify.isObject(objFrom)) {
                // log 'ittfMTreeEx.__loadMTree. objFrom is an object'
                if (verify.isArray(objFrom.nodes) && objFrom.nodes.length == 1) {
                    that.loadFromNode(objFrom.nodes[0], objFrom.$params);
                }
                else if ((objFrom.name || objFrom.n) && objFrom.children) {
                    that.loadFromNode(objFrom, objFrom.$params);
                }
                else {
                    return callback({
                            __is_error: true, 
                            method: 'wizzi-utils.ittfMTreeEx.__loadMTree', 
                            message: 'Invalid object parameter: objFrom. The object is not an mTree object.'
                        });
                }
                return callback(null, that);
            }
            else if (verify.isNotEmpty(objFrom)) {
                // log 'ittfMTreeEx.__loadMTree. objFrom is a string'
                that.model = {
                    uri: (options.fromString ? 'string://' : objFrom), 
                    dirname: (options.fromString ? '' : path.dirname(objFrom))
                };
                if (options.fromString) {
                    // log 'ittfMTreeEx.__loadMTree. Loading from text string'
                    asIsLoader.createFromString(objFrom, options, function(err, asisMTree) {
                        if (err) {
                            return callback(err);
                        }
                        that.content = asisMTree.content;
                        // log 'ittfMTreeEx.asis.loader.asisMTree.nodes.length', asisMTree.nodes.length, !asisMTree.nodes[0]
                        that.loadFromNode(asisMTree.nodes[0], asisMTree.$params);
                        return callback(null, that);
                    });
                }
                else {
                    // log 'ittfMTreeEx.__loadMTree. Loading from file'
                    // load from file using the vfile class
                    file.isFile(objFrom, function(err, isFile) {
                        if (err) {
                            return callback(err);
                        }
                        if (isFile == false) {
                            return callback({
                                    __is_error: true, 
                                    method: 'wizzi-utils.ittfMTreeEx.__loadMTree', 
                                    message: 'Document not found: ' + objFrom
                                });
                        }
                        else {
                            asIsLoader(objFrom, options, function(err, asisMTree) {
                                if (err) {
                                    return callback(err);
                                }
                                that.content = asisMTree.content;
                                // log 'ittfMTreeEx.asis.loader.asisMTree.nodes.length', asisMTree.nodes.length, !asisMTree.nodes[0]
                                that.loadFromNode(asisMTree.nodes[0], asisMTree.$params);
                                that.model.basename = path.basename(objFrom);
                                var ss = that.model.basename.split('.');
                                that.model.isIttf = ss[ss.length-1] === 'ittf';
                                if (that.model.isIttf) {
                                    that.model.schema = ss[ss.length-2].toLowerCase();
                                    that.model.seedName = ss.slice(0,-2).join('.');
                                    if (that.model.schema !== 'json') {
                                        that.model.jsonTwinUri = path.join(that.model.dirname, that.model.seedName + '.json.ittf');
                                    }
                                }
                                // log 'ittfMTreeEx.loadFrom.ittf.model', that.model
                                return callback(null, that);
                            });
                        }
                    });
                }
            }
            else {
                return callback({
                        __is_error: true, 
                        method: 'wizzi-utils.ittfMTreeEx.__loadMTree', 
                        message: 'Invalid parameter: objFrom'
                    });
            }
        });
    }
    IttfMTreeEx.createFrom = function(objFrom, options, callback) {
        if (typeof(callback) === 'undefined' && verify.isFunction(options)) {
            callback = options;
            options = {};
        }
        else {
            options = options || {};
        }
        function clean(node) {
             delete node.parent
             delete node.model
            if (node.children) {
                var i, i_items=node.children, i_len=node.children.length, item;
                for (i=0; i<i_len; i++) {
                    item = node.children[i];
                    clean(item);
                }
            }
            return node;
        }
        var mTree = new IttfMTreeEx();
        mTree.__loadMTree(objFrom, options, function(err, mTree) {
            if (err) {
                return callback(err);
            }
            // log 'wizzi-utils.ittfMTreeEx.createFrom. Received mTree', mTree.name, mTree.value
            if (options.clean) {
                clean(mTree);
            }
            callback(null, mTree);
        });
    }
    IttfMTreeEx.prototype.toMTreePiece = function(parent) {
        if (!parent) {
            parent = {
                parent: null, 
                name: this.name, 
                value: this.value, 
                children: []
            };
        }
        var i, i_items=this.children, i_len=this.children.length, item;
        for (i=0; i<i_len; i++) {
            item = this.children[i];
            var child = {
                parent: parent, 
                name: item.name, 
                value: item.value, 
                children: []
            };
            item.toMTreePiece(child);
            parent.children.push(child);
        }
        return parent;
    }
    IttfMTreeEx.prototype.isCommand = function() {
        return this.name && this.name[0] === '$';
    }
    IttfMTreeEx.prototype.isExpressionCommand = function() {
        return this.name && ['$if', '$elif', '$foreach', '$backeach', '$while'].indexOf(this.name) == 0;
    }
    IttfMTreeEx.prototype.isCodeDeclare = function() {
        return this.name && ['$', '$global'].indexOf(this.name) == 0;
    }
    IttfMTreeEx.prototype.isMultilineDeclare = function() {
        return this.name && ['$.'].indexOf(this.name) == 0;
    }
    IttfMTreeEx.prototype.isCode = function() {
        var test = this.parent;
        while (test) {
            if (test.isCodeDeclare()) {
                return true;
            }
            test = test.parent;
        }
        return false;
    }
    IttfMTreeEx.prototype.isMixinCall = function() {
        return this.name && this.name.substr(-1,1) === '(';
    }
    IttfMTreeEx.prototype.isIncludeCall = function() {
        return this.name === '$include';
    }
    IttfMTreeEx.prototype.isReferenceToIttf = function() {
        if (verify.isNotEmpty(this.getValueStripComments())) {
            // log 'isReferenceToIttf.this.getValueStripComments()', verify.endsWith(this.getValueStripComments(), '.ittf')
            return verify.endsWith(this.getValueStripComments(), '.ittf');
        }
        else {
            return false;
        }
    }
    IttfMTreeEx.prototype.isLineContinuation = function() {
        return this.name && ['\\', '\\b', '\\n'].indexOf(this.name) == 0;
    }
    IttfMTreeEx.prototype.getMixinArgs = function() {
        var ret = [];
        if (this.isMixinCall()) {
            var v = this.getValueStripComments();
            if (v.substr(-1) === ')') {
                v = v.substr(0, v.length-1);
            }
            var ss = v.split(',');
            var i, i_items=ss, i_len=ss.length, s;
            for (i=0; i<i_len; i++) {
                s = ss[i];
                if (s.length > 0) {
                    ret.push(s);
                }
            }
        }
        return ret;
    }
    IttfMTreeEx.prototype.getValueStripComments = function() {
        var ndx = this.value.indexOf('$$');
        if (ndx < 0) {
            ndx = this.value.indexOf('$*');
        }
        if (ndx < 0) {
            return this.value;
        }
        return this.value.substr(0, ndx).trim();
    }
    IttfMTreeEx.prototype.getValueParsed = function() {
        //
        // Parses this mTree node value property
        // detecting interpolations: ${expr}
        // Returns an array of value parts where part items can be
        // of type 0 (normal text) or 1 (interpolated expr)
        //
        // return
        // [ parts
        // { part
        // integer t
        // one-of: 0 (text), 1 (expr)
        // string v
        // # text or expr
        //
        var v = this.value.trim(),
            len = v.length,
            ch,
            i,
            parts = [],
            partsIndex = 0,
            text = [],
            expr = [],
            state = 0;
        for (i=0; i<len; i++) {
            ch = v[i];
            if (ch == '$') {
                if (state == 0) {
                    state = 1;
                }
                else if (state == 1) {
                    text.push('$');
                    text.push(ch);
                    state = 0;
                }
                else {
                    expr.push(ch);
                }
            }
            else if (ch == '{') {
                if (state == 0) {
                    text.push(ch);
                }
                else if (state == 1) {
                    state = 2;
                }
                else {
                    expr.push(ch);
                }
            }
            else if (ch == '}' && state == 2) {
                if (text.length > 0) {
                    parts.push({
                        t: 0, 
                        v: text.join('')
                    });
                    text = [];
                }
                parts.push({
                    t: 1, 
                    v: expr.join('')
                });
                expr = [];
                state = 0;
            }
            else if (state == 0) {
                text.push(ch);
            }
            else if (state == 1) {
                text.push('$');
                text.push(ch);
                state = 0;
            }
            else if (state == 2) {
                expr.push(ch);
            }
        }
        if (text.length > 0) {
            parts.push({
                t: 0, 
                v: text.join('')
            });
            text = [];
        }
        return parts;
    }
    // called on the root node
    // for example by ittfHtmlPrettifier
    // params
    // { ctx
    // { fragments
    // { ittfReferences
    // { ittfFsNode
    // string ittfBasePath
    IttfMTreeEx.prototype.analize = function(ctx, callback) {
        if (typeof ctx === 'undefined') {
            ctx = {};
        }
        var that = this;
        this.analizeRoot(ctx, function(err, notUsed) {
            if (err) {
                return callback(err);
            }
            that.analizeFragment(ctx, function(err, notUsed) {
                if (err) {
                    return callback(err);
                }
                if (that.isCodeDeclare() == false && that.isMultilineDeclare() == false) {
                    async.map(that.children, function(c, callback) {
                        if (c.commentState == 0) {
                            return c.analize(ctx, callback);
                        }
                        else {
                            return callback();
                        }
                    }, function(err, notUsed) {
                        if (err) {
                            return callback(err);
                        }
                        return callback();
                    });
                }
                else {
                    return callback();
                }
            });
        });
    }
    IttfMTreeEx.prototype.analizeRoot = function(ctx, callback) {
        var r = this.root();
        if (this == r && ctx.rootFolder && r.model && r.model.jsonTwinUri && r.model.jsonTwinUri.length > 0) {
            r.file.isFile(r.model.jsonTwinUri, function(err, isFile) {
                if (err) {
                    return callback(err);
                }
                if (isFile) {
                    var fragment = {
                        oper: 'ittfReference', 
                        baseUri: verify.unixifyPath(r.model.dirname), 
                        name: path.basename(r.model.jsonTwinUri), 
                        uri: r.model.jsonTwinUri, 
                        id: 'unknown', 
                        relUri: verify.unixifyPath(path.relative(ctx.rootFolder, r.model.jsonTwinUri))
                    };
                    r.ittfReferences[fragment.name] = fragment;
                }
                return callback();
            });
        }
        else {
            return callback();
        }
    }
    IttfMTreeEx.prototype.analizeFragment = function(ctx, callback) {
        if (this.isMixinCall() == false && this.isIncludeCall() == false && this.isReferenceToIttf() == false) {
            return callback();
        }
        if (this.isReferenceToIttf() && !(ctx && ctx.rootFolder)) {
            return callback();
        }
        // log 'analizeFragment', this.name, this.value
        var r = this.root();
        if (typeof r.model === 'undefined') {
            return callback(new Error('wizzi-utils.ittfMTreeEx.analize require a `model` object in the root node. For example when created calling ittfMTreeEx.createFrom(documentUri)'));
        }
        if (r.model.uri.indexOf('__copy') > -1) {
            // TODO why false ???
            return callback(null, false);
        }
        if (this.isMixinCall()) {
            this.fragmentName = verify.endsWith(this.name, '(') ? this.name.substr(0, this.name.length -1) : this.name;
        }
        else if (this.isIncludeCall()) {
            this.fragmentName = this.getValueStripComments();
        }
        else {
            this.fragmentName = this.getValueStripComments();
        }
        var fragment = {
            oper: this.isMixinCall() ? 'mix' : this.isIncludeCall() ? 'include' : 'ittfReference', 
            baseUri: verify.unixifyPath(path.dirname(r.model.uri)), 
            name: this.fragmentName, 
            uri: 'unknown', 
            id: 'unknown'
        };
        var that = this;
        this.__getFragmentPath(ctx, function(err, fragmentPath) {
            if (err) {
                return callback(err);
            }
            if (fragmentPath.__is_error) {
                fragment.__is_error = true;
                fragment.message = 'NotFound in repository';
                r.errorFragments.push(fragment);
                console.log('wizzi-utils.ittfMTreeEx.analizeFragment.error', fragmentPath, fragment);
                return callback();
            }
            else {
                fragment.uri = verify.unixifyPath(fragmentPath);
                if (ctx && ctx.ittfBasePath && ctx.ittfFsNode) {
                    var mixinIttfFsNodePath = path.relative(ctx.ittfBasePath, fragmentPath);
                    var fragmentDocument = ctx.ittfFsNode.searchDocument(mixinIttfFsNodePath);
                    if (!fragmentDocument) {
                        console.log('wizzi-utils.ittfMTreeEx.analize.fragmentNotFound in ittfFsNode', unixify(mixinIttfFsNodePath), unixify(fragmentPath));
                        fragment.__is_error = true;
                        fragment.message = 'NotFound in ittfFsNode documents.';
                        r.errorFragments.push(fragment);
                        if (ctx.externalFragments) {
                            ctx.externalFragments[that.fragmentName] = fragment;
                        }
                    }
                    else {
                        fragment.id = fragmentDocument.id;
                        if (that.isReferenceToIttf()) {
                            if (ctx.ittfReferences) {
                                ctx.ittfReferences[that.fragmentName] = fragment;
                            }
                        }
                        else {
                            if (ctx.fragments) {
                                ctx.fragments[that.fragmentName] = fragment;
                            }
                        }
                    }
                }
                if (ctx && ctx.rootFolder) {
                    fragment.relUri = verify.unixifyPath(path.relative(ctx.rootFolder, fragmentPath));
                }
                if (that.isReferenceToIttf()) {
                    // do not override
                    if (!r.ittfReferences[that.fragmentName]) {
                        r.ittfReferences[that.fragmentName] = fragment;
                    }
                }
                else {
                    // do not override
                    if (!r.fragments[that.fragmentName]) {
                        r.fragments[that.fragmentName] = fragment;
                    }
                }
                return callback();
            }
        });
    }
    IttfMTreeEx.prototype.__getFragmentPath = function(ctx, callback) {
        var r = this.root(),
            fragmentPath;
        if (this.isReferenceToIttf() && ctx && verify.isNotEmpty(ctx.rootFolder)) {
            // log "ittfMTreeEx.__getFragmentPath.this.fragmentName, ctx.rootFolder", this.fragmentName, ctx.rootFolder
            if (this.fragmentName[0] === '/') {
                fragmentPath = path.join(ctx.rootFolder, this.fragmentName);
            }
            else {
                fragmentPath = path.resolve(r.model.dirname, this.fragmentName);
            }
            // log '__getFragmentPath.fragmentPath', fragmentPath
            r.file.isFile(fragmentPath, function(err, isFile) {
                if (err) {
                    return callback(err);
                }
                if (isFile) {
                    return callback(null, fragmentPath);
                }
                else {
                    return callback(null, {
                            __is_error: true, 
                            uri: fragmentPath
                        });
                }
            });
        }
        else {
            var ittfFinder = new IttfFinder(r.file);
            var that = this;
            ittfFinder.resolvePath({
                callerFullPath: r.model.uri, 
                fragmentName: this.fragmentName
            }, function(err, result) {
                if (err) {
                    return callback(null, {
                            __is_error: true, 
                            fragment: that.fragmentName, 
                            message: err.message
                        });
                }
                else {
                    return callback(null, result);
                }
            });
        }
    }
    IttfMTreeEx.prototype.find = function(name) {
        if (verify.isNotEmpty(name)) {
            return this._findByName(name);
        }
        else if (verify.isObject(name) && verify.isNumber(name.id)) {
            return this._findById(name.id);
        }
        else {
            throw new Error('wizzi-utils.ittfMTreeEx.find. Invalid argument name: ' + name);
        }
    }
    IttfMTreeEx.prototype._findByName = function(name) {
        if (this.name === name) {
            return this;
        }
        var found = null;
        var i, i_items=this.children, i_len=this.children.length, item;
        for (i=0; i<i_len; i++) {
            item = this.children[i];
            found = item._findByName(name);
            if (found) {
                break;
            }
        }
        return found;
    }
    IttfMTreeEx.prototype._findById = function(id) {
        if (this.id === id) {
            return this;
        }
        var found = null;
        var i, i_items=this.children, i_len=this.children.length, item;
        for (i=0; i<i_len; i++) {
            item = this.children[i];
            found = item._findById(id);
            if (found) {
                break;
            }
        }
        return found;
    }
    IttfMTreeEx.prototype.findByRow = function(row) {
        if (this.row === row) {
            return this;
        }
        var found = null;
        var i, i_items=this.children, i_len=this.children.length, item;
        for (i=0; i<i_len; i++) {
            item = this.children[i];
            found = item.findByRow(row);
            if (found) {
                break;
            }
        }
        return found;
    }
    IttfMTreeEx.prototype.equals = function(other) {
        // log 'wizzi-utils.ittfMTreeEx.equals', this.name, this.value, other.name, other.value
        if (this.name !== other.name || this.value !== other.value) {
            return false;
        }
        if (this.children.length !== other.children.length) {
            return false;
        }
        var eq = true;
        for (var i=0; i<this.children.length; i++) {
            eq = this.children[i].equals(other.children[i]);
            if (!eq) {
                break;
            }
        }
        return eq;
    }
    return IttfMTreeEx;
})();

function indentTabs(num) {
    var ret = [];
    for (var i=0; i<num; i++) {
        ret.push('\t');
    }
    return ret.join('');
}
function unixify(path) {
    return verify.replaceAll(path, '\\', '/');
}
module.exports = IttfMTreeEx;
